warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /home/steven/code/tree-sitter-perl/crates/perl-lexer/Cargo.toml
workspace: /home/steven/code/tree-sitter-perl/Cargo.toml
warning: unused variable: `indented`
   --> crates/perl-lexer/src/lib.rs:300:13
    |
300 |         let indented = if self.current_char() == Some('~') {
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_indented`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `delimiter`
   --> crates/perl-lexer/src/lib.rs:318:13
    |
318 |         let delimiter = if self.position < self.input.len() {
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_delimiter`

warning: unused variable: `delim`
   --> crates/perl-lexer/src/lib.rs:326:33
    |
326 | ...                   let delim = self.input[delim_start..self.position].to_string();
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_delim`

warning: unused variable: `delim`
   --> crates/perl-lexer/src/lib.rs:340:33
    |
340 | ...                   let delim = self.input[delim_start..self.position].to_string();
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_delim`

warning: method `matches_bytes` is never used
   --> crates/perl-lexer/src/lib.rs:240:8
    |
54  | impl<'a> PerlLexer<'a> {
    | ---------------------- method in this implementation
...
240 |     fn matches_bytes(&self, pattern: &[u8]) -> bool {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: constant `KEYWORDS` is never used
    --> crates/perl-lexer/src/lib.rs:1479:7
     |
1479 | const KEYWORDS: &[&str] = &[
     |       ^^^^^^^^

warning: constant `COMPOUND_SECOND_CHARS` is never used
    --> crates/perl-lexer/src/lib.rs:1510:7
     |
1510 | const COMPOUND_SECOND_CHARS: &[u8] = b"=<>&|+->.~*";
     |       ^^^^^^^^^^^^^^^^^^^^^

warning: `perl-lexer` (lib) generated 7 warnings
   Compiling tree-sitter-perl v0.1.0 (/home/steven/code/tree-sitter-perl/crates/tree-sitter-perl-rs)
warning: unused import: `PerlParser`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:6:31
  |
6 | use crate::pure_rust_parser::{PerlParser, AstNode, PureRustPerlParser};
  |                               ^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `crate::error::ParseError`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:8:5
  |
8 | use crate::error::ParseError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

warning: unused import: `pest::Parser`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:7:5
  |
7 | use pest::Parser;
  |     ^^^^^^^^^^^^

warning: unused variable: `pattern_start`
   --> crates/tree-sitter-perl-rs/src/context_aware_parser.rs:177:34
    |
177 | ...                   pattern_start: usize,
    |                       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pattern_start`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `quoted`
   --> crates/tree-sitter-perl-rs/src/runtime_heredoc_handler.rs:111:21
    |
111 |                 let quoted = !cap.get(1).unwrap().as_str().is_empty();
    |                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_quoted`

warning: unused variable: `recovery_state`
   --> crates/tree-sitter-perl-rs/src/understanding_parser.rs:219:9
    |
219 |         recovery_state: &mut RecoveryState,
    |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_recovery_state`

warning: unused variable: `context`
   --> crates/tree-sitter-perl-rs/src/dynamic_delimiter_recovery.rs:179:48
    |
179 |     fn try_resolve_variable(&self, expr: &str, context: &ParseContext) -> Option<&PossibleValue> {
    |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `tokens`
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:491:29
    |
491 |     fn build_context(&self, tokens: &[Token], position: usize) -> ParseContext {
    |                             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_tokens`

warning: unused variable: `position`
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:491:47
    |
491 |     fn build_context(&self, tokens: &[Token], position: usize) -> ParseContext {
    |                                               ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_position`

warning: variable does not need to be mutable
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:492:13
    |
492 |         let mut context = ParseContext {
    |             ----^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `e`
  --> crates/tree-sitter-perl-rs/src/disambiguated_parser.rs:31:23
   |
31 |             .map_err(|e| {
   |                       ^ help: if this is intentional, prefix it with an underscore: `_e`

warning: field `inner` is never read
 --> crates/tree-sitter-perl-rs/src/pest_only.rs:8:5
  |
7 | pub struct PestOnlyParser {
  |            -------------- field in this struct
8 |     inner: PureRustPerlParser,
  |     ^^^^^
  |
  = note: `#[warn(dead_code)]` on by default

warning: fields `context_stack` and `eval_cache` are never read
  --> crates/tree-sitter-perl-rs/src/context_aware_parser.rs:28:5
   |
24 | pub struct ContextAwareHeredocParser<'a> {
   |            ------------------------- fields in this struct
...
28 |     context_stack: Vec<ParseContext>,
   |     ^^^^^^^^^^^^^
29 |     /// Cached eval content for re-parsing
30 |     eval_cache: HashMap<String, Vec<HeredocDeclaration>>,
   |     ^^^^^^^^^^

warning: fields `pattern_start` and `pattern_end` are never read
   --> crates/tree-sitter-perl-rs/src/context_aware_parser.rs:209:9
    |
208 |     SubstitutionWithE {
    |     ----------------- fields in this variant
209 |         pattern_start: usize,
    |         ^^^^^^^^^^^^^
210 |         pattern_end: usize,
    |         ^^^^^^^^^^^
    |
    = note: `ContextInfo` has a derived impl for the trait `Debug`, but this is intentionally ignored during dead code analysis

warning: field `source` is never read
   --> crates/tree-sitter-perl-rs/src/encoding_aware_lexer.rs:297:5
    |
295 | pub struct EncodingAwareHeredocScanner<'a> {
    |            --------------------------- field in this struct
296 |     lexer: &'a mut EncodingAwareLexer,
297 |     source: &'a str,
    |     ^^^^^^

warning: fields `expr_delimiter`, `spaced_delimiter`, and `concat_delimiter` are never read
  --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:51:5
   |
47 | struct HeredocMatchers {
   |        --------------- fields in this struct
...
51 |     expr_delimiter: Regex,
   |     ^^^^^^^^^^^^^^
52 |     /// Pattern for << $var (with space)
53 |     spaced_delimiter: Regex,
   |     ^^^^^^^^^^^^^^^^
...
57 |     concat_delimiter: Regex,
   |     ^^^^^^^^^^^^^^^^

warning: field `source` is never read
  --> crates/tree-sitter-perl-rs/src/sexp_formatter.rs:26:5
   |
25 | pub struct SexpFormatter {
   |            ------------- field in this struct
26 |     source: String,
   |     ^^^^^^

warning: fields `buffer` and `pending_heredocs` are never read
  --> crates/tree-sitter-perl-rs/src/streaming_parser.rs:71:5
   |
68 | pub struct StreamingParser<R: Read> {
   |            --------------- fields in this struct
...
71 |     buffer: String,
   |     ^^^^^^
...
75 |     pending_heredocs: VecDeque<HeredocDeclaration>,
   |     ^^^^^^^^^^^^^^^^

warning: field `uri` is never read
   --> crates/tree-sitter-perl-rs/src/lsp_server.rs:139:5
    |
138 | struct DocumentState {
    |        ------------- field in this struct
139 |     uri: String,
    |     ^^^

warning: enum `BracketType` is never used
 --> crates/tree-sitter-perl-rs/src/statement_tracker.rs:8:6
  |
8 | enum BracketType {
  |      ^^^^^^^^^^^

warning: struct `StatementTracker` is never constructed
  --> crates/tree-sitter-perl-rs/src/statement_tracker.rs:15:12
   |
15 | pub struct StatementTracker {
   |            ^^^^^^^^^^^^^^^^

warning: associated items `new`, `process_char`, `is_balanced`, and `reset` are never used
   --> crates/tree-sitter-perl-rs/src/statement_tracker.rs:22:12
    |
21  | impl StatementTracker {
    | --------------------- associated items in this implementation
22  |     pub fn new() -> Self {
    |            ^^^
...
31  |     pub fn process_char(&mut self, ch: char, prev_char: Option<char>) -> bool {
    |            ^^^^^^^^^^^^
...
101 |     pub fn is_balanced(&self) -> bool {
    |            ^^^^^^^^^^^
...
106 |     pub fn reset(&mut self) {
    |            ^^^^^

warning: `tree-sitter-perl` (lib) generated 22 warnings (run `cargo fix --lib -p tree-sitter-perl` to apply 3 suggestions)
    Finished `dev` profile [unoptimized + debuginfo] target(s) in 28.99s
     Running `target/debug/examples/edge_case_demo`
=== Perl Heredoc Edge Case Demo ===


--- Example 1: Dynamic Delimiters ---
Found 0 dynamic delimiter issues

--- Example 2: Phase-Dependent Heredocs ---
Phase warnings:
  ⚠️  Entering BEGIN block at line 3 - heredocs may have compile-time effects

Recommended actions:
  • RefactorCode { reason: "BEGIN-time heredocs can modify compile-time state", suggestion: "Move heredoc initialization to INIT block or runtime" }

--- Example 3: Multiple Edge Cases ---
Edge case summary:
  Total issues: 1
  - 1 errors
  - 0 warnings
  - 0 info messages

First 3 diagnostics:
  1. Dynamic heredoc delimiter: <<$delim
     Fix: Use a static delimiter with variable interpolation inside the heredoc:

my $content = <<"END";
Dynamic value: $variable
END

--- Example 4: Recovery Modes ---

  Recovery mode: Conservative

  Recovery mode: BestGuess

  Recovery mode: Interactive

  Recovery mode: Sandbox

=== Summary ===
The edge case handler can:
  ✓ Detect dynamic delimiters and attempt recovery
  ✓ Identify phase-dependent heredocs (BEGIN/CHECK/etc)
  ✓ Warn about source filters and tied handles
  ✓ Provide actionable recommendations
  ✓ Support multiple recovery strategies
