<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>DAP Implementation - Perl LSP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the perl-lsp project - a production-ready Perl Language Server Protocol implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Perl LSP Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/EffortlessMetrics/tree-sitter-perl-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="dap-crate-architecture-specification"><a class="header" href="#dap-crate-architecture-specification">DAP Crate Architecture Specification</a></h1>
<!-- Labels: architecture:dap, crate:perl-dap, integration:lsp -->
<p><strong>Issue</strong>: #207 - Debug Adapter Protocol Support
<strong>Status</strong>: Architecture Design Complete
<strong>Version</strong>: 1.0.0
<strong>Date</strong>: 2025-10-04</p>
<hr />
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive Summary</a></h2>
<p>This specification defines the crate-level architecture for the perl-dap implementation, integrating with the existing Perl LSP ecosystem. The design follows separation-of-concerns principles while maximizing reuse of existing infrastructure (AST integration, incremental parsing, workspace navigation, security framework).</p>
<p><strong>Key Components</strong>:</p>
<ul>
<li><strong>perl-dap</strong> (new crate): Standalone DAP adapter binary</li>
<li><strong>Devel::TSPerlDAP</strong> (CPAN module): Perl runtime shim</li>
<li><strong>perl-parser</strong> (integration): AST-based breakpoint validation</li>
<li><strong>perl-lsp</strong> (integration): LSP ↔ DAP coordination</li>
</ul>
<p><strong>Design Principles</strong>:</p>
<ul>
<li>Clean separation between LSP and DAP protocols</li>
<li>Optional dependency: LSP server can run without DAP</li>
<li>Focused testing: DAP-specific test infrastructure</li>
<li>Independent versioning: DAP features evolve separately from LSP</li>
</ul>
<hr />
<h2 id="1-workspace-structure"><a class="header" href="#1-workspace-structure">1. Workspace Structure</a></h2>
<h3 id="11-crate-organization"><a class="header" href="#11-crate-organization">1.1 Crate Organization</a></h3>
<pre><code>crates/
├── perl-parser/          # Core parser (unchanged)
│   ├── src/
│   │   ├── lib.rs
│   │   ├── parser.rs
│   │   ├── workspace_index.rs  # Used by DAP for stack frame resolution
│   │   ├── textdoc.rs          # Used by DAP for position mapping
│   │   └── ...
│   └── Cargo.toml
│
├── perl-lsp/             # LSP server binary (unchanged)
│   ├── src/
│   │   ├── main.rs
│   │   └── ...
│   └── Cargo.toml
│
├── perl-dap/             # NEW - DAP adapter binary
│   ├── src/
│   │   ├── main.rs       # Adapter entry point
│   │   ├── lib.rs        # Public API for integration testing
│   │   ├── protocol/
│   │   │   ├── mod.rs    # DAP protocol types and serialization
│   │   │   ├── request.rs
│   │   │   ├── response.rs
│   │   │   └── event.rs
│   │   ├── session/
│   │   │   ├── mod.rs    # Session state management
│   │   │   ├── lifecycle.rs
│   │   │   └── state.rs
│   │   ├── breakpoints/
│   │   │   ├── mod.rs    # Breakpoint manager with AST validation
│   │   │   └── validator.rs
│   │   ├── variables/
│   │   │   ├── mod.rs    # Variable rendering and lazy expansion
│   │   │   └── renderer.rs
│   │   ├── stack/
│   │   │   ├── mod.rs    # Stack trace provider
│   │   │   └── resolver.rs
│   │   ├── shim/
│   │   │   ├── mod.rs    # Perl shim communication
│   │   │   ├── protocol.rs
│   │   │   └── process.rs
│   │   ├── security/
│   │   │   ├── mod.rs    # Security validation (path, eval, timeout)
│   │   │   └── validator.rs
│   │   └── platform/
│   │       ├── mod.rs    # Platform-specific code
│   │       ├── unix.rs
│   │       └── windows.rs
│   ├── tests/
│   │   ├── integration_tests.rs      # Golden transcript validation (AC13)
│   │   ├── breakpoint_validation.rs  # Breakpoint matrix tests (AC7)
│   │   ├── variable_rendering.rs     # Variable rendering tests (AC8)
│   │   ├── control_flow_performance.rs  # Stepping performance (AC9)
│   │   ├── eval_security.rs          # Safe eval validation (AC10)
│   │   ├── security_validation.rs    # Enterprise security (AC16)
│   │   ├── cross_platform_validation.rs  # Platform compatibility (AC12)
│   │   └── fixtures/
│   │       ├── hello.pl
│   │       ├── args.pl
│   │       ├── eval.pl
│   │       └── loops.pl
│   ├── benches/
│   │   └── dap_benchmarks.rs         # Performance benchmarks (AC14)
│   └── Cargo.toml
│
├── perl-lexer/           # Tokenizer (unchanged)
└── perl-corpus/          # Test corpus (unchanged)

vscode-extension/
├── package.json          # Add contributes.debuggers (AC1, AC11)
├── snippets/
│   └── launch.json       # Launch.json snippets (AC2)
├── src/
│   ├── debugAdapter.ts   # Bridge adapter (Phase 1)
│   ├── nativeDapAdapter.ts  # Native adapter interface (Phase 2)
│   └── dapBinaryManager.ts  # Platform binary management (AC19)
└── resources/
    ├── dap-binaries/     # Platform binaries (AC19)
    │   ├── linux-x64/
    │   ├── linux-arm64/
    │   ├── darwin-x64/
    │   ├── darwin-arm64/
    │   ├── win32-x64/
    │   └── win32-arm64/
    └── perl-shim/        # Bundled fallback (AC18)
        └── Devel/
            └── TSPerlDAP.pm

Devel-TSPerlDAP/          # NEW - CPAN module (separate repo or subdir)
├── lib/
│   └── Devel/
│       └── TSPerlDAP.pm  # Perl shim implementation
├── t/
│   ├── 01-set-breakpoints.t
│   ├── 02-stack-trace.t
│   ├── 03-variables.t
│   ├── 04-evaluate.t
│   └── 05-control-flow.t
├── META.json
├── Makefile.PL
└── README.pod
</code></pre>
<hr />
<h2 id="2-perl-dap-crate-design"><a class="header" href="#2-perl-dap-crate-design">2. perl-dap Crate Design</a></h2>
<h3 id="21-dependencies"><a class="header" href="#21-dependencies">2.1 Dependencies</a></h3>
<pre><code class="language-toml"># crates/perl-dap/Cargo.toml
[package]
name = "perl-dap"
version = "0.1.0"
edition = "2024"
authors = ["Tree-sitter Perl Contributors"]
description = "Debug Adapter Protocol server for Perl"
license = "MIT OR Apache-2.0"

[[bin]]
name = "perl-dap"
path = "src/main.rs"

[lib]
name = "perl_dap"
path = "src/lib.rs"

[dependencies]
# Core parser integration
perl-parser = { path = "../perl-parser", version = "0.8.9" }

# LSP types reuse (Position, Range, Location, etc.)
lsp-types = "0.97.0"

# JSON serialization
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"

# Error handling
anyhow = "1.0"
thiserror = "2.0"

# Async runtime
tokio = { version = "1.0", features = ["full"] }

# Logging
tracing = "0.1"
tracing-subscriber = { version = "0.3", features = ["env-filter"] }

# Rope for position mapping (reuse from perl-parser)
ropey = "1.6"

# Process management
tokio-process = "0.2"

[dev-dependencies]
# Property-based testing (AC13)
proptest = "1.0"

# Performance benchmarking (AC14)
criterion = "0.5"

# Test fixtures
tempfile = "3.0"

# Golden transcript validation
serde_yaml = "0.9"

[target.'cfg(unix)'.dependencies]
nix = "0.28"  # For SIGINT handling

[target.'cfg(windows)'.dependencies]
winapi = { version = "0.3", features = ["processthreadsapi"] }  # For Ctrl+C
</code></pre>
<h3 id="22-module-structure"><a class="header" href="#22-module-structure">2.2 Module Structure</a></h3>
<h4 id="221-main-entry-point"><a class="header" href="#221-main-entry-point">2.2.1 Main Entry Point</a></h4>
<pre><pre class="playground"><code class="language-rust">// crates/perl-dap/src/main.rs
use perl_dap::{DapServer, DapConfig};
use tracing::info;

#[tokio::main]
async fn main() -&gt; anyhow::Result&lt;()&gt; {
    // Initialize logging
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::EnvFilter::from_default_env())
        .init();

    // Parse command-line arguments
    let config = DapConfig::from_args()?;

    info!("Starting perl-dap adapter version {}", env!("CARGO_PKG_VERSION"));

    // Create DAP server
    let mut server = DapServer::new(config)?;

    // Run stdio transport
    server.run_stdio().await?;

    Ok(())
}</code></pre></pre>
<h4 id="222-library-api"><a class="header" href="#222-library-api">2.2.2 Library API</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/lib.rs
//! Debug Adapter Protocol server for Perl
//!
//! This crate provides a production-grade DAP adapter for debugging Perl code.
//! It integrates with the perl-parser crate for AST-based breakpoint validation
//! and leverages existing LSP infrastructure for position mapping and workspace navigation.

mod protocol;
mod session;
mod breakpoints;
mod variables;
mod stack;
mod shim;
mod security;
mod platform;

pub use protocol::{DapRequest, DapResponse, DapEvent};
pub use session::{DapSession, SessionState};
pub use breakpoints::{BreakpointManager, BreakpointVerification};

use anyhow::Result;
use tokio::io::{AsyncBufReadExt, AsyncWriteExt, BufReader};
use tokio::sync::Mutex;
use std::sync::Arc;

/// DAP server configuration
pub struct DapConfig {
    pub log_level: String,
    pub install_shim: bool,  // For --install-shim command (AC18)
}

impl DapConfig {
    pub fn from_args() -&gt; Result&lt;Self&gt; {
        // Parse command-line arguments
        let args: Vec&lt;String&gt; = std::env::args().collect();

        Ok(Self {
            log_level: "info".to_string(),
            install_shim: args.contains(&amp;"--install-shim".to_string()),
        })
    }
}

/// Main DAP server
pub struct DapServer {
    config: DapConfig,
    session: Arc&lt;Mutex&lt;Option&lt;DapSession&gt;&gt;&gt;,
    seq: Arc&lt;std::sync::atomic::AtomicI64&gt;,
}

impl DapServer {
    pub fn new(config: DapConfig) -&gt; Result&lt;Self&gt; {
        Ok(Self {
            config,
            session: Arc::new(Mutex::new(None)),
            seq: Arc::new(std::sync::atomic::AtomicI64::new(1)),
        })
    }

    /// Run DAP server over stdio transport
    pub async fn run_stdio(&amp;mut self) -&gt; Result&lt;()&gt; {
        use tokio::io::{stdin, stdout};

        let stdin = BufReader::new(stdin());
        let mut stdout = stdout();

        let mut lines = stdin.lines();

        while let Some(line) = lines.next_line().await? {
            // Parse Content-Length header
            if line.starts_with("Content-Length:") {
                let content_length: usize = line
                    .split(':')
                    .nth(1)
                    .ok_or_else(|| anyhow::anyhow!("Invalid Content-Length header"))?
                    .trim()
                    .parse()?;

                // Skip blank line
                lines.next_line().await?;

                // Read message body
                let mut buffer = vec![0u8; content_length];
                // Note: This simplified example needs proper async reading
                // In production, use tokio::io::AsyncReadExt::read_exact

                let request: DapRequest = serde_json::from_slice(&amp;buffer)?;

                // Handle request
                let response = self.handle_request(request).await?;

                // Serialize response
                let response_json = serde_json::to_string(&amp;response)?;

                // Write response with Content-Length header
                let header = format!("Content-Length: {}\r\n\r\n", response_json.len());
                stdout.write_all(header.as_bytes()).await?;
                stdout.write_all(response_json.as_bytes()).await?;
                stdout.flush().await?;
            }
        }

        Ok(())
    }

    /// Handle DAP request
    async fn handle_request(&amp;self, request: DapRequest) -&gt; Result&lt;DapResponse&gt; {
        match request.command.as_str() {
            "initialize" =&gt; self.handle_initialize(request).await,
            "launch" =&gt; self.handle_launch(request).await,
            "attach" =&gt; self.handle_attach(request).await,
            "setBreakpoints" =&gt; self.handle_set_breakpoints(request).await,
            "continue" =&gt; self.handle_continue(request).await,
            "next" =&gt; self.handle_next(request).await,
            "stepIn" =&gt; self.handle_step_in(request).await,
            "stepOut" =&gt; self.handle_step_out(request).await,
            "pause" =&gt; self.handle_pause(request).await,
            "threads" =&gt; self.handle_threads(request).await,
            "stackTrace" =&gt; self.handle_stack_trace(request).await,
            "scopes" =&gt; self.handle_scopes(request).await,
            "variables" =&gt; self.handle_variables(request).await,
            "evaluate" =&gt; self.handle_evaluate(request).await,
            "disconnect" =&gt; self.handle_disconnect(request).await,
            _ =&gt; self.handle_unknown_command(request),
        }
    }

    async fn handle_initialize(&amp;self, request: DapRequest) -&gt; Result&lt;DapResponse&gt; {
        Ok(DapResponse {
            seq: self.next_seq(),
            type_: "response".to_string(),
            request_seq: request.seq,
            success: true,
            command: "initialize".to_string(),
            message: None,
            body: Some(serde_json::json!({
                "supportsConfigurationDoneRequest": true,
                "supportsEvaluateForHovers": true,
                "supportsStepInTargetsRequest": false,
                "supportsSetVariable": false,
                "supportsConditionalBreakpoints": false,
                "supportsExceptionBreakpoints": false,
            })),
        })
    }

    // Additional handlers omitted for brevity...

    fn next_seq(&amp;self) -&gt; i64 {
        self.seq.fetch_add(1, std::sync::atomic::Ordering::SeqCst)
    }

    fn handle_unknown_command(&amp;self, request: DapRequest) -&gt; Result&lt;DapResponse&gt; {
        Ok(DapResponse {
            seq: self.next_seq(),
            type_: "response".to_string(),
            request_seq: request.seq,
            success: false,
            command: request.command.clone(),
            message: Some(format!("Unknown command: {}", request.command)),
            body: None,
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="223-protocol-module"><a class="header" href="#223-protocol-module">2.2.3 Protocol Module</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/protocol/mod.rs
use serde::{Deserialize, Serialize};

/// DAP request message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DapRequest {
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: String,
    pub command: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub arguments: Option&lt;serde_json::Value&gt;,
}

/// DAP response message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DapResponse {
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: String,
    pub request_seq: i64,
    pub success: bool,
    pub command: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option&lt;String&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option&lt;serde_json::Value&gt;,
}

/// DAP event message
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DapEvent {
    pub seq: i64,
    #[serde(rename = "type")]
    pub type_: String,
    pub event: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub body: Option&lt;serde_json::Value&gt;,
}

// Request-specific argument types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LaunchRequestArguments {
    pub program: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub args: Option&lt;Vec&lt;String&gt;&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "perlPath")]
    pub perl_path: Option&lt;String&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "includePaths")]
    pub include_paths: Option&lt;Vec&lt;String&gt;&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub env: Option&lt;std::collections::HashMap&lt;String, String&gt;&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub cwd: Option&lt;String&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "stopOnEntry")]
    pub stop_on_entry: Option&lt;bool&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SetBreakpointsArguments {
    pub source: DapSource,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub breakpoints: Option&lt;Vec&lt;SourceBreakpoint&gt;&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DapSource {
    #[serde(skip_serializing_if = "Option::is_none")]
    pub path: Option&lt;String&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub name: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SourceBreakpoint {
    pub line: u32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub column: Option&lt;u32&gt;,
}

// Response-specific body types
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Breakpoint {
    pub id: i64,
    pub verified: bool,
    pub line: u32,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub column: Option&lt;u32&gt;,
    #[serde(skip_serializing_if = "Option::is_none")]
    pub message: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StackFrame {
    pub id: i64,
    pub name: String,
    pub source: DapSource,
    pub line: u32,
    pub column: u32,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "presentationHint")]
    pub presentation_hint: Option&lt;String&gt;,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Scope {
    pub name: String,
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
    pub expensive: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Variable {
    pub name: String,
    pub value: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(rename = "type")]
    pub type_: Option&lt;String&gt;,
    #[serde(rename = "variablesReference")]
    pub variables_reference: i64,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="224-breakpoint-manager"><a class="header" href="#224-breakpoint-manager">2.2.4 Breakpoint Manager</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/breakpoints/mod.rs
use perl_parser::{Parser, ast::Node};
use ropey::Rope;
use std::collections::HashMap;
use std::sync::Arc;
use anyhow::Result;

pub struct BreakpointManager {
    parser: Arc&lt;Parser&gt;,
    breakpoints: HashMap&lt;String, Vec&lt;Breakpoint&gt;&gt;,
    next_id: i64,
}

#[derive(Debug, Clone, PartialEq)]
pub enum BreakpointVerification {
    Verified { line: u32 },
    Invalid { reason: String },
}

impl BreakpointManager {
    pub fn new(parser: Arc&lt;Parser&gt;) -&gt; Self {
        Self {
            parser,
            breakpoints: HashMap::new(),
            next_id: 1,
        }
    }

    /// Verify breakpoint line using AST analysis (AC7)
    /// Performance target: &lt;50ms
    ///
    /// Implementation Note: Uses perl_parser::Parser::parse() which returns ast::Node.
    /// AST validation utilities (is_comment_or_blank_line, is_inside_string_literal, etc.)
    /// are implemented in perl-dap crate (see DAP_BREAKPOINT_VALIDATION_GUIDE.md).
    pub fn verify_breakpoint(&amp;self, uri: &amp;str, line: u32, rope: &amp;Rope) -&gt; Result&lt;BreakpointVerification&gt; {
        // Parse source text using existing Parser::new() and parse() API
        let source = rope.to_string();
        let mut parser = Parser::new(&amp;source);
        let ast = parser.parse()?;

        // Get byte offsets for the line using Rope
        let line_start = rope.line_to_byte(line as usize);
        let line_end = if (line as usize) &lt; rope.len_lines() - 1 {
            rope.line_to_byte(line as usize + 1)
        } else {
            rope.len_bytes()
        };

        // Validate line contains executable code using DAP AST utilities
        if is_comment_or_blank_line(&amp;ast, line_start, line_end, &amp;source) {
            return Ok(BreakpointVerification::Invalid {
                reason: "Line contains only comments or whitespace".to_string()
            });
        }

        // Validate not inside string literal or heredoc using AST node type analysis
        if is_inside_string_literal(&amp;ast, line_start) {
            return Ok(BreakpointVerification::Invalid {
                reason: "Line is inside string literal or heredoc".to_string()
            });
        }

        // Validate not inside POD documentation using text scanning
        if is_inside_pod(&amp;source, line_start) {
            return Ok(BreakpointVerification::Invalid {
                reason: "Line is inside POD documentation".to_string()
            });
        }

        // Adjust to nearest executable line if needed
        let adjusted_line = self.adjust_to_executable_line(&amp;ast, line, rope);

        Ok(BreakpointVerification::Verified { line: adjusted_line })
    }

    fn adjust_to_executable_line(&amp;self, ast: &amp;Node, line: u32, rope: &amp;Rope) -&gt; u32 {
        // Search forward for next executable line (max 5 lines)
        for offset in 0..5 {
            let candidate = line + offset;
            if (candidate as usize) &gt;= rope.len_lines() {
                break;
            }

            let line_start = rope.line_to_byte(candidate as usize);
            let line_end = rope.line_to_byte(candidate as usize + 1);

            if is_executable_line(ast, line_start, line_end) {
                return candidate;
            }
        }

        line // Fallback to original line
    }

    /// Set breakpoints for a source file
    pub fn set_breakpoints(
        &amp;mut self,
        uri: &amp;str,
        requested: Vec&lt;(u32, Option&lt;u32&gt;)&gt;, // (line, column)
    ) -&gt; Result&lt;Vec&lt;Breakpoint&gt;&gt; {
        let mut breakpoints = Vec::new();

        for (line, column) in requested {
            let verification = self.verify_breakpoint(uri, line)?;

            let (verified, actual_line, message) = match verification {
                BreakpointVerification::Verified { line } =&gt; (true, line, None),
                BreakpointVerification::Invalid { reason } =&gt; (false, line, Some(reason)),
            };

            let breakpoint = Breakpoint {
                id: self.next_id,
                verified,
                line: actual_line,
                column,
                message,
            };

            self.next_id += 1;
            breakpoints.push(breakpoint.clone());
        }

        self.breakpoints.insert(uri.to_string(), breakpoints.clone());

        Ok(breakpoints)
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="225-variable-renderer"><a class="header" href="#225-variable-renderer">2.2.5 Variable Renderer</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/variables/mod.rs
use ropey::Rope;
use anyhow::Result;

pub struct VariableRenderer {
    // Variable expansion references
    expansion_refs: HashMap&lt;i64, ExpandableValue&gt;,
    next_ref: i64,
}

enum ExpandableValue {
    Array(Vec&lt;String&gt;),
    Hash(HashMap&lt;String, String&gt;),
}

impl VariableRenderer {
    pub fn new() -&gt; Self {
        Self {
            expansion_refs: HashMap::new(),
            next_ref: 1000,
        }
    }

    /// Render variable value with truncation and lazy expansion
    /// Performance target: &lt;200ms initial, &lt;100ms per child expansion
    pub fn render_value(&amp;mut self, value: &amp;PerlValue, rope: &amp;Rope) -&gt; Variable {
        match value {
            PerlValue::Scalar(s) =&gt; Variable {
                name: value.name(),
                value: self.render_scalar(s, rope),
                type_: Some("scalar".to_string()),
                variables_reference: 0,
            },
            PerlValue::Array(arr) =&gt; {
                let ref_id = self.allocate_expansion_ref(ExpandableValue::Array(arr.clone()));
                Variable {
                    name: value.name(),
                    value: format!("[{} items]", arr.len()),
                    type_: Some("array".to_string()),
                    variables_reference: ref_id,
                }
            },
            PerlValue::Hash(hash) =&gt; {
                let ref_id = self.allocate_expansion_ref(ExpandableValue::Hash(hash.clone()));
                Variable {
                    name: value.name(),
                    value: format!("{{{} keys}}", hash.len()),
                    type_: Some("hash".to_string()),
                    variables_reference: ref_id,
                }
            },
            PerlValue::CodeRef(code) =&gt; Variable {
                name: value.name(),
                value: self.render_coderef(code),
                type_: Some("code".to_string()),
                variables_reference: 0,
            },
        }
    }

    fn render_scalar(&amp;self, value: &amp;str, rope: &amp;Rope) -&gt; String {
        // Truncate large values (AC8: 1KB preview max)
        if value.len() &gt; 1024 {
            let truncated = &amp;value[..1024];

            // UTF-16 safe truncation (PR #153 infrastructure)
            let safe_truncate = ensure_utf16_boundary(truncated, rope);
            format!("{}…", safe_truncate)
        } else {
            value.to_string()
        }
    }

    fn render_coderef(&amp;self, code: &amp;str) -&gt; String {
        // Use B::Deparse representation from Perl shim
        format!("sub {{ {} }}", code)
    }

    fn allocate_expansion_ref(&amp;mut self, value: ExpandableValue) -&gt; i64 {
        let ref_id = self.next_ref;
        self.next_ref += 1;
        self.expansion_refs.insert(ref_id, value);
        ref_id
    }

    /// Expand variable reference to children
    pub fn expand_variable(&amp;self, ref_id: i64) -&gt; Result&lt;Vec&lt;Variable&gt;&gt; {
        let expandable = self.expansion_refs.get(&amp;ref_id)
            .ok_or_else(|| anyhow::anyhow!("Invalid variable reference: {}", ref_id))?;

        match expandable {
            ExpandableValue::Array(arr) =&gt; {
                Ok(arr.iter().enumerate().map(|(idx, val)| Variable {
                    name: format!("[{}]", idx),
                    value: val.clone(),
                    type_: Some("scalar".to_string()),
                    variables_reference: 0,
                }).collect())
            },
            ExpandableValue::Hash(hash) =&gt; {
                Ok(hash.iter().map(|(key, val)| Variable {
                    name: format!("{{{}}}", key),
                    value: val.clone(),
                    type_: Some("scalar".to_string()),
                    variables_reference: 0,
                }).collect())
            },
        }
    }
}

// Helper for UTF-16 safe truncation
fn ensure_utf16_boundary(s: &amp;str, _rope: &amp;Rope) -&gt; String {
    // Reuse perl-parser UTF-16 boundary validation (PR #153)
    // This is a simplified example; actual implementation would use
    // perl_lsp::textdoc::ensure_utf16_boundary

    s.to_string() // Placeholder
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="3-develtsperldap-cpan-module"><a class="header" href="#3-develtsperldap-cpan-module">3. Devel::TSPerlDAP CPAN Module</a></h2>
<h3 id="31-module-structure"><a class="header" href="#31-module-structure">3.1 Module Structure</a></h3>
<pre><code>Devel-TSPerlDAP/
├── lib/
│   └── Devel/
│       └── TSPerlDAP.pm
├── t/
│   ├── 01-set-breakpoints.t
│   ├── 02-stack-trace.t
│   ├── 03-variables.t
│   ├── 04-evaluate.t
│   └── 05-control-flow.t
├── META.json
├── Makefile.PL
└── README.pod
</code></pre>
<h3 id="32-core-implementation"><a class="header" href="#32-core-implementation">3.2 Core Implementation</a></h3>
<pre><code class="language-perl"># lib/Devel/TSPerlDAP.pm
package Devel::TSPerlDAP;

use strict;
use warnings;
use JSON::PP;
use IO::Socket::INET;
use PadWalker qw(peek_my peek_our);
use B::Deparse;

our $VERSION = '0.1.0';

# Global state
our %BREAKPOINTS;     # file =&gt; { line =&gt; 1 }
our $SERVER_SOCKET;
our $CLIENT_SOCKET;
our $JSON = JSON::PP-&gt;new-&gt;utf8;

sub import {
    my ($class, %opts) = @_;

    my $daemon = $opts{daemon} // 0;
    my $host = $opts{host} // '127.0.0.1';
    my $port = $opts{port} // 0;  # 0 = random port

    if ($daemon) {
        start_tcp_server($host, $port);
    } else {
        start_stdio_server();
    }
}

sub start_stdio_server {
    # Read JSON commands from STDIN, write responses to STDOUT
    while (my $line = &lt;STDIN&gt;) {
        chomp $line;
        my $request = eval { $JSON-&gt;decode($line) };

        if ($@) {
            print STDERR "JSON parse error: $@\n";
            next;
        }

        my $response = handle_command($request);
        print $JSON-&gt;encode($response), "\n";
    }
}

sub start_tcp_server {
    my ($host, $port) = @_;

    $SERVER_SOCKET = IO::Socket::INET-&gt;new(
        LocalAddr =&gt; $host,
        LocalPort =&gt; $port,
        Proto     =&gt; 'tcp',
        Listen    =&gt; 1,
        Reuse     =&gt; 1,
    ) or die "Cannot start TCP server: $!\n";

    # Print actual port for client discovery
    my $actual_port = $SERVER_SOCKET-&gt;sockport();
    print STDERR "TSPerlDAP listening on $host:$actual_port\n";

    # Accept single client connection
    $CLIENT_SOCKET = $SERVER_SOCKET-&gt;accept();

    # Read JSON commands from socket
    while (my $line = &lt;$CLIENT_SOCKET&gt;) {
        chomp $line;
        my $request = eval { $JSON-&gt;decode($line) };

        if ($@) {
            print STDERR "JSON parse error: $@\n";
            next;
        }

        my $response = handle_command($request);
        print $CLIENT_SOCKET $JSON-&gt;encode($response), "\n";
    }
}

sub handle_command {
    my ($request) = @_;

    my $command = $request-&gt;{command};

    # Dispatch to command handlers
    return set_breakpoints($request-&gt;{arguments})   if $command eq 'set_breakpoints';
    return continue_execution()                     if $command eq 'continue';
    return step_next()                              if $command eq 'next';
    return step_in()                                if $command eq 'step_in';
    return step_out()                               if $command eq 'step_out';
    return pause_execution()                        if $command eq 'pause';
    return get_stack_trace()                        if $command eq 'stack';
    return get_scopes($request-&gt;{arguments})        if $command eq 'scopes';
    return get_variables($request-&gt;{arguments})     if $command eq 'variables';
    return evaluate_expression($request-&gt;{arguments}) if $command eq 'evaluate';

    return { success =&gt; 0, message =&gt; "Unknown command: $command" };
}

sub set_breakpoints {
    my ($args) = @_;

    my $file = $args-&gt;{source}{path};
    my @breakpoints = @{$args-&gt;{breakpoints} // []};

    # Clear existing breakpoints for this file
    delete $BREAKPOINTS{$file};

    # Set new breakpoints using Perl debugger API
    foreach my $bp (@breakpoints) {
        my $line = $bp-&gt;{line};
        $BREAKPOINTS{$file}{$line} = 1;

        # Set debugger breakpoint
        $DB::single{$file}{$line} = 1;
    }

    return {
        success =&gt; 1,
        breakpoints =&gt; [
            map { { id =&gt; $_, verified =&gt; 1, line =&gt; $_ } } @breakpoints
        ]
    };
}

sub get_stack_trace {
    my @frames;
    my $i = 0;

    # Walk call stack using caller()
    while (my ($package, $file, $line, $sub) = caller($i++)) {
        # Skip internal frames (debugger, shim infrastructure)
        next if $package =~ /^(DB|Devel::TSPerlDAP)/;

        push @frames, {
            name =&gt; $sub,
            source =&gt; { path =&gt; $file },
            line =&gt; $line,
            column =&gt; 0,
        };
    }

    return {
        stackFrames =&gt; \@frames,
        totalFrames =&gt; scalar(@frames),
    };
}

sub get_scopes {
    my ($args) = @_;
    my $frame_id = $args-&gt;{frameId};

    # Return standard scopes: Locals, Package, Globals
    return {
        scopes =&gt; [
            {
                name =&gt; 'Locals',
                variablesReference =&gt; $frame_id * 1000 + 1,
                expensive =&gt; 0,
            },
            {
                name =&gt; 'Package',
                variablesReference =&gt; $frame_id * 1000 + 2,
                expensive =&gt; 0,
            },
        ]
    };
}

sub get_variables {
    my ($args) = @_;
    my $ref = $args-&gt;{variablesReference};

    # Decode scope type from reference
    my $frame_id = int($ref / 1000);
    my $scope_type = $ref % 1000;

    my @variables;

    if ($scope_type == 1) {
        # Locals: Use PadWalker to inspect lexical variables
        my $vars = peek_my($frame_id);

        foreach my $name (sort keys %$vars) {
            my $value = $vars-&gt;{$name};

            push @variables, {
                name =&gt; $name,
                value =&gt; render_value($value),
                type =&gt; ref($value) || 'scalar',
                variablesReference =&gt; is_expandable($value) ? allocate_ref($value) : 0,
            };
        }
    } elsif ($scope_type == 2) {
        # Package: Use peek_our for package variables
        my $vars = peek_our($frame_id);

        foreach my $name (sort keys %$vars) {
            my $value = $vars-&gt;{$name};

            push @variables, {
                name =&gt; $name,
                value =&gt; render_value($value),
                type =&gt; ref($value) || 'scalar',
                variablesReference =&gt; is_expandable($value) ? allocate_ref($value) : 0,
            };
        }
    }

    return { variables =&gt; \@variables };
}

sub render_value {
    my ($value) = @_;

    if (ref($value) eq 'CODE') {
        # Use B::Deparse for code refs
        my $deparse = B::Deparse-&gt;new();
        return $deparse-&gt;coderef2text($value);
    } elsif (ref($value) eq 'ARRAY') {
        return "[" . scalar(@$value) . " items]";
    } elsif (ref($value) eq 'HASH') {
        return "{" . scalar(keys %$value) . " keys}";
    } else {
        # Truncate large values (AC8: 1KB max)
        my $str = "$value";
        return length($str) &gt; 1024 ? substr($str, 0, 1024) . "…" : $str;
    }
}

sub is_expandable {
    my ($value) = @_;
    return ref($value) =~ /^(ARRAY|HASH)$/;
}

our %EXPANSION_REFS;
our $NEXT_REF = 3000;

sub allocate_ref {
    my ($value) = @_;

    my $ref_id = $NEXT_REF++;
    $EXPANSION_REFS{$ref_id} = $value;

    return $ref_id;
}

sub evaluate_expression {
    my ($args) = @_;
    my $expr = $args-&gt;{expression};
    my $frame_id = $args-&gt;{frameId};
    my $allow_side_effects = $args-&gt;{allowSideEffects} // 0;

    # Safe evaluation (AC10)
    my $result;
    eval {
        local $SIG{ALRM} = sub { die "timeout\n" };
        alarm(5);  # 5 second timeout

        if ($allow_side_effects) {
            # Full evaluation with write access
            $result = eval $expr;
        } else {
            # Safe evaluation: read-only mode
            # Note: This is a simplified check; production would use Safe.pm
            if ($expr =~ /=(?![=~])/) {
                die "Side effects not allowed without allowSideEffects flag\n";
            }
            $result = eval $expr;
        }

        alarm(0);
    };

    if ($@) {
        return {
            success =&gt; 0,
            message =&gt; "Evaluation failed: $@",
        };
    }

    return {
        success =&gt; 1,
        result =&gt; render_value($result),
        type =&gt; ref($result) || 'scalar',
        variablesReference =&gt; is_expandable($result) ? allocate_ref($result) : 0,
    };
}

# Control flow commands
sub continue_execution {
    $DB::single = 0;
    return { success =&gt; 1 };
}

sub step_next {
    $DB::single = 1;
    return { success =&gt; 1 };
}

sub step_in {
    $DB::single = 1;
    $DB::step = 1;
    return { success =&gt; 1 };
}

sub step_out {
    $DB::single = 0;
    $DB::trace = 1;
    return { success =&gt; 1 };
}

sub pause_execution {
    $DB::signal = 1;
    return { success =&gt; 1 };
}

1;

__END__

=head1 NAME

Devel::TSPerlDAP - Debug Adapter Protocol shim for Perl debugger

=head1 SYNOPSIS

    # Launch debugger with stdio protocol
    perl -d:TSPerlDAP script.pl

    # Launch debugger with TCP protocol
    perl -d:TSPerlDAP=daemon,host=127.0.0.1,port=5000 script.pl

=head1 DESCRIPTION

Devel::TSPerlDAP provides a machine-readable JSON protocol bridge to the Perl
debugger (perl -d). It is designed for integration with the perl-dap Debug
Adapter Protocol server.

=head1 REQUIREMENTS

=over 4

=item * Perl 5.16 or higher (5.30+ recommended)

=item * JSON::PP (core module)

=item * PadWalker 2.0+

=item * B::Deparse (core module)

=back

=head1 AUTHOR

Tree-sitter Perl Contributors

=head1 LICENSE

MIT OR Apache-2.0

=cut
</code></pre>
<h3 id="33-test-suite"><a class="header" href="#33-test-suite">3.3 Test Suite</a></h3>
<pre><code class="language-perl"># t/01-set-breakpoints.t
use strict;
use warnings;
use Test::More tests =&gt; 5;

use Devel::TSPerlDAP;

my $result = Devel::TSPerlDAP::set_breakpoints({
    source =&gt; { path =&gt; 'test.pl' },
    breakpoints =&gt; [ { line =&gt; 10 }, { line =&gt; 20 } ]
});

ok($result-&gt;{success}, "Set breakpoints succeeded");
is(scalar @{$result-&gt;{breakpoints}}, 2, "Two breakpoints set");
is($result-&gt;{breakpoints}[0]{line}, 10, "First breakpoint at line 10");
is($result-&gt;{breakpoints}[1]{line}, 20, "Second breakpoint at line 20");
ok($result-&gt;{breakpoints}[0]{verified}, "Breakpoint verified");

# t/02-stack-trace.t
use strict;
use warnings;
use Test::More tests =&gt; 3;

use Devel::TSPerlDAP;

sub outer { inner() }
sub inner {
    my $stack = Devel::TSPerlDAP::get_stack_trace();
    return $stack;
}

my $result = outer();
ok(scalar @{$result-&gt;{stackFrames}} &gt;= 2, "Stack has at least 2 frames");
like($result-&gt;{stackFrames}[0]{name}, qr/inner/, "Top frame is 'inner'");
is($result-&gt;{totalFrames}, scalar @{$result-&gt;{stackFrames}}, "Total frames matches array size");
</code></pre>
<hr />
<h2 id="4-integration-with-perl-parser"><a class="header" href="#4-integration-with-perl-parser">4. Integration with perl-parser</a></h2>
<h3 id="41-ast-integration"><a class="header" href="#41-ast-integration">4.1 AST Integration</a></h3>
<p><strong>Purpose</strong>: Breakpoint validation using existing ~100% Perl syntax coverage</p>
<p><strong>Integration Points</strong>:</p>
<ul>
<li><code>perl_parser::Parser::parse_file()</code>: Parse source for AST</li>
<li><code>perl_parser::AstNode::line_to_span()</code>: Convert line number to span</li>
<li><code>perl_parser::AstNode::is_comment_or_blank_line()</code>: Validate executable code</li>
<li><code>perl_parser::AstNode::is_inside_string_literal()</code>: Prevent breakpoints in strings</li>
<li><code>perl_parser::AstNode::is_inside_pod()</code>: Prevent breakpoints in documentation</li>
</ul>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/breakpoints/validator.rs
use perl_parser::{Parser, AstNode};

pub fn validate_breakpoint_line(parser: &amp;Parser, uri: &amp;str, line: u32) -&gt; Result&lt;bool&gt; {
    let ast = parser.parse_file(uri)?;
    let span = ast.line_to_span(line)?;

    Ok(!ast.is_comment_or_blank_line(span) &amp;&amp;
       !ast.is_inside_string_literal(span) &amp;&amp;
       !ast.is_inside_pod(span))
}
<span class="boring">}</span></code></pre></pre>
<h3 id="42-incremental-parsing-integration"><a class="header" href="#42-incremental-parsing-integration">4.2 Incremental Parsing Integration</a></h3>
<p><strong>Purpose</strong>: Live breakpoint adjustment as code changes</p>
<p><strong>Integration Points</strong>:</p>
<ul>
<li><code>perl_parser::incremental_v2::IncrementalParserV2::apply_edits()</code>: &lt;1ms updates</li>
<li><code>perl_parser::TextEdit</code>: Document change representation</li>
</ul>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/session.rs
use perl_parser::incremental_v2::IncrementalParserV2;

impl DapSession {
    pub fn on_text_change(&amp;mut self, uri: &amp;str, changes: Vec&lt;TextEdit&gt;) -&gt; Result&lt;()&gt; {
        // Apply incremental parsing (&lt;1ms target)
        self.parser.apply_edits(uri, &amp;changes)?;

        // Re-verify affected breakpoints
        let affected_lines = calculate_affected_lines(&amp;changes);
        for bp in self.get_breakpoints_in_range(uri, &amp;affected_lines) {
            let verification = self.verify_breakpoint(uri, bp.line)?;
            if verification != bp.verification {
                self.send_breakpoint_event(bp.id, verification)?;
            }
        }

        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="43-workspace-navigation-integration"><a class="header" href="#43-workspace-navigation-integration">4.3 Workspace Navigation Integration</a></h3>
<p><strong>Purpose</strong>: Stack frame source resolution via dual indexing</p>
<p><strong>Integration Points</strong>:</p>
<ul>
<li><code>perl_parser::workspace_index::WorkspaceIndex::get_definition()</code>: Symbol lookup</li>
<li><code>perl_parser::workspace_index::Location</code>: Source location representation</li>
</ul>
<p><strong>Usage Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/src/stack/resolver.rs
use perl_parser::workspace_index::WorkspaceIndex;

pub fn resolve_stack_frame(
    workspace: &amp;WorkspaceIndex,
    package: &amp;str,
    subroutine: &amp;str
) -&gt; Option&lt;Location&gt; {
    // Dual pattern matching (98% coverage)
    let qualified = format!("{}::{}", package, subroutine);

    workspace.get_definition(&amp;qualified)
        .or_else(|| workspace.get_definition(subroutine))
}
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="5-integration-with-perl-lsp"><a class="header" href="#5-integration-with-perl-lsp">5. Integration with perl-lsp</a></h2>
<h3 id="51-protocol-separation"><a class="header" href="#51-protocol-separation">5.1 Protocol Separation</a></h3>
<p><strong>Requirement</strong>: Clean routing between LSP and DAP without performance degradation</p>
<p><strong>Design</strong>: Separate binaries, optional integration</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-lsp/src/main.rs (unchanged)
// LSP server runs independently, no DAP dependency

// crates/perl-dap/src/main.rs (new)
// DAP adapter runs as separate process
<span class="boring">}</span></code></pre></pre>
<p><strong>Future Enhancement</strong> (optional): Dual-protocol server</p>
<pre><pre class="playground"><code class="language-rust">// Future: Combined LSP + DAP server
fn main() {
    let mode = std::env::var("DAP_MODE").unwrap_or_default();

    if mode == "dap" {
        run_dap_server();
    } else {
        run_lsp_server();
    }
}</code></pre></pre>
<h3 id="52-shared-infrastructure"><a class="header" href="#52-shared-infrastructure">5.2 Shared Infrastructure</a></h3>
<p><strong>Reusable Components</strong>:</p>
<ul>
<li>JSON-RPC message framing (<code>Content-Length</code> header parsing)</li>
<li>Position mapping (UTF-16 ↔ UTF-8 conversion)</li>
<li>Error handling patterns</li>
<li>Logging infrastructure</li>
</ul>
<p><strong>Integration Example</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Both crates can reuse common protocol handling
use perl_lsp::textdoc::{lsp_pos_to_byte, byte_to_lsp_pos, PosEnc};

// LSP server uses this for textDocument/* requests
let byte_offset = lsp_pos_to_byte(rope, lsp_position, PosEnc::Utf16)?;

// DAP adapter uses same infrastructure for breakpoint positions
let byte_offset = lsp_pos_to_byte(rope, dap_position, PosEnc::Utf16)?;
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="6-vs-code-extension-integration"><a class="header" href="#6-vs-code-extension-integration">6. VS Code Extension Integration</a></h2>
<h3 id="61-debugger-contribution"><a class="header" href="#61-debugger-contribution">6.1 Debugger Contribution</a></h3>
<pre><code class="language-json">// vscode-extension/package.json
{
  "contributes": {
    "debuggers": [
      {
        "type": "perl",
        "label": "Perl Debug (Bridge)",
        "program": "./out/debugAdapter.js",
        "runtime": "node",
        "configurationAttributes": {
          "launch": {
            "required": ["program"],
            "properties": {
              "program": {
                "type": "string",
                "description": "Absolute path to Perl script"
              },
              "args": {
                "type": "array",
                "description": "Command line arguments",
                "default": []
              },
              "perlPath": {
                "type": "string",
                "description": "Path to Perl executable",
                "default": "perl"
              }
            }
          }
        },
        "configurationSnippets": [
          {
            "label": "Perl: Launch",
            "body": {
              "type": "perl",
              "request": "launch",
              "name": "Launch Perl Script",
              "program": "^\"\\${workspaceFolder}/\\${1:script.pl}\"",
              "args": [],
              "perlPath": "perl"
            }
          }
        ]
      },
      {
        "type": "perl-rs",
        "label": "Perl Debug (Native)",
        "program": "./bin/perl-dap",
        "runtime": null,
        "configurationAttributes": {
          "launch": {
            "required": ["program"],
            "properties": {
              "program": {
                "type": "string",
                "description": "Absolute path to Perl script"
              },
              "args": {
                "type": "array",
                "description": "Command line arguments",
                "default": []
              },
              "perlPath": {
                "type": "string",
                "description": "Path to Perl executable",
                "default": "perl"
              },
              "includePaths": {
                "type": "array",
                "description": "Additional @INC paths",
                "default": []
              },
              "env": {
                "type": "object",
                "description": "Environment variables"
              },
              "cwd": {
                "type": "string",
                "description": "Working directory"
              },
              "stopOnEntry": {
                "type": "boolean",
                "description": "Stop on entry",
                "default": false
              }
            }
          }
        }
      }
    ]
  }
}
</code></pre>
<h3 id="62-binary-management"><a class="header" href="#62-binary-management">6.2 Binary Management</a></h3>
<pre><code class="language-typescript">// vscode-extension/src/dapBinaryManager.ts
import * as path from 'path';
import * as fs from 'fs';
import * as https from 'https';

export class DapBinaryManager {
    private extensionPath: string;

    constructor(extensionPath: string) {
        this.extensionPath = extensionPath;
    }

    async ensureBinary(): Promise&lt;string&gt; {
        const platform = process.platform;
        const arch = process.arch;

        // Determine binary name
        const binaryName = this.getBinaryName(platform, arch);
        const binaryPath = path.join(this.extensionPath, 'bin', binaryName);

        // Check if binary exists
        if (fs.existsSync(binaryPath)) {
            return binaryPath;
        }

        // Download from GitHub Releases
        const version = '0.1.0';
        const downloadUrl = `https://github.com/EffortlessMetrics/tree-sitter-perl/releases/download/v${version}/${binaryName}`;

        console.log(`Downloading ${binaryName} from ${downloadUrl}...`);
        await this.downloadFile(downloadUrl, binaryPath);

        // Make executable (Unix)
        if (platform !== 'win32') {
            fs.chmodSync(binaryPath, 0o755);
        }

        return binaryPath;
    }

    private getBinaryName(platform: string, arch: string): string {
        const platformMap: Record&lt;string, string&gt; = {
            'linux': 'linux',
            'darwin': 'darwin',
            'win32': 'win32',
        };

        const archMap: Record&lt;string, string&gt; = {
            'x64': 'x64',
            'arm64': 'arm64',
        };

        const ext = platform === 'win32' ? '.exe' : '';
        return `perl-dap-${platformMap[platform]}-${archMap[arch]}${ext}`;
    }

    private async downloadFile(url: string, dest: string): Promise&lt;void&gt; {
        return new Promise((resolve, reject) =&gt; {
            const file = fs.createWriteStream(dest);

            https.get(url, (response) =&gt; {
                if (response.statusCode !== 200) {
                    reject(new Error(`Download failed: ${response.statusCode}`));
                    return;
                }

                response.pipe(file);

                file.on('finish', () =&gt; {
                    file.close();
                    resolve();
                });
            }).on('error', (err) =&gt; {
                fs.unlinkSync(dest);
                reject(err);
            });
        });
    }
}
</code></pre>
<hr />
<h2 id="7-testing-infrastructure"><a class="header" href="#7-testing-infrastructure">7. Testing Infrastructure</a></h2>
<h3 id="71-test-organization"><a class="header" href="#71-test-organization">7.1 Test Organization</a></h3>
<p><strong>Location</strong>: <code>crates/perl-dap/tests/</code></p>
<p><strong>Test Categories</strong>:</p>
<ol>
<li><strong>Protocol Compliance</strong>: Golden transcript validation (AC13)</li>
<li><strong>Breakpoint Validation</strong>: AST-based edge cases (AC7, AC13)</li>
<li><strong>Variable Rendering</strong>: Truncation, expansion, Unicode (AC8, AC13)</li>
<li><strong>Performance</strong>: Benchmarks with regression detection (AC14)</li>
<li><strong>Security</strong>: Path traversal, safe eval, timeout (AC16)</li>
<li><strong>Cross-Platform</strong>: Platform-specific behavior (AC12)</li>
</ol>
<h3 id="72-golden-transcript-tests"><a class="header" href="#72-golden-transcript-tests">7.2 Golden Transcript Tests</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/tests/integration_tests.rs
use perl_dap::{DapServer, DapRequest, DapResponse};
use serde_json::json;

#[tokio::test] // AC13
async fn test_hello_world_golden_transcript() {
    let transcript = load_golden_transcript("hello.json");
    let server = DapServer::new(Default::default()).unwrap();

    for message in transcript.messages {
        if message.type_ == "request" {
            let response = server.handle_request(message.request).await.unwrap();
            assert_eq!(
                response,
                message.expected_response,
                "Transcript mismatch at seq {}",
                message.seq
            );
        }
    }
}

struct GoldenTranscript {
    messages: Vec&lt;TranscriptMessage&gt;,
}

struct TranscriptMessage {
    type_: String,
    seq: i64,
    request: DapRequest,
    expected_response: DapResponse,
}

fn load_golden_transcript(filename: &amp;str) -&gt; GoldenTranscript {
    let path = format!("tests/fixtures/golden/{}", filename);
    let content = std::fs::read_to_string(path).unwrap();
    serde_json::from_str(&amp;content).unwrap()
}
<span class="boring">}</span></code></pre></pre>
<h3 id="73-benchmarking-infrastructure"><a class="header" href="#73-benchmarking-infrastructure">7.3 Benchmarking Infrastructure</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// crates/perl-dap/benches/dap_benchmarks.rs
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use perl_dap::{DapServer, BreakpointManager};

fn benchmark_breakpoint_verification(c: &amp;mut Criterion) {
    let fixtures = vec![
        ("small.pl", 100),
        ("medium.pl", 1000),
        ("large.pl", 10000),
    ];

    for (fixture, _lines) in fixtures {
        c.bench_function(&amp;format!("verify_breakpoint_{}", fixture), |b| {
            let manager = BreakpointManager::new(/* parser */);
            b.iter(|| {
                manager.verify_breakpoint(black_box(fixture), black_box(42))
            });
        });
    }
}

fn benchmark_variable_rendering(c: &amp;mut Criterion) {
    c.bench_function("render_large_scalar", |b| {
        let large_value = "x".repeat(10000);
        b.iter(|| {
            render_variable_value(black_box(&amp;large_value), /* rope */)
        });
    });
}

criterion_group!(benches, benchmark_breakpoint_verification, benchmark_variable_rendering);
criterion_main!(benches);
<span class="boring">}</span></code></pre></pre>
<hr />
<h2 id="8-deployment-strategy"><a class="header" href="#8-deployment-strategy">8. Deployment Strategy</a></h2>
<h3 id="81-binary-distribution"><a class="header" href="#81-binary-distribution">8.1 Binary Distribution</a></h3>
<p><strong>Platforms</strong>: 6 targets (Linux/macOS/Windows x86_64/aarch64)</p>
<p><strong>GitHub Actions</strong>:</p>
<pre><code class="language-yaml"># .github/workflows/release-dap-binaries.yml
name: Release DAP Binaries

on:
  release:
    types: [created]

jobs:
  build:
    strategy:
      matrix:
        include:
          - os: ubuntu-latest
            target: x86_64-unknown-linux-gnu
          - os: ubuntu-latest
            target: aarch64-unknown-linux-gnu
          - os: macos-latest
            target: x86_64-apple-darwin
          - os: macos-latest
            target: aarch64-apple-darwin
          - os: windows-latest
            target: x86_64-pc-windows-msvc
          - os: windows-latest
            target: aarch64-pc-windows-msvc

    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v3

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          target: ${{ matrix.target }}

      - name: Build perl-dap binary
        run: cargo build -p perl-dap --release --target ${{ matrix.target }}

      - name: Upload artifact
        uses: actions/upload-release-asset@v1
        with:
          upload_url: ${{ github.event.release.upload_url }}
          asset_path: target/${{ matrix.target }}/release/perl-dap${{ matrix.os == 'windows-latest' &amp;&amp; '.exe' || '' }}
          asset_name: perl-dap-${{ matrix.target }}${{ matrix.os == 'windows-latest' &amp;&amp; '.exe' || '' }}
</code></pre>
<h3 id="82-cpan-publication"><a class="header" href="#82-cpan-publication">8.2 CPAN Publication</a></h3>
<p><strong>Devel::TSPerlDAP</strong>:</p>
<pre><code class="language-bash"># Publish to CPAN
cd Devel-TSPerlDAP
perl Makefile.PL
make test
make dist
cpan-upload Devel-TSPerlDAP-0.1.0.tar.gz
</code></pre>
<p><strong>Bundled Fallback</strong>:</p>
<ul>
<li>Extension bundles <code>Devel/TSPerlDAP.pm</code> in <code>resources/perl-shim/</code></li>
<li>Auto-install via <code>cpanm</code> on first use</li>
<li>Fallback to bundled version if CPAN install fails</li>
</ul>
<hr />
<h2 id="9-success-metrics"><a class="header" href="#9-success-metrics">9. Success Metrics</a></h2>
<h3 id="91-build-metrics"><a class="header" href="#91-build-metrics">9.1 Build Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Target</th><th>Validation</th></tr></thead><tbody>
<tr><td>Clean compilation</td><td>Zero warnings</td><td><code>cargo build -p perl-dap --release</code></td></tr>
<tr><td>Cross-platform builds</td><td>6 platforms</td><td>GitHub Actions CI</td></tr>
<tr><td>Binary size</td><td>&lt;5MB per platform</td><td>Binary size validation</td></tr>
</tbody></table>
</div>
<h3 id="92-test-metrics"><a class="header" href="#92-test-metrics">9.2 Test Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Target</th><th>Validation</th></tr></thead><tbody>
<tr><td>Test coverage (adapter)</td><td>&gt;95%</td><td><code>cargo tarpaulin -p perl-dap</code></td></tr>
<tr><td>Test coverage (shim)</td><td>&gt;80%</td><td><code>cover -test</code></td></tr>
<tr><td>Integration tests</td><td>&gt;95% pass rate</td><td><code>cargo test -p perl-dap --test integration_tests</code></td></tr>
</tbody></table>
</div>
<h3 id="93-performance-metrics"><a class="header" href="#93-performance-metrics">9.3 Performance Metrics</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Target</th><th>Validation</th></tr></thead><tbody>
<tr><td>Breakpoint verification</td><td>&lt;50ms</td><td><code>cargo bench -p perl-dap -- verify_breakpoint</code></td></tr>
<tr><td>Variable rendering</td><td>&lt;200ms initial</td><td><code>cargo bench -p perl-dap -- render_variable</code></td></tr>
<tr><td>Memory overhead</td><td>&lt;1MB adapter</td><td>Memory profiling tests</td></tr>
</tbody></table>
</div>
<hr />
<h2 id="10-references"><a class="header" href="#10-references">10. References</a></h2>
<ul>
<li><a href="DAP_IMPLEMENTATION_SPECIFICATION.html">DAP Implementation Specification</a>: Primary technical specification</li>
<li><a href="DAP_PROTOCOL_SCHEMA.html">DAP Protocol Schema</a>: JSON-RPC message schemas</li>
<li><a href="DAP_SECURITY_SPECIFICATION.html">DAP Security Specification</a>: Security requirements</li>
<li><a href="LSP_IMPLEMENTATION_GUIDE.html">LSP Implementation Guide</a>: LSP server architecture patterns</li>
<li><a href="CRATE_ARCHITECTURE_GUIDE.html">Crate Architecture Guide</a>: Existing workspace structure</li>
</ul>
<hr />
<p><strong>End of DAP Crate Architecture Specification</strong></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/lsp-implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/modern-architecture.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/lsp-implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/modern-architecture.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
