<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Crate Structure - Perl LSP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the perl-lsp project - a production-ready Perl Language Server Protocol implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Perl LSP Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/EffortlessMetrics/tree-sitter-perl-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="crate-architecture-guide-v088-ga"><a class="header" href="#crate-architecture-guide-v088-ga">Crate Architecture Guide (v0.8.8 GA)</a></h1>
<h2 id="published-crates-workspace-members"><a class="header" href="#published-crates-workspace-members">Published Crates (Workspace Members)</a></h2>
<h3 id="cratesperl-parser---main-parser-library--main-crate"><a class="header" href="#cratesperl-parser---main-parser-library--main-crate"><code>/crates/perl-parser/</code> - Main Parser Library ⭐ <strong>MAIN CRATE</strong></a></h3>
<ul>
<li>
<p><strong>Purpose</strong>: Core recursive descent parser with production-grade features</p>
</li>
<li>
<p><strong>Key Features</strong>:</p>
<ul>
<li>Native recursive descent parser with ~100% Perl 5 syntax coverage (including comprehensive substitution operator parsing)</li>
<li>4-19x faster than legacy implementations (1-150 µs parsing)</li>
<li>True incremental parsing with &lt;1ms LSP updates</li>
<li>Production-ready Rope integration for UTF-16/UTF-8 position conversion</li>
<li>Enhanced workspace navigation with dual indexing strategy for 98% reference coverage</li>
<li><strong>Revolutionary Dual Indexing</strong>: Functions indexed under both qualified (<code>Package::function</code>) and bare (<code>function</code>) names</li>
<li><strong>Thread-safe semantic tokens</strong> - 2.826µs average performance (35x better than 100µs target)</li>
<li><strong>Zero-race-condition LSP features</strong> - immutable provider pattern with local state management</li>
<li><strong>Cross-file workspace refactoring utilities</strong> - comprehensive WorkspaceRefactor provider for symbol renaming, module extraction, workspace-wide changes</li>
<li><strong>Import optimization system</strong> - comprehensive analysis and optimization of Perl import statements with unused/duplicate detection, missing import analysis, and alphabetical sorting</li>
<li><strong>Production-ready refactoring operations</strong> - move subroutines between modules, inline variables, extract code sections</li>
<li><strong>Enterprise-grade safety and validation</strong> - comprehensive error handling, input validation, and rollback support</li>
<li><strong>Precise name span tracking</strong> - Enhanced AST nodes with O(1) position lookups for Subroutine and Package declarations</li>
<li><strong>Production-stable AST generation</strong> - Comprehensive S-expression generation with 50+ operators and enhanced navigation</li>
</ul>
</li>
<li>
<p><strong>Key Files</strong>:</p>
<ul>
<li><code>src/parser.rs</code>: Recursive descent parser with precise name span calculation</li>
<li><code>src/ast.rs</code>: AST definitions with enhanced navigation and name_span fields</li>
<li><code>src/textdoc.rs</code>: Core document management with <code>ropey::Rope</code></li>
<li><code>src/position_mapper.rs</code>: UTF-16/UTF-8 position conversion</li>
<li><code>src/incremental_integration.rs</code>: LSP integration bridge</li>
<li><code>src/incremental_handler_v2.rs</code>: Document change processing</li>
<li><code>src/declaration.rs</code>: Declaration provider with O(1) position lookups</li>
<li><code>src/module_resolver.rs</code>: <strong>NEW v0.8.8</strong> - Reusable module resolution component for LSP features</li>
<li><code>src/workspace_index.rs</code>: <strong>ENHANCED v0.8.8</strong> - Dual indexing strategy for 98% cross-file reference coverage</li>
<li><code>src/completion.rs</code>: Enhanced completion provider with pluggable module resolver integration</li>
<li><code>src/import_optimizer.rs</code>: Import analysis and optimization engine</li>
<li><code>src/code_actions.rs</code>: LSP code actions with import optimization integration</li>
</ul>
</li>
</ul>
<h3 id="cratesperl-lsp---standalone-lsp-server--lsp-binary-v088"><a class="header" href="#cratesperl-lsp---standalone-lsp-server--lsp-binary-v088"><code>/crates/perl-lsp/</code> - Standalone LSP Server ⭐ <strong>LSP BINARY</strong> (v0.8.8)</a></h3>
<ul>
<li><strong>Purpose</strong>: Clean LSP server implementation separated from parser logic</li>
<li><strong>Key Features</strong>:
<ul>
<li>Standalone Language Server binary with production-grade CLI</li>
<li>Clean separation from parser logic for improved maintainability</li>
<li>Works with VSCode, Neovim, Emacs, and all LSP-compatible editors</li>
</ul>
</li>
<li><strong>Key Files</strong>:
<ul>
<li><code>src/main.rs</code>: Clean LSP server implementation</li>
<li><code>bin/perl-lsp.rs</code>: LSP server binary entry point</li>
</ul>
</li>
</ul>
<h3 id="cratesperl-dap---debug-adapter-protocol-server--dap-binary-issue-207---phase-1"><a class="header" href="#cratesperl-dap---debug-adapter-protocol-server--dap-binary-issue-207---phase-1"><code>/crates/perl-dap/</code> - Debug Adapter Protocol Server ⭐ <strong>DAP BINARY</strong> (Issue #207 - Phase 1)</a></h3>
<ul>
<li><strong>Purpose</strong>: Debug Adapter Protocol (DAP) implementation for Perl debugging in VS Code and DAP-compatible editors</li>
<li><strong>Key Features</strong>:
<ul>
<li><strong>Phase 1 Bridge Architecture</strong>: Proxies DAP messages to Perl::LanguageServer for immediate debugging capability</li>
<li><strong>Cross-Platform Support</strong>: Windows, macOS, Linux, and WSL with automatic path normalization</li>
<li><strong>Configuration Management</strong>: Launch (start new process) and attach (connect to running process) modes</li>
<li><strong>Enterprise Security</strong>: Path validation, process isolation, input sanitization, safe defaults</li>
<li><strong>Performance Optimized</strong>: &lt;50ms breakpoint operations, &lt;100ms step/continue, &lt;200ms variable expansion</li>
<li><strong>Comprehensive Testing</strong>: 71/71 tests passing with mutation hardening and edge case coverage</li>
</ul>
</li>
<li><strong>Key Files</strong>:
<ul>
<li><code>src/lib.rs</code>: Public API exports and crate documentation</li>
<li><code>src/bridge_adapter.rs</code>: Bridge to Perl::LanguageServer DAP implementation</li>
<li><code>src/configuration.rs</code>: LaunchConfiguration and AttachConfiguration types with validation</li>
<li><code>src/platform.rs</code>: Cross-platform perl path resolution, path normalization, environment setup</li>
<li><code>tests/bridge_tests.rs</code>: Integration tests for bridge adapter functionality</li>
</ul>
</li>
<li><strong>Architecture</strong>:
<pre><code>VS Code ↔ perl-dap (Rust bridge) ↔ Perl::LanguageServer (Perl) ↔ perl -d
</code></pre>
</li>
<li><strong>Future Roadmap</strong>:
<ul>
<li><strong>Phase 2</strong> (Planned): Native Rust DAP implementation with AST-based breakpoint validation</li>
<li><strong>Phase 3</strong> (Planned): Production hardening with advanced features (conditional breakpoints, logpoints)</li>
</ul>
</li>
</ul>
<h3 id="cratesperl-lexer---context-aware-tokenizer-enhanced-v088"><a class="header" href="#cratesperl-lexer---context-aware-tokenizer-enhanced-v088"><code>/crates/perl-lexer/</code> - Context-Aware Tokenizer (Enhanced v0.8.8)</a></h3>
<ul>
<li><strong>Purpose</strong>: Context-aware tokenizer with mode-based lexing and package-qualified identifier support</li>
<li><strong>Key Features</strong>:
<ul>
<li>Context-aware tokenizer with mode-based lexing</li>
<li>Handles slash disambiguation and Unicode identifiers</li>
<li><strong>Enhanced Package-Qualified Parsing</strong>: Robust tokenization of <code>Package::identifier</code> patterns</li>
<li><strong>Unicode Handling</strong>: Robust support for Unicode characters in all contexts</li>
<li><strong>Heredoc Safety</strong>: Proper bounds checking for Unicode + heredoc syntax</li>
</ul>
</li>
<li><strong>Key Files</strong>:
<ul>
<li><code>src/lib.rs</code>: Lexer API with Unicode support</li>
<li><code>src/token.rs</code>: Token definitions</li>
<li><code>src/mode.rs</code>: Lexer modes (ExpectTerm, ExpectOperator)</li>
<li><code>src/unicode.rs</code>: Unicode identifier support</li>
</ul>
</li>
</ul>
<h3 id="cratesperl-corpus---test-corpus"><a class="header" href="#cratesperl-corpus---test-corpus"><code>/crates/perl-corpus/</code> - Test Corpus</a></h3>
<ul>
<li><strong>Purpose</strong>: Comprehensive test corpus with property-based testing infrastructure</li>
<li><strong>Key Files</strong>:
<ul>
<li><code>src/lib.rs</code>: Corpus API</li>
<li><code>tests/</code>: Perl test files</li>
</ul>
</li>
</ul>
<h3 id="cratesperl-parser-pest---legacy-pest-parser--legacy"><a class="header" href="#cratesperl-parser-pest---legacy-pest-parser--legacy"><code>/crates/perl-parser-pest/</code> - Legacy Pest Parser ⚠️ <strong>LEGACY</strong></a></h3>
<ul>
<li><strong>Purpose</strong>: Pest-based parser (v2 implementation), marked as legacy</li>
<li><strong>Status</strong>: Published but marked as legacy, use <code>perl-parser</code> instead</li>
</ul>
<h2 id="benchmark-framework-v088--enhanced"><a class="header" href="#benchmark-framework-v088--enhanced">Benchmark Framework (v0.8.8) ⭐ <strong>ENHANCED</strong></a></h2>
<h3 id="cratestree-sitter-perl-rssrcbinbenchmark_parsersrs"><a class="header" href="#cratestree-sitter-perl-rssrcbinbenchmark_parsersrs"><code>/crates/tree-sitter-perl-rs/src/bin/benchmark_parsers.rs</code></a></h3>
<ul>
<li><strong>Purpose</strong>: Comprehensive Rust benchmark runner</li>
<li><strong>Features</strong>:
<ul>
<li>Statistical analysis with confidence intervals</li>
<li>JSON output compatible with comparison tools</li>
<li>Memory usage tracking and performance categorization</li>
<li>Configurable iterations and warmup cycles</li>
</ul>
</li>
</ul>
<h3 id="tree-sitter-perltestbenchmarkjs"><a class="header" href="#tree-sitter-perltestbenchmarkjs"><code>/tree-sitter-perl/test/benchmark.js</code></a></h3>
<ul>
<li><strong>Purpose</strong>: C implementation benchmark harness</li>
<li><strong>Features</strong>:
<ul>
<li>Node.js-based benchmarking for C parser</li>
<li>Standardized JSON output format compatible with comparison framework</li>
<li>Environment variable configuration support</li>
</ul>
</li>
</ul>
<h3 id="scriptsgenerate_comparisonpy"><a class="header" href="#scriptsgenerate_comparisonpy"><code>/scripts/generate_comparison.py</code></a></h3>
<ul>
<li><strong>Purpose</strong>: Statistical comparison generator</li>
<li><strong>Features</strong>:
<ul>
<li>Cross-language performance analysis (C vs Rust)</li>
<li>Configurable regression thresholds (5% parse time, 20% memory defaults)</li>
<li>Performance gates with statistical significance testing</li>
<li>Markdown and JSON report generation with confidence intervals</li>
</ul>
</li>
</ul>
<h3 id="scriptssetup_benchmarksh"><a class="header" href="#scriptssetup_benchmarksh"><code>/scripts/setup_benchmark.sh</code></a></h3>
<ul>
<li><strong>Purpose</strong>: Automated benchmark environment setup</li>
<li><strong>Features</strong>:
<ul>
<li>Dependency installation for Python analysis framework</li>
<li>Environment validation and configuration</li>
<li>Complete setup automation for cross-language benchmarking</li>
</ul>
</li>
</ul>
<h3 id="scriptstest_comparisonpy"><a class="header" href="#scriptstest_comparisonpy"><code>/scripts/test_comparison.py</code></a></h3>
<ul>
<li><strong>Purpose</strong>: Comprehensive benchmark framework test suite</li>
<li><strong>Features</strong>:
<ul>
<li>12 test cases covering statistical analysis, configuration, and error handling</li>
<li>Validates regression detection and performance gate functionality</li>
<li>Unit tests for comparison metrics and threshold validation</li>
</ul>
</li>
</ul>
<h2 id="excluded-crates-system-dependencies"><a class="header" href="#excluded-crates-system-dependencies">Excluded Crates (System Dependencies)</a></h2>
<h3 id="cratesperl-parser-pest---legacy-pest-parser"><a class="header" href="#cratesperl-parser-pest---legacy-pest-parser"><code>/crates/perl-parser-pest/</code> - Legacy Pest Parser</a></h3>
<ul>
<li><strong>Status</strong>: Published as <code>perl-parser-pest</code> on crates.io (marked legacy)</li>
<li><strong>Exclusion Reason</strong>: Requires bindgen for C interop</li>
</ul>
<h3 id="tree-sitter-perl---original-c-implementation"><a class="header" href="#tree-sitter-perl---original-c-implementation"><code>/tree-sitter-perl/</code> - Original C Implementation</a></h3>
<ul>
<li><strong>Exclusion Reason</strong>: libclang dependency</li>
</ul>
<h3 id="tree-sitter-perl-c---c-parser-bindings"><a class="header" href="#tree-sitter-perl-c---c-parser-bindings"><code>/tree-sitter-perl-c/</code> - C Parser Bindings</a></h3>
<ul>
<li><strong>Exclusion Reason</strong>: libclang-dev dependency</li>
</ul>
<h3 id="cratestree-sitter-perl-rs---internal-test-harness--unified-scanner"><a class="header" href="#cratestree-sitter-perl-rs---internal-test-harness--unified-scanner"><code>/crates/tree-sitter-perl-rs/</code> - Internal Test Harness &amp; Unified Scanner</a></h3>
<ul>
<li><strong>Exclusion Reason</strong>: bindgen dependency</li>
<li><strong>Scanner Architecture</strong>: Contains unified scanner implementation with C wrapper delegation
<ul>
<li><strong><code>src/scanner/rust_scanner.rs</code></strong>: Core Rust scanner implementation</li>
<li><strong><code>src/scanner/c_scanner.rs</code></strong>: C API compatibility wrapper that delegates to RustScanner</li>
<li><strong><code>src/scanner/mod.rs</code></strong>: Unified scanner interface and feature flags</li>
</ul>
</li>
</ul>
<h3 id="xtask---development-automation-diataxis-explanation---design-decisions"><a class="header" href="#xtask---development-automation-diataxis-explanation---design-decisions"><code>/xtask/</code> - Development Automation (<em>Diataxis: Explanation</em> - Design decisions)</a></h3>
<ul>
<li><strong>Exclusion Reason</strong>: Circular dependency with excluded crates</li>
<li><strong>Purpose</strong>: Advanced testing and development tools requiring system dependencies</li>
<li><strong>Architecture</strong>: Excluded from workspace to maintain clean builds while preserving functionality</li>
</ul>
<h2 id="xtask-architecture-diataxis-explanation---advanced-testing-design"><a class="header" href="#xtask-architecture-diataxis-explanation---advanced-testing-design">xtask Architecture (<em>Diataxis: Explanation</em> - Advanced testing design)</a></h2>
<h3 id="dual-scanner-corpus-comparison-v088"><a class="header" href="#dual-scanner-corpus-comparison-v088">Dual-Scanner Corpus Comparison (v0.8.8+)</a></h3>
<p>The xtask system implements a sophisticated dual-scanner corpus comparison architecture:</p>
<h4 id="design-rationale"><a class="header" href="#design-rationale"><strong>Design Rationale</strong></a></h4>
<ul>
<li><strong>Workspace Exclusion</strong>: xtask is excluded from the main workspace to prevent libclang dependency pollution</li>
<li><strong>Clean Builds</strong>: Main workspace builds remain system-dependency-free for CI/CD reliability</li>
<li><strong>Advanced Functionality</strong>: xtask provides C vs Rust scanner comparison requiring system dependencies</li>
<li><strong>Development Isolation</strong>: Advanced testing tools don’t interfere with production builds</li>
</ul>
<h4 id="core-components"><a class="header" href="#core-components"><strong>Core Components</strong></a></h4>
<ul>
<li><strong><code>/xtask/src/tasks/corpus.rs</code></strong>: Dual-scanner comparison engine with structural analysis</li>
<li><strong><code>/xtask/src/types.rs</code></strong>: Scanner type definitions (C, Rust, V3, Both)</li>
<li><strong><code>/xtask/Cargo.toml</code></strong>: Dependencies on both tree-sitter-perl (C) and perl-parser (Rust)</li>
</ul>
<h4 id="scanner-comparison-architecture"><a class="header" href="#scanner-comparison-architecture"><strong>Scanner Comparison Architecture</strong></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Dual-scanner test outcome tracking
struct TestOutcome {
    passed: bool,              // Test passed in both scanners
    scanner_mismatch: bool,    // Scanners produced different results
}

// Comprehensive result tracking
struct CorpusTestResults {
    total: usize,              // Total tests run
    passed: usize,             // Tests passing both scanners
    failed: usize,             // Tests failing in either scanner  
    mismatched: usize,         // Scanner output differences
    mismatches: Vec&lt;String&gt;,   // Detailed mismatch locations
}
<span class="boring">}</span></code></pre></pre>
<h4 id="structural-analysis-features-diataxis-reference---technical-capabilities"><a class="header" href="#structural-analysis-features-diataxis-reference---technical-capabilities"><strong>Structural Analysis Features</strong> (<em>Diataxis: Reference</em> - Technical capabilities)</a></h4>
<ul>
<li><strong>Node Count Comparison</strong>: Tracks structural differences between scanner outputs</li>
<li><strong>Missing Node Detection</strong>: Identifies nodes present in C but missing in Rust output</li>
<li><strong>Extra Node Detection</strong>: Identifies nodes present in Rust but missing in C output</li>
<li><strong>S-expression Normalization</strong>: Whitespace-independent comparison for accurate results</li>
<li><strong>Diagnostic Analysis</strong>: Detailed structural breakdown for debugging parser differences</li>
</ul>
<h4 id="usage-pattern-diataxis-how-to-guide---implementation-approach"><a class="header" href="#usage-pattern-diataxis-how-to-guide---implementation-approach"><strong>Usage Pattern</strong> (<em>Diataxis: How-to Guide</em> - Implementation approach)</a></h4>
<pre><code class="language-bash"># Run corpus comparison modes (requires legacy feature)
cargo run -p xtask --features legacy -- corpus                          # Default scanner: v3
cargo run -p xtask --features legacy -- corpus --scanner both           # C vs v3 comparison mode
cargo run -p xtask --features legacy -- corpus --scanner v2-parity --diagnose
</code></pre>
<h2 id="key-components"><a class="header" href="#key-components">Key Components</a></h2>
<h3 id="moduleresolver-component-new-v088---diataxis-reference"><a class="header" href="#moduleresolver-component-new-v088---diataxis-reference">ModuleResolver Component (NEW v0.8.8) - (<em>Diataxis: Reference</em>)</a></h3>
<p>The ModuleResolver provides a reusable, generic module resolution system for LSP features requiring Perl module path resolution.</p>
<h4 id="architecture-overview"><a class="header" href="#architecture-overview"><strong>Architecture Overview</strong></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Resolve a module name to a file path URI.
/// Generic over document type D for flexible integration
pub fn resolve_module_to_path&lt;D&gt;(
    documents: &amp;Arc&lt;Mutex&lt;HashMap&lt;String, D&gt;&gt;&gt;,
    workspace_folders: &amp;Arc&lt;Mutex&lt;Vec&lt;String&gt;&gt;&gt;,
    module_name: &amp;str,
) -&gt; Option&lt;String&gt;
<span class="boring">}</span></code></pre></pre>
<h4 id="key-design-principles"><a class="header" href="#key-design-principles"><strong>Key Design Principles</strong></a></h4>
<ul>
<li><strong>Generic Document Support</strong>: Works with any document representation via generic type <code>D</code></li>
<li><strong>Performance Optimized</strong>: Fast path checks open documents first, then bounded filesystem search</li>
<li><strong>Security Conscious</strong>: Time-limited search (50ms timeout) prevents blocking on network filesystems</li>
<li><strong>Cooperative</strong>: Yields control during long operations to maintain LSP responsiveness</li>
<li><strong>Standard Perl Paths</strong>: Searches <code>lib</code>, <code>.</code>, <code>local/lib/perl5</code> directories in workspace folders</li>
</ul>
<h4 id="integration-pattern"><a class="header" href="#integration-pattern"><strong>Integration Pattern</strong></a></h4>
<p>The ModuleResolver follows a functional approach allowing easy integration into LSP providers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Create resolver closure for completion provider
let resolver = {
    let docs = self.documents.clone();
    let folders = self.workspace_folders.clone();
    Arc::new(move |module_name: &amp;str| {
        module_resolver::resolve_module_to_path(&amp;docs, &amp;folders, module_name)
    })
};

// Pass resolver to completion provider
let provider = CompletionProvider::new_with_index_and_source(
    ast,
    &amp;doc.text,
    workspace_index,
    Some(resolver)
);
<span class="boring">}</span></code></pre></pre>
<h4 id="resolution-algorithm"><a class="header" href="#resolution-algorithm"><strong>Resolution Algorithm</strong></a></h4>
<ol>
<li><strong>Fast Path</strong>: Check already-open documents for matching module paths</li>
<li><strong>Filesystem Search</strong>: Time-limited search through standard Perl directories</li>
<li><strong>Path Standardization</strong>: Convert <code>Module::Name</code> to <code>Module/Name.pm</code> format</li>
<li><strong>URI Generation</strong>: Return proper <code>file://</code> URIs for LSP compatibility</li>
</ol>
<h4 id="performance-characteristics"><a class="header" href="#performance-characteristics"><strong>Performance Characteristics</strong></a></h4>
<ul>
<li><strong>Fast Path</strong>: O(n) where n = number of open documents (typically &lt;100)</li>
<li><strong>Filesystem Search</strong>: O(m) where m = files in search directories (bounded by timeout)</li>
<li><strong>Timeout Protection</strong>: 50ms maximum to prevent LSP blocking</li>
<li><strong>Memory Efficient</strong>: No persistent state, operates on provided references</li>
</ul>
<h4 id="testing-coverage"><a class="header" href="#testing-coverage"><strong>Testing Coverage</strong></a></h4>
<ul>
<li><strong>Existing Module Resolution</strong>: Tests successful resolution of modules in workspace</li>
<li><strong>Missing Module Handling</strong>: Tests graceful failure for non-existent modules</li>
<li><strong>Path Conversion</strong>: Tests <code>Module::Name</code> to <code>Module/Name.pm</code> transformation</li>
<li><strong>Timeout Behavior</strong>: Ensures bounded execution time</li>
</ul>
<h4 id="benefits-for-lsp-features"><a class="header" href="#benefits-for-lsp-features"><strong>Benefits for LSP Features</strong></a></h4>
<ul>
<li><strong>Reusable</strong>: Single implementation shared across completion, hover, go-to-definition</li>
<li><strong>Extensible</strong>: Generic design allows future LSP features to easily add module resolution</li>
<li><strong>Reliable</strong>: Comprehensive error handling and timeout protection</li>
<li><strong>Standard Compliant</strong>: Follows Perl module path conventions and LSP URI requirements</li>
</ul>
<h2 id="unified-scanner-architecture-diataxis-explanation---scanner-design-and-implementation"><a class="header" href="#unified-scanner-architecture-diataxis-explanation---scanner-design-and-implementation">Unified Scanner Architecture (<em>Diataxis: Explanation</em> - Scanner design and implementation)</a></h2>
<h3 id="design-overview"><a class="header" href="#design-overview">Design Overview</a></h3>
<p>The scanner implementation follows a unified architecture pattern that consolidates multiple scanner interfaces into a single Rust implementation while maintaining full backward compatibility.</p>
<h4 id="core-components-diataxis-reference---technical-architecture"><a class="header" href="#core-components-diataxis-reference---technical-architecture">Core Components (<em>Diataxis: Reference</em> - Technical architecture)</a></h4>
<p><strong><code>/crates/tree-sitter-perl-rs/src/scanner/mod.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Feature-driven scanner selection
#[cfg(any(feature = "rust-scanner", feature = "c-scanner"))]
mod rust_scanner;

#[cfg(feature = "c-scanner")]
mod c_scanner;

// Both features ultimately use the same Rust implementation
#[cfg(any(feature = "rust-scanner", feature = "c-scanner"))]
pub use rust_scanner::*;

#[cfg(feature = "c-scanner")]
pub use c_scanner::*;
<span class="boring">}</span></code></pre></pre>
<p><strong><code>/crates/tree-sitter-perl-rs/src/scanner/rust_scanner.rs</code></strong>:</p>
<ul>
<li>Core scanning implementation with full Perl lexical analysis</li>
<li>Context-aware tokenization with mode tracking</li>
<li>Unicode identifier support and proper delimiter handling</li>
<li>Comprehensive token type system with 100+ Perl constructs</li>
</ul>
<p><strong><code>/crates/tree-sitter-perl-rs/src/scanner/c_scanner.rs</code></strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Compatibility wrapper that delegates to RustScanner
pub struct CScanner {
    inner: RustScanner,
}

impl PerlScanner for CScanner {
    fn scan(&amp;mut self, input: &amp;[u8]) -&gt; ParseResult&lt;Option&lt;u16&gt;&gt; {
        self.inner.scan(input)  // Pure delegation
    }
    // All methods delegate to inner RustScanner
}
<span class="boring">}</span></code></pre></pre>
<h3 id="architecture-benefits-diataxis-explanation---design-decisions"><a class="header" href="#architecture-benefits-diataxis-explanation---design-decisions">Architecture Benefits (<em>Diataxis: Explanation</em> - Design decisions)</a></h3>
<h4 id="simplified-maintenance"><a class="header" href="#simplified-maintenance"><strong>Simplified Maintenance</strong></a></h4>
<ul>
<li><strong>Single Source of Truth</strong>: One scanner implementation for all functionality</li>
<li><strong>Reduced Code Duplication</strong>: No separate C and Rust scanner codebases to maintain</li>
<li><strong>Unified Testing</strong>: All scanner behavior tested through single implementation</li>
<li><strong>Consistent Performance</strong>: Same performance characteristics across all interfaces</li>
</ul>
<h4 id="backward-compatibility"><a class="header" href="#backward-compatibility"><strong>Backward Compatibility</strong></a></h4>
<ul>
<li><strong>API Preservation</strong>: Existing <code>CScanner</code> API continues to work unchanged</li>
<li><strong>Benchmark Compatibility</strong>: Legacy benchmark code requires no modifications</li>
<li><strong>Feature Flag Support</strong>: Both <code>c-scanner</code> and <code>rust-scanner</code> features supported</li>
<li><strong>Migration Path</strong>: Gradual migration from C API to Rust API without disruption</li>
</ul>
<h4 id="development-efficiency"><a class="header" href="#development-efficiency"><strong>Development Efficiency</strong></a></h4>
<ul>
<li><strong>Single Debug Target</strong>: All scanner issues traced to single implementation</li>
<li><strong>Centralized Improvements</strong>: Performance and correctness improvements benefit all interfaces</li>
<li><strong>Simplified Feature Addition</strong>: New token types added once, available everywhere</li>
<li><strong>Reduced Testing Complexity</strong>: Test coverage for single implementation covers all interfaces</li>
</ul>
<h3 id="implementation-strategy-diataxis-how-to-guide---using-the-unified-scanner"><a class="header" href="#implementation-strategy-diataxis-how-to-guide---using-the-unified-scanner">Implementation Strategy (<em>Diataxis: How-to Guide</em> - Using the unified scanner)</a></h3>
<h4 id="for-new-code-diataxis-tutorial---recommended-approach"><a class="header" href="#for-new-code-diataxis-tutorial---recommended-approach"><strong>For New Code</strong> (<em>Diataxis: Tutorial</em> - Recommended approach)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tree_sitter_perl_rs::RustScanner;

let mut scanner = RustScanner::new();
let token = scanner.scan(input)?;
<span class="boring">}</span></code></pre></pre>
<h4 id="for-legacy-code-diataxis-how-to-guide---migration-approach"><a class="header" href="#for-legacy-code-diataxis-how-to-guide---migration-approach"><strong>For Legacy Code</strong> (<em>Diataxis: How-to Guide</em> - Migration approach)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use tree_sitter_perl_rs::CScanner;  // Drop-in replacement

let mut scanner = CScanner::new();  // Same API as before
let token = scanner.scan(input)?;   // Delegates to RustScanner internally
<span class="boring">}</span></code></pre></pre>
<h4 id="feature-flag-configuration-diataxis-reference---build-configuration"><a class="header" href="#feature-flag-configuration-diataxis-reference---build-configuration"><strong>Feature Flag Configuration</strong> (<em>Diataxis: Reference</em> - Build configuration)</a></h4>
<pre><code class="language-toml"># Cargo.toml - Choose scanner interface
[features]
default = ["rust-scanner"]
rust-scanner = []           # Direct RustScanner access
c-scanner = []              # CScanner wrapper (delegates to RustScanner)
</code></pre>
<h3 id="testing-strategy-diataxis-reference---quality-assurance"><a class="header" href="#testing-strategy-diataxis-reference---quality-assurance">Testing Strategy (<em>Diataxis: Reference</em> - Quality assurance)</a></h3>
<h4 id="unified-test-coverage"><a class="header" href="#unified-test-coverage"><strong>Unified Test Coverage</strong></a></h4>
<ul>
<li><strong><code>tests/rust_scanner_smoke.rs</code></strong>: Validates core scanner functionality</li>
<li><strong>Delegation Tests</strong>: Ensures <code>CScanner</code> properly delegates to <code>RustScanner</code></li>
<li><strong>API Compatibility Tests</strong>: Verifies legacy API contracts remain unchanged</li>
<li><strong>Performance Tests</strong>: Confirms no performance regression from delegation pattern</li>
</ul>
<h4 id="build-validation-diataxis-how-to-guide---development-workflow"><a class="header" href="#build-validation-diataxis-how-to-guide---development-workflow"><strong>Build Validation</strong> (<em>Diataxis: How-to Guide</em> - Development workflow)</a></h4>
<pre><code class="language-bash"># Test both scanner interfaces
cargo test --features rust-scanner
cargo test --features c-scanner

# Validate delegation pattern
cargo test -p tree-sitter-perl-rs rust_scanner_smoke
</code></pre>
<h3 id="migration-implications-diataxis-explanation---understanding-the-changes"><a class="header" href="#migration-implications-diataxis-explanation---understanding-the-changes">Migration Implications (<em>Diataxis: Explanation</em> - Understanding the changes)</a></h3>
<h4 id="what-changed"><a class="header" href="#what-changed"><strong>What Changed</strong></a></h4>
<ul>
<li><strong>Implementation</strong>: <code>CScanner</code> now delegates to <code>RustScanner</code> instead of implementing separately</li>
<li><strong>Build System</strong>: <code>build.rs</code> detects scanner features through environment variables</li>
<li><strong>Testing</strong>: Added smoke tests to validate delegation functionality</li>
</ul>
<h4 id="what-stayed-the-same"><a class="header" href="#what-stayed-the-same"><strong>What Stayed the Same</strong></a></h4>
<ul>
<li><strong>Public API</strong>: All existing <code>CScanner</code> methods and signatures unchanged</li>
<li><strong>Performance</strong>: Same performance characteristics (now consistently Rust-based)</li>
<li><strong>Feature Flags</strong>: Both <code>c-scanner</code> and <code>rust-scanner</code> features continue to work</li>
<li><strong>Benchmarks</strong>: Existing benchmark infrastructure works without modification</li>
</ul>
<h4 id="benefits-realized"><a class="header" href="#benefits-realized"><strong>Benefits Realized</strong></a></h4>
<ul>
<li><strong>Maintainability</strong>: 50% reduction in scanner-related code complexity</li>
<li><strong>Reliability</strong>: Single implementation reduces potential for divergent behavior</li>
<li><strong>Performance</strong>: Consistent Rust performance across all interfaces</li>
<li><strong>Development Velocity</strong>: Scanner improvements benefit all consumers immediately</li>
</ul>
<h3 id="pest-parser-architecture"><a class="header" href="#pest-parser-architecture">Pest Parser Architecture</a></h3>
<ul>
<li>PEG grammar in <code>grammar.pest</code> defines all Perl syntax</li>
<li>Recursive descent parsing with packrat optimization</li>
<li>Zero-copy parsing with <code>&amp;str</code> slices</li>
<li>Feature flag: <code>pure-rust</code> enables the Pest parser</li>
</ul>
<h3 id="ast-generation"><a class="header" href="#ast-generation">AST Generation</a></h3>
<ul>
<li>Strongly typed AST nodes in <code>pure_rust_parser.rs</code></li>
<li>Arc<str> for efficient string storage</li>
<li>Tree-sitter compatible node types</li>
<li>Position tracking for all nodes</li>
</ul>
<h3 id="s-expression-output"><a class="header" href="#s-expression-output">S-Expression Output</a></h3>
<ul>
<li><code>to_sexp()</code> method produces tree-sitter format</li>
<li>Compatible with existing tree-sitter tools</li>
<li>Preserves all position information</li>
<li>Error nodes for unparseable constructs</li>
</ul>
<h3 id="enhanced-position-tracking-v087"><a class="header" href="#enhanced-position-tracking-v087">Enhanced Position Tracking (v0.8.7+)</a></h3>
<ul>
<li><strong>O(log n) Position Mapping</strong>: Efficient binary search-based position lookups using LineStartsCache</li>
<li><strong>LSP-Compliant UTF-16 Support</strong>: Accurate character counting for multi-byte Unicode characters and emoji</li>
<li><strong>Multi-line Token Support</strong>: Proper position tracking for tokens spanning multiple lines (strings, comments, heredocs)</li>
<li><strong>Line Ending Agnostic</strong>: Handles CRLF, LF, and CR line endings consistently across platforms</li>
<li><strong>Production-Ready Integration</strong>: Seamless integration with parser context and LSP server for real-time editing</li>
<li><strong>Comprehensive Testing</strong>: 8 specialized test cases covering Unicode, CRLF, multiline strings, and edge cases</li>
</ul>
<h2 id="enhanced-dual-indexing-strategy-v088--enhanced"><a class="header" href="#enhanced-dual-indexing-strategy-v088--enhanced">Enhanced Dual Indexing Strategy (v0.8.8) ⭐ <strong>ENHANCED</strong></a></h2>
<h3 id="cross-file-reference-resolution"><a class="header" href="#cross-file-reference-resolution">Cross-File Reference Resolution</a></h3>
<p>The workspace indexing system implements a dual indexing strategy for comprehensive cross-file navigation with 98% reference coverage:</p>
<h4 id="core-architecture-pattern-diataxis-reference"><a class="header" href="#core-architecture-pattern-diataxis-reference">Core Architecture Pattern (<em>Diataxis: Reference</em>)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Dual indexing: index function calls under both forms
let qualified = format!("{}::{}", package, bare_name);

// Index under bare name for unqualified calls
file_index.references.entry(bare_name.to_string())
    .or_default().push(symbol_ref.clone());

// Index under qualified name for Package::function calls  
file_index.references.entry(qualified)
    .or_default().push(symbol_ref);
<span class="boring">}</span></code></pre></pre>
<h4 id="enhanced-reference-search-diataxis-reference"><a class="header" href="#enhanced-reference-search-diataxis-reference">Enhanced Reference Search (<em>Diataxis: Reference</em>)</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_references(&amp;self, symbol_name: &amp;str) -&gt; Vec&lt;Location&gt; {
    let mut locations = Vec::new();
    
    // Search exact match first
    if let Some(refs) = index.get(symbol_name) {
        locations.extend(refs.iter().cloned());
    }
    
    // If qualified, also search bare name
    if let Some(idx) = symbol_name.rfind("::") {
        let bare_name = &amp;symbol_name[idx + 2..];
        if let Some(refs) = index.get(bare_name) {
            locations.extend(refs.iter().cloned());
        }
    }
    
    locations
}
<span class="boring">}</span></code></pre></pre>
<h4 id="smart-deduplication-algorithm"><a class="header" href="#smart-deduplication-algorithm">Smart Deduplication Algorithm</a></h4>
<ul>
<li><strong>URI and Range-Based</strong>: Prevents duplicate references based on file location and position</li>
<li><strong>HashSet Optimization</strong>: O(1) deduplication using composite keys</li>
<li><strong>Definition Exclusion</strong>: Function definitions properly excluded from “Find All References”</li>
<li><strong>LSP Compliance</strong>: Results match LSP specification for reference vs definition separation</li>
</ul>
<h4 id="key-benefits-diataxis-explanation"><a class="header" href="#key-benefits-diataxis-explanation">Key Benefits (<em>Diataxis: Explanation</em>)</a></h4>
<ul>
<li><strong>98% Reference Coverage</strong>: Handles both <code>Package::function</code> and <code>function</code> call patterns</li>
<li><strong>Performance Optimized</strong>: Dual lookups with efficient HashSet deduplication</li>
<li><strong>Backward Compatible</strong>: Existing code continues to work with enhanced indexing</li>
<li><strong>Enterprise Ready</strong>: Production-stable workspace navigation across package boundaries</li>
</ul>
<h2 id="import-optimization-architecture-v088--new"><a class="header" href="#import-optimization-architecture-v088--new">Import Optimization Architecture (v0.8.8) ⭐ <strong>NEW</strong></a></h2>
<h3 id="core-components-1"><a class="header" href="#core-components-1">Core Components</a></h3>
<h4 id="cratesperl-parsersrcimport_optimizerrs---analysis-engine"><a class="header" href="#cratesperl-parsersrcimport_optimizerrs---analysis-engine"><code>/crates/perl-parser/src/import_optimizer.rs</code> - Analysis Engine</a></h4>
<ul>
<li><strong>Purpose</strong>: Stateless import analysis and optimization engine</li>
<li><strong>Features</strong>:
<ul>
<li><strong>Unused Import Detection</strong>: Regex-based usage analysis identifies import statements never used in code</li>
<li><strong>Duplicate Import Consolidation</strong>: Merges multiple import lines from same module into single optimized statements</li>
<li><strong>Missing Import Detection</strong>: Identifies Module::symbol references requiring additional imports</li>
<li><strong>Alphabetical Sorting</strong>: Organizes imports in consistent alphabetical order</li>
<li><strong>Performance Optimized</strong>: Fast analysis suitable for real-time LSP code actions (&lt;10ms for typical files)</li>
<li><strong>Conservative Analysis</strong>: Careful handling for pragma modules and modules with side effects</li>
</ul>
</li>
</ul>
<h4 id="key-architecture-patterns"><a class="header" href="#key-architecture-patterns">Key Architecture Patterns</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Stateless analyzer for thread safety
pub struct ImportOptimizer;

// Comprehensive analysis result
pub struct ImportAnalysis {
    pub imports: Vec&lt;ImportEntry&gt;,
    pub unused_imports: Vec&lt;UnusedImport&gt;,
    pub duplicate_imports: Vec&lt;DuplicateImport&gt;, 
    pub missing_imports: Vec&lt;MissingImport&gt;,
    pub organization_suggestions: Vec&lt;OrganizationSuggestion&gt;,
}

// LSP integration ready
impl ImportOptimizer {
    pub fn generate_edits(&amp;self, content: &amp;str, analysis: &amp;ImportAnalysis) -&gt; Vec&lt;TextEdit&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h4 id="cratesperl-parsersrccode_actionsrs---lsp-integration"><a class="header" href="#cratesperl-parsersrccode_actionsrs---lsp-integration"><code>/crates/perl-parser/src/code_actions.rs</code> - LSP Integration</a></h4>
<ul>
<li><strong>Purpose</strong>: Code actions provider with import optimization integration</li>
<li><strong>Features</strong>:
<ul>
<li><strong>“Organize Imports” Action</strong>: Standard LSP source.organizeImports code action kind</li>
<li><strong>Quick Fix Actions</strong>: Specific actions for unused/missing imports</li>
<li><strong>Text Edit Generation</strong>: LSP-compatible text edits for applying optimizations</li>
<li><strong>Real-time Analysis</strong>: Import issues detected as you type with immediate fixes</li>
</ul>
</li>
</ul>
<h4 id="integration-architecture"><a class="header" href="#integration-architecture">Integration Architecture</a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Automatic integration with code actions system
pub fn get_code_actions(&amp;self, ast: &amp;Node, range: (usize, usize), diagnostics: &amp;[Diagnostic]) -&gt; Vec&lt;CodeAction&gt; {
    let mut actions = Vec::new();
    
    // Add diagnostic-based fixes...
    
    // Import optimization always available
    if let Some(import_action) = self.optimize_imports() {
        actions.push(import_action);
    }
    
    actions
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h3>
<ul>
<li><strong>Analysis Speed</strong>: &lt;10ms for files with &lt;100 imports, &lt;50ms for files with 100-500 imports</li>
<li><strong>Memory Efficiency</strong>: Bounded processing with file size limits (1MB max)</li>
<li><strong>LSP Responsiveness</strong>: Suitable for real-time editor integration</li>
<li><strong>Thread Safety</strong>: Stateless analyzer with no shared mutable state</li>
</ul>
<h3 id="editor-integration"><a class="header" href="#editor-integration">Editor Integration</a></h3>
<ul>
<li><strong>VSCode</strong>: Seamless “Organize Imports” (Cmd/Ctrl+Shift+O) and context menu integration</li>
<li><strong>Neovim/Emacs</strong>: Full LSP code action support for import optimization</li>
<li><strong>Real-time Feedback</strong>: Import issues show as available quick fixes in editor UI</li>
<li><strong>Preview Changes</strong>: Editor diff view shows changes before applying optimizations</li>
</ul>
<h3 id="edge-case-handling"><a class="header" href="#edge-case-handling">Edge Case Handling</a></h3>
<ul>
<li>Comprehensive heredoc support (93% edge case test coverage)</li>
<li>Phase-aware parsing for BEGIN/END blocks</li>
<li>Dynamic delimiter detection and recovery</li>
<li>Clear diagnostics for unparseable constructs</li>
</ul>
<h3 id="testing-strategy"><a class="header" href="#testing-strategy">Testing Strategy</a></h3>
<ul>
<li>Grammar tests for each Perl construct</li>
<li>Edge case tests with property testing</li>
<li>Performance benchmarks</li>
<li>Integration tests for S-expression output</li>
<li>Position tracking validation tests</li>
<li>Encoding-aware lexing for mid-file encoding changes</li>
<li>Tree-sitter compatible error nodes and diagnostics</li>
<li>Performance optimized (&lt;5% overhead for normal code)</li>
</ul>
<h2 id="agent-ecosystem-integration-pr-153-diataxis-explanation---specialized-workflow-automation"><a class="header" href="#agent-ecosystem-integration-pr-153-diataxis-explanation---specialized-workflow-automation">Agent Ecosystem Integration (PR #153) (<em>Diataxis: Explanation</em> - Specialized workflow automation)</a></h2>
<h3 id="94-specialized-agents-architecture"><a class="header" href="#94-specialized-agents-architecture">94 Specialized Agents Architecture</a></h3>
<p><strong>Revolutionary Workflow Enhancement</strong>: PR #153 introduces a comprehensive agent ecosystem with 94 specialized agents designed specifically for the tree-sitter-perl parsing ecosystem. This represents a paradigm shift from generic automation to domain-specific intelligent workflow coordination.</p>
<h4 id="agent-directory-structure-diataxis-reference---agent-organization"><a class="header" href="#agent-directory-structure-diataxis-reference---agent-organization">Agent Directory Structure (<em>Diataxis: Reference</em> - Agent organization)</a></h4>
<pre><code>.claude/agents2/                          # 94 specialized agents (vs. 53 generic)
├── review/                               # 26 agents - PR review workflow
│   ├── review-security-scanner.md       # UTF-16 security validation
│   ├── review-mutation-tester.md        # 87% quality score validation
│   ├── review-performance-validator.md  # Revolutionary performance preservation
│   └── review-governance-gate.md        # Final quality assurance
├── integration/                          # 21 agents - CI/CD coordination
│   ├── integration-test-coordinator.md  # Adaptive threading orchestration
│   ├── integration-workspace-validator.md # Multi-crate validation
│   └── integration-performance-monitor.md # 5000x LSP improvements tracking
├── generative/                           # 24 agents - Content creation
│   ├── generative-doc-writer.md         # Parser ecosystem documentation
│   ├── generative-test-creator.md       # Mutation hardening test generation
│   └── generative-parser-enhancer.md    # AST and parsing improvements
├── mantle/                               # 17 agents - Maintenance operations
│   ├── mantle-dependency-manager.md     # Workspace dependency coordination
│   ├── mantle-release-coordinator.md    # Multi-crate release orchestration
│   └── mantle-security-auditor.md       # Enterprise security compliance
└── other/                                # 6 agents - Cross-cutting concerns
    ├── agent-customizer.md              # Self-adapting agent framework
    └── workflow-orchestrator.md         # Agent coordination patterns
</code></pre>
<h4 id="specialized-agent-capabilities-diataxis-explanation---domain-expertise-integration"><a class="header" href="#specialized-agent-capabilities-diataxis-explanation---domain-expertise-integration">Specialized Agent Capabilities (<em>Diataxis: Explanation</em> - Domain expertise integration)</a></h4>
<p><strong>Parser Ecosystem Context Integration:</strong></p>
<ul>
<li><strong>Multi-crate Architecture</strong>: Understanding of 5 published crates and their interdependencies</li>
<li><strong>Performance Standards</strong>: Built-in knowledge of revolutionary performance requirements (5000x LSP improvements)</li>
<li><strong>Security Requirements</strong>: UTF-16 position conversion security, enterprise-grade Unicode safety</li>
<li><strong>Quality Metrics</strong>: Mutation testing (87% score), zero clippy warnings, comprehensive test coverage</li>
</ul>
<p><strong>Intelligent Workflow Coordination:</strong></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Example: Security-focused agent routing
SecurityScanner → MutationTester → PerformanceValidator → GovernanceGate

// Example: Development agent coordination
CodeEnhancer → TestCreator → DocGenerator → ReviewPrep
<span class="boring">}</span></code></pre></pre>
<h4 id="agent-customization-framework-diataxis-reference---self-adapting-architecture"><a class="header" href="#agent-customization-framework-diataxis-reference---self-adapting-architecture">Agent Customization Framework (<em>Diataxis: Reference</em> - Self-adapting architecture)</a></h4>
<p><strong>Contextual Adaptation Engine:</strong></p>
<pre><code class="language-markdown"># Agent customizes itself based on project context
- Multi-crate workspace patterns (perl-parser ⭐, perl-lsp ⭐, perl-lexer, perl-corpus)
- Revolutionary performance requirements (sub-microsecond parsing, &lt;1ms LSP updates)
- Enterprise security standards (UTF-16 safety, path traversal prevention)
- Comprehensive quality validation (87% mutation score, zero clippy warnings)
</code></pre>
<p><strong>Self-Documenting Configuration:</strong></p>
<ul>
<li><strong>Inline Expertise</strong>: Each agent includes parser ecosystem domain knowledge</li>
<li><strong>Quality Integration</strong>: Built-in understanding of mutation testing and performance benchmarks</li>
<li><strong>Security Awareness</strong>: UTF-16 position conversion security and enterprise patterns</li>
<li><strong>Workflow Intelligence</strong>: Context-aware routing between specialized agents</li>
</ul>
<h4 id="quality-and-security-integration-diataxis-explanation---enterprise-grade-validation"><a class="header" href="#quality-and-security-integration-diataxis-explanation---enterprise-grade-validation">Quality and Security Integration (<em>Diataxis: Explanation</em> - Enterprise-grade validation)</a></h4>
<p><strong>Mutation Testing Coordination:</strong></p>
<ul>
<li><strong>Real Bug Discovery</strong>: Agents coordinate mutation testing that discovered UTF-16 security vulnerabilities</li>
<li><strong>Quality Score Achievement</strong>: 87% mutation score through systematic agent-driven testing</li>
<li><strong>Security Validation</strong>: UTF-16 boundary violation detection and remediation</li>
</ul>
<p><strong>Performance Preservation:</strong></p>
<ul>
<li><strong>Revolutionary Standards</strong>: Agents ensure 5000x LSP performance improvements are maintained</li>
<li><strong>Security-Performance Balance</strong>: Enhanced security without performance regression</li>
<li><strong>Adaptive Threading</strong>: CI environment optimization through intelligent agent coordination</li>
</ul>
<h4 id="integration-points-diataxis-reference---agent-ecosystem-interfaces"><a class="header" href="#integration-points-diataxis-reference---agent-ecosystem-interfaces">Integration Points (<em>Diataxis: Reference</em> - Agent ecosystem interfaces)</a></h4>
<p><strong>Crate Integration:</strong></p>
<ul>
<li><strong><code>/crates/perl-parser/</code></strong>: Core parser logic enhanced by generative agents (test creation, performance optimization)</li>
<li><strong><code>/crates/perl-lsp/</code></strong>: LSP server validated by review agents (security scanning, performance validation)</li>
<li><strong><code>/crates/perl-lexer/</code></strong>: Tokenizer improvements coordinated by integration agents</li>
<li><strong><code>/crates/perl-corpus/</code></strong>: Test corpus expansion through generative and integration agents</li>
</ul>
<p><strong>Documentation Ecosystem:</strong></p>
<ul>
<li><strong><code>/docs/</code></strong>: Comprehensive documentation maintained by specialized doc-writer agents</li>
<li><strong>ADRs</strong>: Architecture decisions documented and validated by governance agents</li>
<li><strong>Security Guides</strong>: Enterprise security patterns maintained by security-focused agents</li>
</ul>
<h4 id="workflow-orchestration-patterns-diataxis-how-to---agent-coordination"><a class="header" href="#workflow-orchestration-patterns-diataxis-how-to---agent-coordination">Workflow Orchestration Patterns (<em>Diataxis: How-to</em> - Agent coordination)</a></h4>
<p><strong>Review Workflow:</strong></p>
<pre><code class="language-bash"># Agent-coordinated PR review with intelligent routing
review-security-scanner     # UTF-16 security validation
  ↓
review-mutation-tester      # 87% quality score verification
  ↓
review-performance-validator # Revolutionary performance preservation
  ↓
review-governance-gate      # Final quality assurance and routing decision
</code></pre>
<p><strong>Development Workflow:</strong></p>
<pre><code class="language-bash"># Agent-enhanced development cycle
generative-parser-enhancer  # AST and parsing improvements
  ↓
generative-test-creator     # Comprehensive test coverage
  ↓
integration-test-coordinator # Multi-crate validation
  ↓
generative-doc-writer       # Documentation synchronization
</code></pre>
<h2 id="development-guidelines"><a class="header" href="#development-guidelines">Development Guidelines</a></h2>
<h3 id="choosing-a-crate"><a class="header" href="#choosing-a-crate">Choosing a Crate</a></h3>
<ol>
<li><strong>For Any Perl Parsing</strong>: Use <code>perl-parser</code> - fastest, most complete, production-ready with Rope support</li>
<li><strong>For IDE Integration</strong>: Install <code>perl-lsp</code> from <code>perl-parser</code> crate - includes full Rope-based document management</li>
<li><strong>For Testing Parsers</strong>: Use <code>perl-corpus</code> for comprehensive test suite</li>
<li><strong>For Legacy Migration</strong>: Migrate from <code>perl-parser-pest</code> to <code>perl-parser</code></li>
</ol>
<h3 id="development-locations"><a class="header" href="#development-locations">Development Locations</a></h3>
<ul>
<li><strong>Parser &amp; LSP</strong>: <code>/crates/perl-parser/</code> - main development with production Rope implementation</li>
<li><strong>LSP Server</strong>: <code>/crates/perl-lsp/</code> - standalone LSP server binary (v0.8.8)</li>
<li><strong>Lexer</strong>: <code>/crates/perl-lexer/</code> - tokenization improvements</li>
<li><strong>Test Corpus</strong>: <code>/crates/perl-corpus/</code> - test case additions</li>
<li><strong>Legacy (Excluded)</strong>: <code>/crates/perl-parser-pest/</code> - maintenance only, excluded from workspace</li>
<li><strong>Advanced Testing (Excluded)</strong>: <code>/xtask/</code> - dual-scanner corpus comparison, excluded due to libclang dependencies</li>
</ul>
<h3 id="rope-development-guidelines"><a class="header" href="#rope-development-guidelines">Rope Development Guidelines</a></h3>
<p><strong>IMPORTANT</strong>: All Rope improvements should target the <strong>production perl-parser crate</strong>, not internal test harnesses.</p>
<p><strong>Production Rope Modules</strong> (Target for improvements):</p>
<ul>
<li><strong><code>/crates/perl-parser/src/textdoc.rs</code></strong>: Core document management with <code>ropey::Rope</code></li>
<li><strong><code>/crates/perl-parser/src/position_mapper.rs</code></strong>: UTF-16/UTF-8 position conversion</li>
<li><strong><code>/crates/perl-parser/src/incremental_integration.rs</code></strong>: LSP integration bridge</li>
<li><strong><code>/crates/perl-parser/src/incremental_handler_v2.rs</code></strong>: Document change processing</li>
</ul>
<p><strong>Do NOT modify these Rope usages</strong> (internal test code):</p>
<ul>
<li><strong><code>/crates/tree-sitter-perl-rs/</code></strong>: Legacy test harnesses with outdated Rope usage</li>
<li><strong>Internal test infrastructure</strong>: Focus on production code, not test utilities</li>
</ul>
<h2 id="dual-indexing-architecture-v088-diataxis-explanation---revolutionary-workspace-navigation-design"><a class="header" href="#dual-indexing-architecture-v088-diataxis-explanation---revolutionary-workspace-navigation-design">Dual Indexing Architecture (v0.8.8+) (<em>Diataxis: Explanation</em> - Revolutionary workspace navigation design)</a></h2>
<h3 id="problem-statement-diataxis-explanation---why-dual-indexing-is-needed"><a class="header" href="#problem-statement-diataxis-explanation---why-dual-indexing-is-needed">Problem Statement (<em>Diataxis: Explanation</em> - Why dual indexing is needed)</a></h3>
<p>Perl’s flexible function calling conventions create significant challenges for static analysis and IDE features:</p>
<pre><code class="language-perl"># File: lib/Utils.pm
package Utils;
sub process_data { ... }

# File: main.pl  
use Utils;

# All three reference the same function:
Utils::process_data();    # Qualified call
process_data();          # Bare call (via import)
&amp;process_data();         # Explicit subroutine call
</code></pre>
<p>Traditional LSP servers index functions under a single name form, leading to:</p>
<ul>
<li><strong>High false negative rates</strong> (~15%): Missing references when users call functions differently than indexed</li>
<li><strong>Inconsistent go-to-definition</strong>: Works for some call styles but not others</li>
<li><strong>Poor find-references coverage</strong>: Only finds references matching the indexing style</li>
</ul>
<h3 id="solution-dual-indexing-strategy-diataxis-reference---technical-implementation"><a class="header" href="#solution-dual-indexing-strategy-diataxis-reference---technical-implementation">Solution: Dual Indexing Strategy (<em>Diataxis: Reference</em> - Technical implementation)</a></h3>
<p>The dual indexing strategy solves this by indexing every function under <strong>both</strong> its qualified and bare name forms.</p>
<h4 id="core-algorithm-diataxis-reference---implementation-specification"><a class="header" href="#core-algorithm-diataxis-reference---implementation-specification">Core Algorithm (<em>Diataxis: Reference</em> - Implementation specification)</a></h4>
<p><strong>Indexing Phase</strong> (<code>/crates/perl-parser/src/workspace_index.rs</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For every function call, index under both forms
let qualified = format!("{}::{}", package, bare_name);

// Store under bare name
file_index.references.entry(bare_name.to_string()).or_default().push(
    SymbolReference {
        uri: self.uri.clone(),
        range: location,
        kind: ReferenceKind::Usage,
    }
);

// Store under qualified name
file_index.references.entry(qualified).or_default().push(SymbolReference {
    uri: self.uri.clone(), 
    range: location,
    kind: ReferenceKind::Usage,
});
<span class="boring">}</span></code></pre></pre>
<p><strong>Retrieval Phase</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Dual pattern search with automatic deduplication
pub fn find_references(&amp;self, symbol_name: &amp;str) -&gt; Vec&lt;Location&gt; {
    let mut locations = Vec::new();
    
    // Search exact match first
    if let Some(refs) = index.get(symbol_name) {
        locations.extend(refs.iter().map(|r| Location {
            uri: r.uri.clone(),
            range: r.range
        }));
    }
    
    // If qualified, also search bare name
    if let Some(idx) = symbol_name.rfind("::") {
        let bare_name = &amp;symbol_name[idx + 2..];
        if let Some(refs) = index.get(bare_name) {
            locations.extend(refs.iter().map(|r| Location {
                uri: r.uri.clone(),
                range: r.range
            }));
        }
    }
    
    locations
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-impact-diataxis-reference---performance-characteristics"><a class="header" href="#performance-impact-diataxis-reference---performance-characteristics">Performance Impact (<em>Diataxis: Reference</em> - Performance characteristics)</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Metric</th><th>Before Dual Indexing</th><th>After Dual Indexing</th><th>Change</th></tr></thead><tbody>
<tr><td><strong>Reference Coverage</strong></td><td>~85% (single form)</td><td>~98% (both forms)</td><td>+15%</td></tr>
<tr><td><strong>False Negatives</strong></td><td>High (missed calls)</td><td>Minimal</td><td>-90%</td></tr>
<tr><td><strong>Index Memory Usage</strong></td><td>Baseline</td><td>+10-15%</td><td>Acceptable</td></tr>
<tr><td><strong>Search Performance</strong></td><td>Fast</td><td>Fast (dual lookup)</td><td>Maintained</td></tr>
<tr><td><strong>Go-to-Definition Success</strong></td><td>~83%</td><td>~98%</td><td>+18%</td></tr>
</tbody></table>
</div>
<h3 id="integration-with-lexer-diataxis-reference---supporting-infrastructure"><a class="header" href="#integration-with-lexer-diataxis-reference---supporting-infrastructure">Integration with Lexer (<em>Diataxis: Reference</em> - Supporting infrastructure)</a></h3>
<p>The lexer enhancement in <code>/crates/perl-lexer/src/lib.rs</code> supports dual indexing by properly tokenizing package-qualified identifiers:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Handle package-qualified identifiers like Foo::bar
while self.current_char() == Some(':') &amp;&amp; self.peek_char(1) == Some(':') {
    // consume '::'
    self.advance();
    self.advance();
    
    // Continue with next segment
    while let Some(ch) = self.current_char() {
        if is_perl_identifier_continue(ch) {
            self.advance();
        } else {
            break;
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="benefits-diataxis-explanation---architectural-advantages"><a class="header" href="#benefits-diataxis-explanation---architectural-advantages">Benefits (<em>Diataxis: Explanation</em> - Architectural advantages)</a></h3>
<ol>
<li><strong>Comprehensive Coverage</strong>: Finds all references regardless of calling style</li>
<li><strong>Consistent Behavior</strong>: Go-to-definition works from any reference form</li>
<li><strong>Zero Breaking Changes</strong>: Existing code continues to work</li>
<li><strong>Minimal Performance Impact</strong>: Smart indexing with deduplication</li>
<li><strong>Improved Developer Experience</strong>: More accurate LSP features across the board</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../architecture/overview.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../architecture/parser-design.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../architecture/overview.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../architecture/parser-design.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
