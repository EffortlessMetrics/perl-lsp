<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Commands Reference - Perl LSP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the perl-lsp project - a production-ready Perl Language Server Protocol implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Perl LSP Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/EffortlessMetrics/tree-sitter-perl-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="commands-reference-diataxis-reference---complete-command-specifications"><a class="header" href="#commands-reference-diataxis-reference---complete-command-specifications">Commands Reference (<em>Diataxis: Reference</em> - Complete command specifications)</a></h1>
<p><em>This reference provides all available commands for building, testing, and using the tree-sitter-perl ecosystem.</em></p>
<h2 id="installation-commands-diataxis-how-to-guide---step-by-step-installation"><a class="header" href="#installation-commands-diataxis-how-to-guide---step-by-step-installation">Installation Commands (<em>Diataxis: How-to Guide</em> - Step-by-step installation)</a></h2>
<h3 id="lsp-server"><a class="header" href="#lsp-server">LSP Server</a></h3>
<pre><code class="language-bash"># Quick install (Linux/macOS)
curl -fsSL https://raw.githubusercontent.com/EffortlessSteven/tree-sitter-perl/main/install.sh | bash

# Homebrew (macOS)
brew tap tree-sitter-perl/tap
brew install perl-lsp

# Build from source
cargo build -p perl-lsp --release

# Install globally
cargo install --path crates/perl-lsp

# Run the LSP server
perl-lsp --stdio  # For editor integration
perl-lsp --stdio --log  # With debug logging
</code></pre>
<h3 id="dap-server-debug-adapter"><a class="header" href="#dap-server-debug-adapter">DAP Server (Debug Adapter)</a></h3>
<pre><code class="language-bash"># Build DAP server
cargo build -p perl-parser --bin perl-dap --release

# Install DAP server globally
cargo install --path crates/perl-parser --bin perl-dap

# Run the DAP server (for VSCode integration)
perl-dap --stdio  # Standard DAP transport
</code></pre>
<h2 id="build-commands-diataxis-how-to-guide---development-builds"><a class="header" href="#build-commands-diataxis-how-to-guide---development-builds">Build Commands (<em>Diataxis: How-to Guide</em> - Development builds)</a></h2>
<h3 id="published-crates"><a class="header" href="#published-crates">Published Crates</a></h3>
<pre><code class="language-bash"># Install from crates.io
cargo install perl-lsp                     # LSP server
cargo add perl-parser                      # As library dependency
cargo add perl-corpus --dev                # For testing

# Build from source
cargo build -p perl-parser --release
cargo build -p perl-lexer --release
cargo build -p perl-corpus --release
cargo build -p perl-parser-pest --release  # Legacy
</code></pre>
<h3 id="native-parser-recommended"><a class="header" href="#native-parser-recommended">Native Parser (Recommended)</a></h3>
<pre><code class="language-bash"># Build the lexer and parser
cargo build -p perl-lexer -p perl-parser

# Build with incremental parsing support
cargo build -p perl-parser --features incremental

# Build in release mode
cargo build -p perl-lexer -p perl-parser --release

# Build with incremental parsing in release mode
cargo build -p perl-parser --features incremental --release

# Build everything
cargo build --all
</code></pre>
<h2 id="workspace-configuration-v088"><a class="header" href="#workspace-configuration-v088">Workspace Configuration (v0.8.8+)</a></h2>
<p>The workspace uses an exclusion strategy to ensure reliable builds across all platforms:</p>
<pre><code class="language-bash"># Workspace tests (production crates only)
cargo test  # Tests perl-parser, perl-lsp, perl-lexer, perl-corpus

# Check workspace configuration
cargo check  # Should build cleanly without system dependencies

# Workspace status report (see WORKSPACE_TEST_REPORT.md)
# - Excludes tree-sitter-perl-c (requires libclang/system dependencies)
# - Excludes example crates with feature conflicts 
# - Focuses on published crate stability
</code></pre>
<h3 id="workspace-architecture-benefits"><a class="header" href="#workspace-architecture-benefits">Workspace Architecture Benefits</a></h3>
<ul>
<li><strong>Clean Builds</strong>: No system dependency failures (libclang, parser.c)</li>
<li><strong>CI Stability</strong>: Consistent test results across platforms</li>
<li><strong>Production Focus</strong>: Tests only published crate APIs</li>
<li><strong>Platform Independence</strong>: Works without tree-sitter C toolchain</li>
</ul>
<h3 id="xtask-exclusion-strategy-diataxis-explanation---design-decisions"><a class="header" href="#xtask-exclusion-strategy-diataxis-explanation---design-decisions">xtask Exclusion Strategy (<em>Diataxis: Explanation</em> - Design decisions)</a></h3>
<p>The xtask crate is excluded from the workspace to maintain clean builds while preserving advanced functionality:</p>
<ul>
<li><strong>Why excluded</strong>: xtask depends on excluded crates (tree-sitter-perl-rs with libclang)</li>
<li><strong>How to use</strong>: Run from xtask directory: <code>cd xtask &amp;&amp; cargo run &lt;command&gt;</code></li>
<li><strong>Benefits</strong>: Workspace builds remain system-dependency-free</li>
<li><strong>Advanced features</strong>: Dual-scanner corpus comparison requires libclang-dev</li>
</ul>
<h2 id="test-commands"><a class="header" href="#test-commands">Test Commands</a></h2>
<h3 id="workspace-testing-v088"><a class="header" href="#workspace-testing-v088">Workspace Testing (v0.8.8)</a></h3>
<pre><code class="language-bash"># Test core published crates (workspace members only)
cargo test                              # Tests perl-lexer, perl-parser, perl-corpus, perl-lsp
                                        # Excludes crates with system dependencies

# Test individual published crates
cargo test -p perl-parser               # Main parser library tests (195 tests)
cargo test -p perl-lexer                # Lexer tests (40 tests)  
cargo test -p perl-corpus               # Corpus tests (12 tests)
cargo test -p perl-lsp                  # LSP integration tests

# Advanced test commands (excluded from workspace, run from xtask directory)
# cd xtask &amp;&amp; cargo run test            # Advanced xtask test suite
# cd xtask &amp;&amp; cargo run corpus          # Dual-scanner corpus comparison
</code></pre>
<h3 id="comprehensive-integration-testing"><a class="header" href="#comprehensive-integration-testing">Comprehensive Integration Testing</a></h3>
<pre><code class="language-bash"># LSP E2E tests
cargo test -p perl-parser --test lsp_comprehensive_e2e_test  # 33 LSP E2E tests

# Symbol documentation tests (comment extraction)
cargo test -p perl-parser --test symbol_documentation_tests

# File completion tests
cargo test -p perl-parser --test file_completion_tests

# DAP tests
cargo test -p perl-parser --test dap_comprehensive_test
cargo test -p perl-parser --test dap_integration_test -- --ignored  # Full integration test

# Incremental parsing tests
cargo test -p perl-parser --test incremental_integration_test --features incremental
cargo test -p perl-parser --features incremental
cargo test -p perl-parser incremental_v2::tests            # IncrementalParserV2 tests

# Performance and benchmark tests  
cargo test -p perl-parser --test incremental_perf_test
cargo bench incremental --features incremental
</code></pre>
<h3 id="enhanced-workspace-navigation-tests-v088"><a class="header" href="#enhanced-workspace-navigation-tests-v088">Enhanced Workspace Navigation Tests (v0.8.8)</a></h3>
<pre><code class="language-bash"># Test comprehensive AST traversal with ExpressionStatement support
cargo test -p perl-parser --test workspace_comprehensive_traversal_test

# Test enhanced code actions and refactoring
cargo test -p perl-parser code_actions_enhanced

# Test improved call hierarchy provider
cargo test -p perl-parser call_hierarchy_provider

# Test enhanced workspace indexing and symbol resolution
cargo test -p perl-parser workspace_index workspace_rename

# Test TDD basic functionality enhancements
cargo test -p perl-parser tdd_basic
</code></pre>
<h3 id="wsl-safe-local-gate-diataxis-how-to-guide---resource-constrained-testing"><a class="header" href="#wsl-safe-local-gate-diataxis-how-to-guide---resource-constrained-testing">WSL-Safe Local Gate (<em>Diataxis: How-to Guide</em> - Resource-constrained testing)</a></h3>
<p>The local gate script provides a reliable test workflow for WSL, containers, and resource-constrained environments by controlling parallelism to prevent OOM crashes.</p>
<pre><code class="language-bash"># Standard WSL-safe execution (debug build, recommended)
CARGO_BUILD_JOBS=2 RUST_TEST_THREADS=1 ./scripts/gate-local.sh

# Release build mode (faster execution, more memory-intensive)
GATE_RELEASE=1 CARGO_BUILD_JOBS=2 RUST_TEST_THREADS=1 ./scripts/gate-local.sh

# Custom parallelism (for systems with more resources)
CARGO_BUILD_JOBS=4 RUST_TEST_THREADS=2 ./scripts/gate-local.sh
</code></pre>
<p><strong>What the gate checks:</strong></p>
<ol>
<li><strong>Format check</strong>: <code>cargo fmt --all -- --check</code></li>
<li><strong>Clippy lints</strong>: <code>cargo clippy --workspace --all-targets -- -D warnings</code></li>
<li><strong>Build perl-lsp binary</strong>: Ensures tests use the correct version</li>
<li><strong>Binary version check</strong>: Catches stale/wrong binary issues immediately</li>
<li><strong>perl-parser tests</strong>: Library tests with thread control</li>
<li><strong>perl-lsp tests</strong>: Integration tests with proper binary</li>
<li><strong>perl-lexer tests</strong>: Optional, non-fatal</li>
<li><strong>perl-dap tests</strong>: Optional, non-fatal</li>
</ol>
<p><strong>Why this matters:</strong></p>
<ul>
<li>Prevents ‚Äúmysterious hover null‚Äù issues caused by testing against stale binaries</li>
<li>The <code>binary_version_test</code> runs first to catch wrong-binary issues immediately</li>
<li>Debug binary is built explicitly before tests (avoids stale release binary trap)</li>
<li>Controlled parallelism prevents WSL OOM crashes</li>
<li>Works reliably in CI containers with limited resources</li>
</ul>
<p><strong>Environment variables:</strong></p>
<div class="table-wrapper"><table><thead><tr><th>Variable</th><th>Default</th><th>Description</th></tr></thead><tbody>
<tr><td><code>CARGO_BUILD_JOBS</code></td><td>2</td><td>Parallel rustc invocations</td></tr>
<tr><td><code>RUST_TEST_THREADS</code></td><td>1</td><td>Test parallelism (1 = serial)</td></tr>
<tr><td><code>GATE_RELEASE</code></td><td>unset</td><td>Set to ‚Äú1‚Äù for release builds</td></tr>
</tbody></table>
</div>
<h3 id="revolutionary-performance-testing-pr-140-diataxis-how-to-guide---game-changing-test-reliability"><a class="header" href="#revolutionary-performance-testing-pr-140-diataxis-how-to-guide---game-changing-test-reliability">Revolutionary Performance Testing (PR #140) (<em>Diataxis: How-to Guide</em> - Game-changing test reliability)</a></h3>
<p>PR #140 delivers transformative performance optimizations achieving unprecedented test speed and reliability:</p>
<ul>
<li><strong>LSP behavioral tests</strong>: 1560s+ ‚Üí 0.31s (<strong>5000x faster</strong>)</li>
<li><strong>User story tests</strong>: 1500s+ ‚Üí 0.32s (<strong>4700x faster</strong>)</li>
<li><strong>Workspace tests</strong>: 60s+ ‚Üí 0.26s (<strong>230x faster</strong>)</li>
<li><strong>Overall suite</strong>: 60s+ ‚Üí &lt;10s (<strong>6x faster</strong>)</li>
</ul>
<p>The testing infrastructure includes sophisticated adaptive threading configuration that scales timeouts and concurrency based on system constraints, enhanced with intelligent symbol waiting and optimized idle detection cycles.</p>
<pre><code class="language-bash"># Revolutionary CI testing with adaptive timeouts (PR #140 optimizations)
RUST_TEST_THREADS=2 cargo test -p perl-lsp              # 5000x faster behavioral tests
RUST_TEST_THREADS=2 cargo test -p perl-parser           # Enhanced with intelligent symbol waiting

# Optimized single-threaded testing (maximum reliability)
RUST_TEST_THREADS=1 cargo test --test lsp_comprehensive_e2e_test  # Exponential backoff protection

# High-performance development environment
cargo test -p perl-lsp                                   # 200ms idle detection cycles (was 1000ms)
cargo test                                               # &lt;10s total execution (was &gt;60s)

# Enhanced timeout configuration (PR #140 features)
LSP_TEST_TIMEOUT_MS=20000 cargo test -p perl-lsp        # Override adaptive timeouts
LSP_TEST_SHORT_MS=1000 cargo test -p perl-lsp           # Fine-grained timeout control

# Advanced debugging with performance monitoring
LSP_TEST_ECHO_STDERR=1 RUST_TEST_THREADS=2 cargo test -p perl-lsp -- --nocapture
RUST_LOG=debug cargo test -p perl-lsp -- --nocapture    # Monitor timeout scaling
</code></pre>
<h4 id="revolutionary-performance-matrix-diataxis-reference---pr-140-achievements"><a class="header" href="#revolutionary-performance-matrix-diataxis-reference---pr-140-achievements">Revolutionary Performance Matrix (<em>Diataxis: Reference</em> - PR #140 achievements)</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Test Suite</th><th>Before PR #140</th><th>After PR #140</th><th>Improvement</th><th>Strategic Value</th></tr></thead><tbody>
<tr><td><strong>lsp_behavioral_tests</strong></td><td>1560s+</td><td>0.31s</td><td><strong>5000x faster</strong></td><td>Transformational</td></tr>
<tr><td><strong>lsp_full_coverage_user_stories</strong></td><td>1500s+</td><td>0.32s</td><td><strong>4700x faster</strong></td><td>Revolutionary</td></tr>
<tr><td><strong>Individual workspace tests</strong></td><td>60s+</td><td>0.26s</td><td><strong>230x faster</strong></td><td>Game-changing</td></tr>
<tr><td><strong>lsp_golden_tests</strong></td><td>45s</td><td>2.1s</td><td><strong>21x faster</strong></td><td>Significant</td></tr>
<tr><td><strong>Overall test suite</strong></td><td>60s+</td><td>&lt;10s</td><td><strong>6x faster</strong></td><td>Production-ready</td></tr>
</tbody></table>
</div>
<h4 id="enhanced-thread-configuration-reference-diataxis-reference---multi-tier-timeout-scaling"><a class="header" href="#enhanced-thread-configuration-reference-diataxis-reference---multi-tier-timeout-scaling">Enhanced Thread Configuration Reference (<em>Diataxis: Reference</em> - Multi-tier timeout scaling)</a></h4>
<div class="table-wrapper"><table><thead><tr><th>Environment</th><th>Thread Count</th><th>LSP Harness</th><th>Comprehensive</th><th>Idle Detection</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>CI/GitHub Actions</strong></td><td>0-2</td><td>500ms</td><td>15s</td><td>200ms cycles</td><td>Resource-constrained automation</td></tr>
<tr><td><strong>Constrained Dev</strong></td><td>3-4</td><td>300ms</td><td>10s</td><td>200ms cycles</td><td>Limited hardware development</td></tr>
<tr><td><strong>Light Constraint</strong></td><td>5-8</td><td>200ms</td><td>7.5s</td><td>200ms cycles</td><td>Modern development machines</td></tr>
<tr><td><strong>Full Workstation</strong></td><td>&gt;8</td><td>200ms</td><td>5s</td><td>200ms cycles</td><td>High-performance development</td></tr>
</tbody></table>
</div>
<h4 id="thread-aware-test-examples-diataxis-tutorial---common-testing-patterns"><a class="header" href="#thread-aware-test-examples-diataxis-tutorial---common-testing-patterns">Thread-Aware Test Examples (<em>Diataxis: Tutorial</em> - Common testing patterns)</a></h4>
<pre><code class="language-bash"># GitHub Actions CI configuration
- name: Run LSP tests
  run: RUST_TEST_THREADS=2 cargo test -p perl-lsp
  timeout-minutes: 10

# Local development on limited hardware
RUST_TEST_THREADS=4 cargo test -p perl-parser --test lsp_comprehensive_e2e_test

# High-performance workstation (default behavior)
cargo test  # Uses all available threads, standard 5-second timeouts

# Debug timeout issues
RUST_LOG=debug LSP_TEST_ECHO_STDERR=1 RUST_TEST_THREADS=1 cargo test -p perl-lsp --test specific_test
</code></pre>
<h2 id="parser-commands"><a class="header" href="#parser-commands">Parser Commands</a></h2>
<h3 id="native-parser-perl-parser"><a class="header" href="#native-parser-perl-parser">Native Parser (perl-parser)</a></h3>
<pre><code class="language-bash"># Parse a Perl file (create a simple wrapper first)
# The v3 parser is a library - use it programmatically or via examples:

# Test regex patterns including m!pattern!
cargo run -p perl-parser --example test_regex

# Test comprehensive edge cases
cargo run -p perl-parser --example test_edge_cases

# Test all edge cases (shows coverage)
cargo run -p perl-parser --example test_more_edge_cases

# Test LSP capabilities demo
cargo run -p perl-parser --example lsp_capabilities
</code></pre>
<h2 id="lsp-development-commands"><a class="header" href="#lsp-development-commands">LSP Development Commands</a></h2>
<h3 id="core-lsp-testing-diataxis-how-to-guide---development-workflows"><a class="header" href="#core-lsp-testing-diataxis-how-to-guide---development-workflows">Core LSP Testing (<em>Diataxis: How-to Guide</em> - Development workflows)</a></h3>
<pre><code class="language-bash"># Run LSP tests with performance optimizations (v0.8.8+)
cargo test -p perl-parser lsp

# Run LSP integration tests with controlled threading (recommended)
RUST_TEST_THREADS=2 cargo test -p perl-lsp -- --test-threads=2

# Revolutionary performance testing with enhanced test harness (PR #140)
LSP_TEST_FALLBACKS=1 cargo test -p perl-lsp             # Fast mode with mock responses

# Optimal CI performance with adaptive configuration
RUST_TEST_THREADS=2 LSP_TEST_FALLBACKS=1 cargo test -p perl-lsp -- --test-threads=2

# Enhanced test harness features (PR #140)
cargo test -p perl-lsp --test lsp_behavioral_tests       # 5000x performance improvement
cargo test -p perl-lsp --test lsp_full_coverage_user_stories  # 4700x performance improvement

# Run specific performance-sensitive tests with threading control
RUST_TEST_THREADS=2 cargo test -p perl-lsp test_completion_detail_formatting -- --test-threads=2
RUST_TEST_THREADS=2 cargo test -p perl-lsp test_workspace_symbol_search -- --test-threads=2

# Run formatting capability tests (robust across environments)
cargo test -p perl-lsp --test lsp_comprehensive_e2e_test test_e2e_document_formatting
cargo test -p perl-lsp --test lsp_perltidy_test test_formatting_provider_capability

# Test LSP server manually
echo -e 'Content-Length: 58\r\n\r\n{"jsonrpc":"2.0","id":1,"method":"initialize","params":{}}' | perl-lsp --stdio

# Run with incremental parsing enabled (production-ready feature)
PERL_LSP_INCREMENTAL=1 perl-lsp --stdio

# Test incremental parsing with LSP protocol
PERL_LSP_INCREMENTAL=1 perl-lsp --stdio &lt; test_requests.jsonrpc

# Run with a test file
perl-lsp --stdio &lt; test_requests.jsonrpc
</code></pre>
<h3 id="lsp-testing-environment-variables-diataxis-reference---configuration-options"><a class="header" href="#lsp-testing-environment-variables-diataxis-reference---configuration-options">LSP Testing Environment Variables (<em>Diataxis: Reference</em> - Configuration options)</a></h3>
<p><strong>RUST_TEST_THREADS</strong> (<strong>Revolutionary Enhancement in PR #140</strong>):</p>
<pre><code class="language-bash"># Control test thread concurrency for transformative performance
export RUST_TEST_THREADS=2                # Achieves 5000x performance gains in CI

# Revolutionary performance testing with adaptive timeouts
RUST_TEST_THREADS=2 cargo test -p perl-lsp --test lsp_behavioral_tests     # 0.31s (was 1560s+)
RUST_TEST_THREADS=2 cargo test -p perl-lsp --test lsp_full_coverage_user_stories  # 0.32s (was 1500s+)

# Enhanced benefits of PR #140 threading optimization:
# - 5000x faster behavioral test execution
# - 4700x faster user story completion
# - 100% test pass rate (was ~55% due to timeouts)
# - Intelligent symbol waiting with exponential backoff
# - Optimized idle detection (1000ms ‚Üí 200ms cycles)
# - Enhanced test harness with mock responses and graceful degradation

# Revolutionary thread configuration examples:
cargo test -p perl-lsp -- --test-threads=2              # Optimal CI configuration
RUST_TEST_THREADS=1 cargo test -p perl-lsp              # Maximum reliability mode
RUST_TEST_THREADS=4 cargo test -p perl-lsp              # High-performance development
</code></pre>
<p><strong>LSP_TEST_FALLBACKS</strong> (<strong>NEW in v0.8.8</strong>):</p>
<pre><code class="language-bash"># Enable fast testing mode (reduces test timeouts by ~75%)
export LSP_TEST_FALLBACKS=1

# Optional external dependencies for enhanced features
export PERLTIDY_PATH="/usr/local/bin/perltidy"    # Custom perltidy location
export PERLCRITIC_PATH="/usr/local/bin/perlcritic" # Custom perlcritic location

# Performance characteristics in fallback mode:
# - Base timeout: 500ms (vs 2000ms)
# - Wait for idle: 50ms (vs 2000ms)  
# - Symbol polling: single 200ms attempt (vs progressive backoff)
# - Result: 99.5% faster test execution (60s+ ‚Üí 0.26s for workspace tests)

# Use cases:
cargo test -p perl-lsp                    # Fast CI/development testing
LSP_TEST_FALLBACKS=1 cargo test --workspace  # Quick workspace validation
LSP_TEST_FALLBACKS=1 cargo check --workspace # Fast build verification
</code></pre>
<p><strong>PERL_LSP_INCREMENTAL</strong>:</p>
<pre><code class="language-bash"># Enable incremental parsing (production-ready)
export PERL_LSP_INCREMENTAL=1
perl-lsp --stdio

# Performance benefits:
# - &lt;1ms LSP updates with 70-99% node reuse efficiency
# - Production-stable incremental parsing
# - Enterprise-grade workspace refactoring support
</code></pre>
<h3 id="lsp-executecommand-integration--new-issue-145-diataxis-how-to-guide---execute-command-usage"><a class="header" href="#lsp-executecommand-integration--new-issue-145-diataxis-how-to-guide---execute-command-usage">LSP executeCommand Integration ‚≠ê <strong>NEW: Issue #145</strong> (<em>Diataxis: How-to Guide</em> - Execute command usage)</a></h3>
<p>The LSP server now supports comprehensive <code>workspace/executeCommand</code> functionality with integrated perlcritic analysis and advanced code actions.</p>
<h4 id="perlruncritic-command-usage--new-issue-145"><a class="header" href="#perlruncritic-command-usage--new-issue-145">perl.runCritic Command Usage ‚≠ê <strong>NEW: Issue #145</strong></a></h4>
<p><strong>Dual Analyzer Strategy Overview</strong> (<em>Diataxis: Explanation</em> - Architecture design):</p>
<p>The <code>perl.runCritic</code> command implements a sophisticated dual analyzer strategy ensuring 100% availability:</p>
<ol>
<li><strong>Primary</strong>: External perlcritic (full policy coverage, configurable)</li>
<li><strong>Fallback</strong>: Built-in analyzer (always available, comprehensive basic policies)</li>
<li><strong>Seamless Transition</strong>: Automatic fallback with no user intervention required</li>
<li><strong>Performance Target</strong>: &lt;2s execution time for typical Perl files</li>
</ol>
<p><strong>Basic Usage</strong> (<em>Diataxis: Tutorial</em> - Getting started with code quality analysis):</p>
<pre><code class="language-bash"># Test perl.runCritic command integration
cargo test -p perl-lsp --test lsp_behavioral_tests -- test_execute_command_perlcritic

# Test executeCommand protocol compliance
cargo test -p perl-lsp --test lsp_execute_command_tests

# Test with dual analyzer strategy (external + built-in fallback)
cargo test -p perl-lsp --test lsp_execute_command_tests -- test_perlcritic_dual_analyzer

# Test built-in analyzer specifically
cargo test -p perl-parser --test execute_command_tests -- test_execute_command_run_critic_builtin

# Test with missing files (error handling)
cargo test -p perl-parser --test execute_command_tests -- test_execute_command_run_critic_missing_file
</code></pre>
<p><strong>Advanced Configuration</strong> (<em>Diataxis: How-to Guide</em> - Optimizing perlcritic integration):</p>
<p><strong>External Perlcritic Setup</strong>:</p>
<pre><code class="language-bash"># Install perlcritic for enhanced analysis
sudo apt-get install perlcritic         # Ubuntu/Debian
brew install perl-critic                # macOS
cpan Perl::Critic                      # CPAN installation

# Verify perlcritic availability
which perlcritic                        # Should return path if installed
perlcritic --version                    # Check version

# Test external analyzer detection
cargo test -p perl-parser --test execute_command_tests -- test_command_exists_behavior
</code></pre>
<p><strong>Built-in Analyzer Capabilities</strong> (<em>Diataxis: Reference</em> - Policy coverage):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Built-in analyzer policies (always available)
- RequireUseStrict: "Missing 'use strict' pragma"
- RequireUseWarnings: "Missing 'use warnings' pragma"
- Syntax::ParseError: "Comprehensive syntax error detection"
- Performance optimized: ~100¬µs analysis time for typical files
- Parse-error resilient: Continues analysis even with syntax errors
<span class="boring">}</span></code></pre></pre>
<p><strong>Performance Specifications</strong> (<em>Diataxis: Reference</em> - Timing requirements):</p>
<div class="table-wrapper"><table><thead><tr><th>Analyzer Type</th><th>File Size</th><th>Analysis Time</th><th>Policy Coverage</th><th>Availability</th></tr></thead><tbody>
<tr><td>External perlcritic</td><td>&lt;10KB</td><td>&lt;0.5s</td><td>150+ policies</td><td>Requires installation</td></tr>
<tr><td>External perlcritic</td><td>&lt;100KB</td><td>&lt;1.5s</td><td>150+ policies</td><td>Configurable severity</td></tr>
<tr><td>Built-in analyzer</td><td>&lt;10KB</td><td>&lt;0.1s</td><td>Core policies</td><td>100% availability</td></tr>
<tr><td>Built-in analyzer</td><td>&lt;100KB</td><td>&lt;0.3s</td><td>Core policies</td><td>Parse-error resilient</td></tr>
</tbody></table>
</div>
<p><strong>Troubleshooting</strong> (<em>Diataxis: How-to Guide</em> - Common issues and solutions):</p>
<p><strong>Issue: External perlcritic not found</strong></p>
<pre><code class="language-bash"># Problem: LSP falls back to built-in analyzer always
# Solution: Install perlcritic and verify PATH
which perlcritic || echo "perlcritic not found in PATH"
echo $PATH | grep -o '/usr/local/bin\|/usr/bin\|/opt/perl/bin'

# Alternative: Use built-in analyzer explicitly (always works)
cargo test -p perl-parser --test execute_command_tests -- test_execute_command_run_critic_builtin
</code></pre>
<p><strong>Issue: Analysis timeout or slow performance</strong></p>
<pre><code class="language-bash"># Problem: Large files cause timeout
# Solution: Verify file size and complexity
wc -l your_file.pl                     # Check line count
time perlcritic your_file.pl           # Test external tool directly

# Built-in analyzer performance validation
cargo test -p perl-parser --test execute_command_tests -- test_run_builtin_critic_with_valid_file
</code></pre>
<p><strong>Issue: Parse errors prevent analysis</strong></p>
<pre><code class="language-bash"># Problem: Syntax errors stop analysis
# Solution: Built-in analyzer handles parse errors gracefully
perl -c your_file.pl                   # Check syntax separately
cargo test -p perl-parser --test execute_command_tests # Built-in handles syntax errors
</code></pre>
<p><strong>Integration with LSP Diagnostics</strong> (<em>Diataxis: How-to Guide</em> - Diagnostic workflow):</p>
<pre><code class="language-bash"># Test diagnostic integration with executeCommand
cargo test -p perl-lsp --test lsp_behavioral_tests -- test_execute_command_perlcritic

# Verify diagnostic publication after executeCommand
cargo test -p perl-lsp --test lsp_comprehensive_e2e_test -- test_execute_command_and_code_actions

# Performance validation: &lt;50ms code actions, &lt;2s executeCommand
cargo test -p perl-lsp --test lsp_performance_tests -- test_execute_command_latency
</code></pre>
<p><strong>LSP Protocol Integration</strong> (<em>Diataxis: Reference</em> - executeCommand specifications):</p>
<pre><code class="language-json">// Client request format for perl.runCritic
{
  "jsonrpc": "2.0",
  "id": 1,
  "method": "workspace/executeCommand",
  "params": {
    "command": "perl.runCritic",
    "arguments": ["/path/to/file.pl"]
  }
}

// Server response format
{
  "jsonrpc": "2.0",
  "id": 1,
  "result": {
    "success": true,
    "violations": [
      {
        "policy": "Subroutines::RequireFinalReturn",
        "severity": "medium",
        "message": "Subroutine does not end with explicit return",
        "line": 15,
        "column": 1
      }
    ],
    "analyzer_used": "external",
    "execution_time": "0.125s",
    "file_path": "/path/to/file.pl"
  }
}
</code></pre>
<h4 id="supported-executecommand-operations-diataxis-reference---complete-command-list"><a class="header" href="#supported-executecommand-operations-diataxis-reference---complete-command-list">Supported executeCommand Operations (<em>Diataxis: Reference</em> - Complete command list)</a></h4>
<p><strong>Core Commands</strong> (Available since v0.8.8+):</p>
<pre><code class="language-bash"># Test all supported executeCommand operations
cargo test -p perl-lsp --test lsp_execute_command_tests -- test_supported_commands

# Individual command testing
cargo test -p perl-lsp --test lsp_behavioral_tests -- test_execute_command_run_tests     # perl.runTests
cargo test -p perl-lsp --test lsp_behavioral_tests -- test_execute_command_run_file     # perl.runFile
cargo test -p perl-lsp --test lsp_behavioral_tests -- test_execute_command_debug_tests  # perl.debugTests
</code></pre>
<p><strong>Command Capabilities</strong>:</p>
<ul>
<li>‚úÖ <code>perl.runTests</code> - Execute Perl test files with TAP output parsing</li>
<li>‚úÖ <code>perl.runFile</code> - Execute single Perl file with output capture</li>
<li>‚úÖ <code>perl.runTestSub</code> - Execute specific test subroutine with isolation</li>
<li>‚úÖ <code>perl.debugTests</code> - Debug test execution with breakpoint support</li>
<li>‚úÖ <code>perl.runCritic</code> - <strong>NEW</strong>: Perl::Critic analysis with dual analyzer strategy</li>
</ul>
<h3 id="advanced-code-actions-testing--new-issue-145-diataxis-how-to-guide---code-action-workflows"><a class="header" href="#advanced-code-actions-testing--new-issue-145-diataxis-how-to-guide---code-action-workflows">Advanced Code Actions Testing ‚≠ê <strong>NEW: Issue #145</strong> (<em>Diataxis: How-to Guide</em> - Code action workflows)</a></h3>
<p><strong>Refactoring Operations</strong> (<em>Diataxis: Tutorial</em> - Using code actions for refactoring):</p>
<pre><code class="language-bash"># Test comprehensive code action integration
cargo test -p perl-lsp --test lsp_code_actions_tests

# Test specific refactoring categories
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_extract_variable_action     # RefactorExtract
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_extract_subroutine_action  # Advanced extraction
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_organize_imports_action    # SourceOrganizeImports

# Test code quality improvements
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_modernize_code_actions     # RefactorRewrite
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_add_missing_pragmas_action # Code modernization
</code></pre>
<p><strong>Performance Testing</strong> (<em>Diataxis: How-to Guide</em> - Code action performance validation):</p>
<pre><code class="language-bash"># Validate &lt;50ms response time requirement
cargo test -p perl-lsp --test lsp_performance_tests -- test_code_actions_response_time

# Test caching efficiency with incremental updates
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_code_action_caching

# Cross-file refactoring with dual indexing integration
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_cross_file_extract_subroutine
</code></pre>
<p><strong>LSP Protocol Compliance</strong> (<em>Diataxis: Reference</em> - Code action specifications):</p>
<pre><code class="language-json">// Client request for code actions
{
  "jsonrpc": "2.0",
  "id": 2,
  "method": "textDocument/codeAction",
  "params": {
    "textDocument": {"uri": "file:///path/to/file.pl"},
    "range": {"start": {"line": 10, "character": 4}, "end": {"line": 12, "character": 8}},
    "context": {
      "diagnostics": [],
      "only": ["refactor.extract", "source.organizeImports"]
    }
  }
}

// Server response with available code actions
{
  "jsonrpc": "2.0",
  "id": 2,
  "result": [
    {
      "title": "Extract variable 'user_input'",
      "kind": "refactor.extract",
      "edit": { /* WorkspaceEdit with text changes */ },
      "isPreferred": true
    },
    {
      "title": "Organize Imports",
      "kind": "source.organizeImports",
      "edit": { /* Import optimization changes */ }
    }
  ]
}
</code></pre>
<h4 id="integration-testing-diataxis-how-to-guide---end-to-end-validation"><a class="header" href="#integration-testing-diataxis-how-to-guide---end-to-end-validation">Integration Testing (<em>Diataxis: How-to Guide</em> - End-to-end validation)</a></h4>
<p><strong>Complete Workflow Testing</strong>:</p>
<pre><code class="language-bash"># Test executeCommand and code actions together
cargo test -p perl-lsp --test lsp_comprehensive_e2e_test -- test_execute_command_and_code_actions

# Validate with adaptive threading (recommended)
RUST_TEST_THREADS=2 cargo test -p perl-lsp --test lsp_execute_command_tests -- --test-threads=2
RUST_TEST_THREADS=2 cargo test -p perl-lsp --test lsp_code_actions_tests -- --test-threads=2

# Performance regression prevention
cargo test -p perl-lsp --test lsp_performance_benchmarks -- test_execute_command_latency
cargo test -p perl-lsp --test lsp_performance_benchmarks -- test_code_actions_throughput
</code></pre>
<p><strong>Quality Assurance Commands</strong>:</p>
<pre><code class="language-bash"># Acceptance criteria validation (Issue #145)
cargo test -p perl-lsp --test lsp_execute_command_tests -- test_ac1_execute_command_implementation  # AC1
cargo test -p perl-lsp --test lsp_execute_command_tests -- test_ac2_perlcritic_integration          # AC2
cargo test -p perl-lsp --test lsp_code_actions_tests -- test_ac3_advanced_refactoring_operations   # AC3

# Previously ignored tests now enabled
cargo test -p perl-lsp --test lsp_behavioral_tests | grep -v "ignored"  # Verify test enablement
</code></pre>
<p>The enhanced executeCommand and code actions integration delivers enterprise-grade LSP functionality with &lt;50ms response times, comprehensive error handling, and production-ready tool integration patterns.</p>
<h2 id="benchmark-commands"><a class="header" href="#benchmark-commands">Benchmark Commands</a></h2>
<h3 id="workspace-benchmarks-v088"><a class="header" href="#workspace-benchmarks-v088">Workspace Benchmarks (v0.8.8)</a></h3>
<pre><code class="language-bash"># Run parser benchmarks (workspace crates)
cargo bench                             # Benchmarks for published crates
cargo bench -p perl-parser              # Main parser benchmarks (v3)

# Individual crate benchmarks
cargo bench -p perl-lexer               # Lexer performance tests
cargo bench -p perl-corpus              # Corpus validation performance

# Performance validation
cargo test -p perl-parser --test incremental_perf_test  # Incremental parsing performance
</code></pre>
<h3 id="comprehensive-c-vs-rust-benchmark-framework-v088"><a class="header" href="#comprehensive-c-vs-rust-benchmark-framework-v088">Comprehensive C vs Rust Benchmark Framework (v0.8.8)</a></h3>
<pre><code class="language-bash"># Run complete cross-language benchmark suite with statistical analysis
cargo xtask bench                       # Complete benchmark workflow with C vs Rust comparison

# Individual benchmark components
cargo run -p tree-sitter-perl-rs --bin benchmark_parsers --features pure-rust  # Rust parser benchmarks
cd tree-sitter-perl &amp;&amp; node test/benchmark.js  # C implementation benchmarks

# Generate statistical comparison report with configurable thresholds
python3 scripts/generate_comparison.py \
  --c-results c_benchmark.json \
  --rust-results rust_benchmark.json \
  --output comparison.json \
  --report comparison_report.md

# Custom performance gates (5% parse time, 20% memory defaults)
python3 scripts/generate_comparison.py \
  --parse-threshold 3.0 \
  --memory-threshold 15.0 \
  --verbose

# Setup benchmark environment with all dependencies
bash scripts/setup_benchmark.sh

# Run benchmark validation tests (12 comprehensive test cases)
python3 -m pytest scripts/test_comparison.py -v

# Compare all three parsers with memory tracking
cargo xtask compare --report             # Full comparison with memory metrics and statistical analysis
cargo xtask compare --c-only             # Test C implementation only with memory tracking
cargo xtask compare --rust-only          # Test Rust implementation only with memory tracking
cargo xtask compare --validate-only      # Validate existing results without re-running
cargo xtask compare --check-gates        # Check performance gates with memory thresholds

# Memory profiling validation
cargo run --bin xtask -- validate-memory-profiling  # Test dual-mode memory measurement
</code></pre>
<h2 id="code-quality-commands"><a class="header" href="#code-quality-commands">Code Quality Commands</a></h2>
<h3 id="workspace-quality-checks-v088"><a class="header" href="#workspace-quality-checks-v088">Workspace Quality Checks (v0.8.8)</a></h3>
<pre><code class="language-bash"># Run standard Rust quality checks (workspace crates)
cargo fmt                              # Format workspace code
cargo clippy --workspace              # Lint workspace crates  
cargo clippy --workspace --tests      # Lint tests

# Individual crate checks
cargo clippy -p perl-parser           # Lint main parser crate
cargo clippy -p perl-lsp              # Lint LSP server
cargo test --doc                      # Documentation tests

# Legacy quality commands (excluded from workspace)
# cargo xtask check --all             # xtask excluded from workspace
# cargo xtask fmt                     # xtask excluded from workspace
</code></pre>
<h2 id="dual-scanner-corpus-comparison-diataxis-how-to-guide---testing-procedures"><a class="header" href="#dual-scanner-corpus-comparison-diataxis-how-to-guide---testing-procedures">Dual-Scanner Corpus Comparison (<em>Diataxis: How-to Guide</em> - Testing procedures)</a></h2>
<h3 id="running-dual-scanner-corpus-tests-v088"><a class="header" href="#running-dual-scanner-corpus-tests-v088">Running Dual-Scanner Corpus Tests (v0.8.8+)</a></h3>
<pre><code class="language-bash"># Prerequisites: Install libclang-dev for C scanner support
sudo apt-get install libclang-dev  # Ubuntu/Debian
brew install llvm                  # macOS

# Run corpus comparison modes (requires legacy feature)
cargo run -p xtask --features legacy -- corpus                          # Corpus vs selected parser (default scanner: v3)
cargo run -p xtask --features legacy -- corpus --scanner both           # C vs v3 comparison mode
cargo run -p xtask --features legacy -- corpus --scanner both --diagnose

# Individual scanner testing
cargo run -p xtask --features legacy -- corpus --scanner c                    # C scanner
cargo run -p xtask --features legacy -- corpus --scanner rust                 # In-crate v2 pest parser
cargo run -p xtask --features legacy -- corpus --scanner v2-pest-microcrate   # Extracted perl-parser-pest v2
cargo run -p xtask --features legacy -- corpus --scanner v2-parity --diagnose # v2&lt;-&gt;v2 drift detector
cargo run -p xtask --features legacy -- corpus --scanner v3                   # V3 parser only

# Diagnostic analysis (*Diataxis: Reference* - detailed comparison)
cargo run -p xtask --features legacy -- corpus --diagnose  # Analyze first failing test
cargo run -p xtask --features legacy -- corpus --test      # Test current parser behavior

# Custom corpus path
cargo run -p xtask --features legacy -- corpus --path tree-sitter-perl/test/corpus
</code></pre>
<h3 id="dual-scanner-output-analysis-diataxis-explanation---understanding-results"><a class="header" href="#dual-scanner-output-analysis-diataxis-explanation---understanding-results">Dual-Scanner Output Analysis (<em>Diataxis: Explanation</em> - Understanding results)</a></h3>
<pre><code class="language-bash"># Scanner mismatch tracking
# When using --scanner both, the system tracks:
# - Total corpus tests run
# - Tests passing both scanners  
# - Tests failing in either scanner
# - Scanner output mismatches (different S-expressions)

# Example output interpretation:
# üìä Corpus Test Summary:
#    Total: 157
#    Passed: 142 ‚úÖ
#    Failed: 15 ‚ùå
#    Scanner mismatches: 23  # C vs Rust differences

# üîÄ Scanner mismatches:
#    corpus_file.txt: test_case_name  # Specific mismatch location
</code></pre>
<h3 id="structural-analysis-features-diataxis-reference---analysis-capabilities"><a class="header" href="#structural-analysis-features-diataxis-reference---analysis-capabilities">Structural Analysis Features (<em>Diataxis: Reference</em> - Analysis capabilities)</a></h3>
<pre><code class="language-bash"># The dual-scanner system provides:
# - Node count comparison between C and Rust scanners
# - Missing node detection (in C but not Rust output)
# - Extra node detection (in Rust but not C output)  
# - Normalized S-expression comparison (whitespace-independent)
# - Detailed structural diff output for debugging

# Example diagnostic output:
# üîç STRUCTURAL ANALYSIS:
# C scanner nodes: 42
# V3 scanner nodes: 41
# ‚ùå Nodes missing in V3 output:
#   - specific_node_type
# ‚ûï Extra nodes in V3 output:  
#   - different_node_type
</code></pre>
<h3 id="xtask-corpus-command-reference-diataxis-reference---complete-command-specification"><a class="header" href="#xtask-corpus-command-reference-diataxis-reference---complete-command-specification">xtask corpus Command Reference (<em>Diataxis: Reference</em> - Complete command specification)</a></h3>
<pre><code class="language-bash"># Basic corpus command structure
cargo run -p xtask --features legacy -- corpus [OPTIONS]

# Command line options:
--path &lt;PATH&gt;              # Corpus directory path (default: tree-sitter-perl/test/corpus)
--scanner &lt;SCANNER&gt;        # Scanner type: c, rust, v2-pest-microcrate, v2-parity, v3, both
--diagnose                 # Run diagnostic analysis on first failing test
--test                     # Test current parser behavior with simple expressions

# Scanner type options:
c       # Use C tree-sitter scanner only (baseline for comparison)
rust    # Use in-crate v2 pest parser (tree_sitter_perl::PureRustPerlParser)
v2-pest-microcrate  # Use extracted perl-parser-pest v2 parser
v2-parity  # Compare in-crate v2 vs extracted v2 output only (ignores corpus expected)
v3      # Use V3 native parser only (perl_parser::Parser)
both    # Compare C scanner vs V3 parser output before corpus expectation check

# Prerequisites for dual-scanner mode:
# Ubuntu/Debian: sudo apt-get install libclang-dev
# macOS: brew install llvm
# Fedora: sudo dnf install clang-devel

# Exit codes:
# 0  - All tests passed, no scanner mismatches
# 1  - Test failures or scanner mismatches detected

# Output format:
# üìä Corpus Test Summary:
#    Total: &lt;number&gt;         # Total corpus tests processed
#    Passed: &lt;number&gt; ‚úÖ     # Tests passing in all scanners
#    Failed: &lt;number&gt; ‚ùå     # Tests failing in any scanner
#    Scanner mismatches: &lt;number&gt;  # Different outputs between scanners
#
# ‚ùå Failed Tests:           # List of failing tests
#    filename: test_name
#
# üîÄ Scanner mismatches:     # List of scanner differences
#    filename: test_name
</code></pre>
<h3 id="corpus-test-file-structure-diataxis-reference---test-format-specification"><a class="header" href="#corpus-test-file-structure-diataxis-reference---test-format-specification">Corpus Test File Structure (<em>Diataxis: Reference</em> - Test format specification)</a></h3>
<pre><code>Test Case Name
================================================================================
source code here
----
(expected s_expression output here)

Next Test Case Name
================================================================================
more source code
----
(expected_output)
</code></pre>
<h2 id="highlight-testing-commands-diataxis-reference---tree-sitter-highlight-test-runner"><a class="header" href="#highlight-testing-commands-diataxis-reference---tree-sitter-highlight-test-runner">Highlight Testing Commands (<em>Diataxis: Reference</em> - Tree-Sitter Highlight Test Runner)</a></h2>
<h3 id="basic-highlight-testing-diataxis-tutorial---getting-started-with-highlight-tests"><a class="header" href="#basic-highlight-testing-diataxis-tutorial---getting-started-with-highlight-tests">Basic Highlight Testing (<em>Diataxis: Tutorial</em> - Getting started with highlight tests)</a></h3>
<pre><code class="language-bash"># Prerequisites: Navigate to xtask directory for highlight testing
cd xtask

# Run all highlight tests with perl-parser AST integration
cargo run --no-default-features -- highlight

# Test specific highlight directory
cargo run --no-default-features -- highlight --path ../crates/tree-sitter-perl/test/highlight

# Test with specific scanner (for compatibility testing)
cargo run --no-default-features -- highlight --scanner v3
</code></pre>
<h3 id="highlight-integration-testing-diataxis-how-to-guide---running-comprehensive-tests"><a class="header" href="#highlight-integration-testing-diataxis-how-to-guide---running-comprehensive-tests">Highlight Integration Testing (<em>Diataxis: How-to Guide</em> - Running comprehensive tests)</a></h3>
<pre><code class="language-bash"># Run perl-corpus highlight integration tests (4 comprehensive tests)
cargo test -p perl-corpus --test highlight_integration_test

# Individual integration test scenarios
cargo test -p perl-corpus highlight_integration_test::test_highlight_runner_integration     # Basic AST integration
cargo test -p perl-corpus highlight_integration_test::test_complex_highlight_constructs    # Complex Perl constructs  
cargo test -p perl-corpus highlight_integration_test::test_highlight_error_handling        # Edge case handling
cargo test -p perl-corpus highlight_integration_test::test_highlight_performance           # Performance validation

# Performance characteristics validation (&lt;100ms for complex code)
cargo test -p perl-corpus highlight_integration_test::test_highlight_performance -- --nocapture
</code></pre>
<h3 id="creating-highlight-test-fixtures-diataxis-how-to-guide---adding-new-test-cases"><a class="header" href="#creating-highlight-test-fixtures-diataxis-how-to-guide---adding-new-test-cases">Creating Highlight Test Fixtures (<em>Diataxis: How-to Guide</em> - Adding new test cases)</a></h3>
<pre><code class="language-bash"># Navigate to highlight test fixture directory
cd crates/tree-sitter-perl/test/highlight

# Create new highlight test file (follow existing naming conventions)
touch new_feature.pm

# Highlight test file format:
# Working highlight test examples
# 
# Simple variable assignment
# my $name = "John";
# # &lt;- keyword  
# #    ^ punctuation.special
# #     ^ variable
# #            ^ string
# 
# Number operations  
# 42;
# # &lt;- number
# 
# Use statement
# use strict;
# # &lt;- keyword
# #   ^ type

# Supported highlight scopes mapped to perl-parser AST nodes:
# - keyword        ‚Üí VariableDeclaration
# - punctuation.special ‚Üí Variable (sigil mapping)
# - variable       ‚Üí Variable
# - string         ‚Üí string
# - number         ‚Üí number
# - operator       ‚Üí binary_+ (binary operations)
# - function       ‚Üí SubDeclaration
# - type           ‚Üí UseStatement
# - label          ‚Üí HereDocEnd

# Test your new fixture
cd ../../../../xtask
cargo run --no-default-features -- highlight --path ../crates/tree-sitter-perl/test/highlight
</code></pre>
<h3 id="highlight-test-runner-reference-diataxis-reference---complete-command-specification"><a class="header" href="#highlight-test-runner-reference-diataxis-reference---complete-command-specification">Highlight Test Runner Reference (<em>Diataxis: Reference</em> - Complete command specification)</a></h3>
<pre><code class="language-bash"># Command structure
cd xtask &amp;&amp; cargo run --no-default-features -- highlight [OPTIONS]

# Command line options:
--path &lt;PATH&gt;         # Path to highlight test directory [default: c/test/highlight]
--scanner &lt;SCANNER&gt;   # Run with specific scanner [possible values: c, rust, both, v3]

# Default behavior:
# - Uses v3 parser (perl-parser native recursive descent)
# - Processes all .pm files in highlight directory
# - Maps highlight scopes to AST node kinds
# - Reports test results with pass/fail statistics

# Test fixture format requirements:
# - Files must have .pm extension
# - Comments starting with # define expected highlight scopes
# - Source code lines contain the Perl code to be highlighted
# - Empty lines separate test cases within a file
# - Position markers: ^ or &lt;- indicate highlight scope location

# Performance characteristics:
# - ~540ms for 21 test cases (reasonable performance)
# - Integration with comprehensive perl-parser AST traversal
# - Secure path handling with WalkDir max_depth protection
</code></pre>
<h3 id="highlight-test-architecture-diataxis-explanation---system-design-and-integration"><a class="header" href="#highlight-test-architecture-diataxis-explanation---system-design-and-integration">Highlight Test Architecture (<em>Diataxis: Explanation</em> - System design and integration)</a></h3>
<p>The highlight test runner integrates deeply with the perl-parser AST generation system:</p>
<p><strong>Parser Integration</strong>:</p>
<ul>
<li>Uses <code>perl_parser::Parser</code> for native recursive descent parsing</li>
<li>Leverages comprehensive AST node kind collection via <code>collect_node_kinds()</code></li>
<li>Maps tree-sitter highlight scopes to perl-parser NodeKind variants</li>
</ul>
<p><strong>AST Node Mapping Strategy</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Highlight scope ‚Üí AST NodeKind mapping
"keyword"           ‚Üí NodeKind::VariableDeclaration
"punctuation.special" ‚Üí NodeKind::Variable (Perl sigils)
"variable"          ‚Üí NodeKind::Variable
"string"            ‚Üí NodeKind::String
"number"            ‚Üí NodeKind::Number  
"operator"          ‚Üí NodeKind::Binary with specific operators (+, -, *, etc.)
"function"          ‚Üí NodeKind::Subroutine
"type"              ‚Üí NodeKind::Use
<span class="boring">}</span></code></pre></pre>
<p><strong>Integration with perl-corpus Testing</strong>:</p>
<ul>
<li>Comprehensive integration tests validate highlight runner functionality</li>
<li>4/4 integration tests passing with performance validation (&lt;100ms)</li>
<li>Tests cover basic constructs, complex scenarios, error handling, and performance</li>
</ul>
<p><strong>Security and Path Handling</strong>:</p>
<ul>
<li>Uses <code>WalkDir</code> with <code>max_depth(1)</code> for secure directory traversal</li>
<li>Validates file extensions (<code>.pm</code> only)</li>
<li>Proper error handling for parse failures and missing files</li>
</ul>
<p><strong>Performance Optimizations</strong>:</p>
<ul>
<li>Efficient AST traversal using manual recursion over NodeKind variants</li>
<li>HashMap-based node counting for fast scope matching</li>
<li>Progress indication with <code>indicatif</code> for user feedback</li>
</ul>
<h3 id="advanced-diagnostic-features-diataxis-reference---analysis-capabilities"><a class="header" href="#advanced-diagnostic-features-diataxis-reference---analysis-capabilities">Advanced Diagnostic Features (<em>Diataxis: Reference</em> - Analysis capabilities)</a></h3>
<pre><code class="language-bash"># Structural analysis when using --diagnose:
üîç DIAGNOSTIC: test_name
Input Perl code:
```perl
source code being tested
</code></pre>
<p>üìä C scanner S-expression:
(program (expression_statement (number ‚Äú1‚Äù)))</p>
<p>üìä V3 scanner S-expression:<br />
(program (expression_statement (literal ‚Äú1‚Äù)))</p>
<p>üîç STRUCTURAL ANALYSIS:
C scanner nodes: 15
V3 scanner nodes: 14
‚ùå Nodes missing in V3 output:</p>
<ul>
<li>number
‚ûï Extra nodes in V3 output:</li>
<li>literal</li>
</ul>
<pre><code>
## Scanner Architecture Testing (*Diataxis: How-to Guide* - Unified scanner validation)

The project uses a unified scanner architecture where both `c-scanner` and `rust-scanner` features use the same Rust implementation, with `CScanner` serving as a compatibility wrapper that delegates to `RustScanner`.

### Scanner Implementation Testing (*Diataxis: Reference* - Scanner validation commands)

```bash
# Test core Rust scanner implementation directly
cargo test -p tree-sitter-perl-rs --features rust-scanner

# Test C scanner wrapper (delegates to Rust implementation internally)
cargo test -p tree-sitter-perl-rs --features c-scanner

# Validate scanner delegation functionality
cargo test -p tree-sitter-perl-rs rust_scanner_smoke

# Test scanner state management and serialization
cargo test -p tree-sitter-perl-rs scanner_state
</code></pre>
<h3 id="scanner-compatibility-validation-diataxis-how-to-guide---ensuring-backward-compatibility"><a class="header" href="#scanner-compatibility-validation-diataxis-how-to-guide---ensuring-backward-compatibility">Scanner Compatibility Validation (<em>Diataxis: How-to Guide</em> - Ensuring backward compatibility)</a></h3>
<pre><code class="language-bash"># Verify both scanner interfaces work correctly
cargo test -p tree-sitter-perl-rs --features rust-scanner,c-scanner

# Test C scanner API compatibility (should delegate to Rust without changes)
cargo test -p tree-sitter-perl-rs c_scanner::tests::test_c_scanner_delegates

# Performance testing (both scanners use same Rust implementation)
cargo bench -p tree-sitter-perl-rs --features rust-scanner
cargo bench -p tree-sitter-perl-rs --features c-scanner
</code></pre>
<h3 id="scanner-build-configuration-diataxis-reference---feature-flag-usage"><a class="header" href="#scanner-build-configuration-diataxis-reference---feature-flag-usage">Scanner Build Configuration (<em>Diataxis: Reference</em> - Feature flag usage)</a></h3>
<pre><code class="language-bash"># Build with Rust scanner only (direct usage)
cargo build -p tree-sitter-perl-rs --features rust-scanner

# Build with C scanner wrapper (delegates to Rust internally)
cargo build -p tree-sitter-perl-rs --features c-scanner

# Build with both scanner interfaces available
cargo build -p tree-sitter-perl-rs --features rust-scanner,c-scanner
</code></pre>
<h3 id="understanding-scanner-architecture-diataxis-explanation---design-rationale"><a class="header" href="#understanding-scanner-architecture-diataxis-explanation---design-rationale">Understanding Scanner Architecture (<em>Diataxis: Explanation</em> - Design rationale)</a></h3>
<p>The unified scanner architecture provides:</p>
<ul>
<li><strong>Single Implementation</strong>: Both <code>c-scanner</code> and <code>rust-scanner</code> features use the same Rust code</li>
<li><strong>Backward Compatibility</strong>: <code>CScanner</code> API unchanged, existing benchmark code works without modification</li>
<li><strong>Simplified Maintenance</strong>: One scanner implementation instead of separate C and Rust versions</li>
<li><strong>Consistent Performance</strong>: All interfaces benefit from Rust implementation performance</li>
</ul>
<h2 id="edge-case-testing-commands"><a class="header" href="#edge-case-testing-commands">Edge Case Testing Commands</a></h2>
<h3 id="workspace-edge-case-tests-v088"><a class="header" href="#workspace-edge-case-tests-v088">Workspace Edge Case Tests (v0.8.8)</a></h3>
<pre><code class="language-bash"># Run comprehensive edge case tests (workspace crates)
cargo test -p perl-parser               # Includes all edge case coverage
cargo test -p perl-corpus               # Corpus-based edge case validation

# Specific edge case test suites
cargo test -p perl-parser --test scope_analyzer_tests        # Scope analysis edge cases
cargo test -p perl-parser edge_case                          # Edge case pattern tests
cargo test -p perl-parser regex                              # Regex delimiter tests
cargo test -p perl-parser heredoc                            # Heredoc edge cases
</code></pre>
<h2 id="scope-analyzer-testing"><a class="header" href="#scope-analyzer-testing">Scope Analyzer Testing</a></h2>
<pre><code class="language-bash"># Run all scope analyzer tests (38 comprehensive tests)
cargo test -p perl-parser --test scope_analyzer_tests

# Test enhanced variable resolution patterns
cargo test -p perl-parser scope_analyzer_tests::test_hash_access_variable_resolution
cargo test -p perl-parser scope_analyzer_tests::test_array_access_variable_resolution
cargo test -p perl-parser scope_analyzer_tests::test_complex_variable_patterns

# Test hash key context detection
cargo test -p perl-parser scope_analyzer_tests::test_hash_key_context_detection
</code></pre>
<h2 id="lsp-development-commands-1"><a class="header" href="#lsp-development-commands-1">LSP Development Commands</a></h2>
<h3 id="testing-comment-documentation"><a class="header" href="#testing-comment-documentation">Testing Comment Documentation</a></h3>
<pre><code class="language-bash"># Test comprehensive comment extraction (20 tests covering all scenarios)
cargo test -p perl-parser --test symbol_documentation_tests

# Test specific comment patterns and edge cases
cargo test -p perl-parser symbol_documentation_tests::comment_separated_by_blank_line_is_not_captured
cargo test -p perl-parser symbol_documentation_tests::comment_with_extra_hashes_and_spaces
cargo test -p perl-parser symbol_documentation_tests::multi_package_comment_scenarios
cargo test -p perl-parser symbol_documentation_tests::complex_comment_formatting
cargo test -p perl-parser symbol_documentation_tests::unicode_in_comments
cargo test -p perl-parser symbol_documentation_tests::performance_with_large_comment_blocks

# Performance benchmarking (&lt;100¬µs per iteration target)
cargo test -p perl-parser symbol_documentation_tests::performance_benchmark_comment_extraction -- --nocapture
</code></pre>
<h3 id="testing-position-tracking"><a class="header" href="#testing-position-tracking">Testing Position Tracking</a></h3>
<pre><code class="language-bash"># Run position tracking tests
cargo test -p perl-parser --test parser_context -- test_multiline_positions
cargo test -p perl-parser --test parser_context -- test_utf16_position_mapping
cargo test -p perl-parser --test parser_context -- test_crlf_line_endings

# Test with specific edge cases
cargo test -p perl-parser parser_context_tests::test_multiline_string_token_positions
</code></pre>
<h3 id="testing-file-completion"><a class="header" href="#testing-file-completion">Testing File Completion</a></h3>
<pre><code class="language-bash"># Run file completion specific tests
cargo test -p perl-parser --test file_completion_tests

# Test individual scenarios
cargo test -p perl-parser file_completion_tests::completes_files_in_src_directory
cargo test -p perl-parser file_completion_tests::basic_security_test_rejects_path_traversal

# Test with various file patterns
cargo test -p perl-parser --test lsp_comprehensive_e2e_test -- test_completion
</code></pre>
<h2 id="parser-generation-commands"><a class="header" href="#parser-generation-commands">Parser Generation Commands</a></h2>
<pre><code class="language-bash"># Generate parser from grammar (if needed for testing)
cd tree-sitter-perl
npx tree-sitter generate
</code></pre>
<h2 id="common-development-tasks"><a class="header" href="#common-development-tasks">Common Development Tasks</a></h2>
<h3 id="adding-a-new-perl-feature"><a class="header" href="#adding-a-new-perl-feature">Adding a New Perl Feature</a></h3>
<ol>
<li>Update <code>src/grammar.pest</code> with new syntax rules</li>
<li>Add corresponding AST nodes in <code>pure_rust_parser.rs</code></li>
<li>Update <code>build_node()</code> method to handle new constructs</li>
<li>Add tests in <code>tests/</code> directory</li>
<li>Run tests: <code>cargo test --features pure-rust</code></li>
<li>Run benchmarks: <code>cargo bench --features pure-rust</code></li>
</ol>
<h3 id="debugging-parse-failures"><a class="header" href="#debugging-parse-failures">Debugging Parse Failures</a></h3>
<ol>
<li>Use <code>cargo xtask corpus --diagnose</code> for detailed error info</li>
<li>For Pest parser: Check parse error messages which show exact location</li>
<li>Use <code>cargo xtask parse-rust file.pl --ast</code> to see AST structure</li>
</ol>
<h3 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h3>
<ol>
<li>Run benchmarks before and after changes: <code>cargo bench</code></li>
<li>Use comprehensive benchmark framework: <code>cargo xtask bench</code></li>
<li>Use <code>cargo xtask compare --report</code> to compare implementations with memory tracking</li>
<li>Check performance gates with statistical analysis: <code>python3 scripts/generate_comparison.py</code></li>
<li>Check for performance gates: <code>cargo xtask compare --check-gates</code></li>
<li>Monitor incremental parsing performance: <code>cargo test -p perl-parser --test incremental_perf_test</code></li>
<li>Validate memory profiling: <code>cargo run --bin xtask -- validate-memory-profiling</code></li>
<li>Monitor memory usage patterns with statistical analysis</li>
<li>Use dual-mode memory measurement (procfs RSS + peak_alloc) for accurate profiling</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../developer/contributing.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../developer/testing-guide.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../developer/contributing.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../developer/testing-guide.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
