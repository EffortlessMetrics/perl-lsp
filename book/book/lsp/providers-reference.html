<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LSP Providers Reference - Perl LSP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the perl-lsp project - a production-ready Perl Language Server Protocol implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Perl LSP Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/EffortlessMetrics/tree-sitter-perl-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lsp-providers-reference"><a class="header" href="#lsp-providers-reference">LSP Providers Reference</a></h1>
<!-- Labels: docs:reference, lsp:providers, parser:comprehensive-improvements -->
<p><strong>Reference Documentation</strong> - Complete technical specifications for Perl LSP providers</p>
<p>This document provides comprehensive API reference for the seven LSP provider modules that deliver enhanced editor integration features for Perl development. Each provider integrates with the Parse → Index → Navigate → Complete → Analyze workflow to provide specialized functionality.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ul>
<li><a href="#document-links-provider">Document Links Provider</a></li>
<li><a href="#code-lens-provider">Code Lens Provider</a></li>
<li><a href="#inlay-hints-provider">Inlay Hints Provider</a></li>
<li><a href="#document-highlights-provider">Document Highlights Provider</a></li>
<li><a href="#folding-ranges-provider">Folding Ranges Provider</a></li>
<li><a href="#type-definition-provider">Type Definition Provider</a></li>
<li><a href="#implementation-provider">Implementation Provider</a></li>
</ul>
<hr />
<h2 id="document-links-provider"><a class="header" href="#document-links-provider">Document Links Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/document_links.rs</code>
<strong>LSP Method</strong>: <code>textDocument/documentLink</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentLink">LSP 3.17 Document Link</a></p>
<h3 id="purpose"><a class="header" href="#purpose">Purpose</a></h3>
<p>Provides clickable links in Perl source code for module imports and file requirements, enabling quick navigation to module definitions or CPAN documentation. Automatically resolves local module paths and creates MetaCPAN links for external dependencies.</p>
<h3 id="lsp-workflow-integration"><a class="header" href="#lsp-workflow-integration">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: Scans source text for <code>use</code> and <code>require</code> statements (line-based parsing)</li>
<li><strong>Index</strong>: Resolves module paths against workspace roots and common Perl library directories</li>
<li><strong>Navigate</strong>: Creates URI links to local files or MetaCPAN documentation</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: No direct integration</li>
</ul>
<h3 id="configuration"><a class="header" href="#configuration">Configuration</a></h3>
<p>The provider requires workspace root URLs for proper module path resolution:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::document_links::compute_links;
use url::Url;

let workspace_roots = vec![
    Url::parse("file:///workspace/project").unwrap(),
];
<span class="boring">}</span></code></pre></pre>
<h3 id="key-methods"><a class="header" href="#key-methods">Key Methods</a></h3>
<h4 id="compute_links"><a class="header" href="#compute_links"><code>compute_links</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn compute_links(uri: &amp;str, text: &amp;str, roots: &amp;[Url]) -&gt; Vec&lt;Value&gt;
<span class="boring">}</span></code></pre></pre>
<p>Computes document links for a given Perl document.</p>
<p><strong>Arguments</strong>:</p>
<ul>
<li><code>uri</code>: The URI of the document being processed</li>
<li><code>text</code>: The content of the document</li>
<li><code>roots</code>: A slice of workspace root URLs to resolve modules against</li>
</ul>
<p><strong>Returns</strong>: Vector of <code>serde_json::Value</code> objects representing LSP DocumentLink structures</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Scans text line-by-line for <code>use</code> and <code>require</code> statements</li>
<li>Extracts module names (e.g., <code>Foo::Bar</code> from <code>use Foo::Bar;</code>)</li>
<li>Filters out core pragmas (<code>strict</code>, <code>warnings</code>, <code>utf8</code>, etc.)</li>
<li>Attempts local resolution through <code>lib/</code>, <code>blib/lib/</code>, workspace root</li>
<li>Falls back to MetaCPAN link for unresolved modules (<code>https://metacpan.org/pod/{module}</code>)</li>
</ol>
<h3 id="supported-patterns"><a class="header" href="#supported-patterns">Supported Patterns</a></h3>
<p>The provider recognizes these Perl import patterns:</p>
<pre><code class="language-perl"># Module imports - creates links to local files or MetaCPAN
use Data::Dumper;
use MyApp::Module;

# File requirements - resolves relative to workspace roots
require "lib/helper.pl";
require 'config/settings.pm';
</code></pre>
<h3 id="excluded-patterns"><a class="header" href="#excluded-patterns">Excluded Patterns</a></h3>
<p>Core Perl pragmas are excluded from linking (30 pragmas total):</p>
<pre><code class="language-perl"># No links created for these
use strict;
use warnings;
use feature;
use parent;
use base;
# ... (see is_pragma function for complete list)
</code></pre>
<h3 id="example-usage"><a class="header" href="#example-usage">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::document_links::compute_links;
use url::Url;

let source = r#"
use Data::Dumper;
require JSON::XS;
use MyApp::Controller;
"#;

let uri = "file:///project/script.pl";
let roots = vec![Url::parse("file:///project").unwrap()];

let links = compute_links(uri, source, &amp;roots);

// Links contain JSON-RPC formatted DocumentLink objects:
// {
//   "range": {"start": {"line": 1, "character": 4}, "end": {"line": 1, "character": 16}},
//   "target": "https://metacpan.org/pod/Data::Dumper",
//   "tooltip": "Open Data::Dumper"
// }
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics"><a class="header" href="#performance-characteristics">Performance Characteristics</a></h3>
<ul>
<li><strong>Parsing Speed</strong>: Line-based scanning, &lt;100μs for typical files</li>
<li><strong>Memory Footprint</strong>: Minimal - no AST required, operates on text</li>
<li><strong>Workspace Resolution</strong>: First-match algorithm for module paths</li>
</ul>
<h3 id="test-coverage"><a class="header" href="#test-coverage">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_document_links_test.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Basic URL handling (Windows/Unix paths)</li>
<li>Relative path resolution</li>
<li>Module link creation</li>
</ul>
<p><strong>Known Limitations</strong>:</p>
<ul>
<li>Test coverage is basic (URL validation only)</li>
<li>No integration tests for full LSP workflow</li>
<li>Module resolution logic not directly testable from external tests</li>
</ul>
<hr />
<h2 id="code-lens-provider"><a class="header" href="#code-lens-provider">Code Lens Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/code_lens_provider.rs</code>
<strong>LSP Method</strong>: <code>textDocument/codeLens</code>, <code>codeLens/resolve</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_codeLens">LSP 3.17 Code Lens</a></p>
<h3 id="purpose-1"><a class="header" href="#purpose-1">Purpose</a></h3>
<p>Displays inline actionable information above code elements such as reference counts for subroutines/packages and “Run Test” buttons for test functions. Supports two-phase resolution: initial lens extraction and lazy reference counting.</p>
<h3 id="lsp-workflow-integration-1"><a class="header" href="#lsp-workflow-integration-1">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST traversal to identify subroutines, packages, test functions</li>
<li><strong>Index</strong>: Reference counting via workspace index for “X references” lenses</li>
<li><strong>Navigate</strong>: Provides commands for finding references and running tests</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Test function detection uses naming convention heuristics</li>
</ul>
<h3 id="configuration-1"><a class="header" href="#configuration-1">Configuration</a></h3>
<p>No external configuration required. Integrates with workspace index for reference counting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::code_lens_provider::{CodeLensProvider, resolve_code_lens};

let provider = CodeLensProvider::new(source.to_string());
<span class="boring">}</span></code></pre></pre>
<h3 id="key-types"><a class="header" href="#key-types">Key Types</a></h3>
<h4 id="codelens"><a class="header" href="#codelens"><code>CodeLens</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct CodeLens {
    pub range: Range,                    // LSP range to display lens
    pub command: Option&lt;Command&gt;,        // Executable command (resolved)
    pub data: Option&lt;Value&gt;,             // Data for lazy resolution
}
<span class="boring">}</span></code></pre></pre>
<h4 id="command"><a class="header" href="#command"><code>Command</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct Command {
    pub title: String,                   // Display text
    pub command: String,                 // Command identifier
    pub arguments: Option&lt;Vec&lt;Value&gt;&gt;,   // Command arguments
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-methods-1"><a class="header" href="#key-methods-1">Key Methods</a></h3>
<h4 id="codelensprovidernew"><a class="header" href="#codelensprovidernew"><code>CodeLensProvider::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(source: String) -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates a new code lens provider with source text for position calculations.</p>
<h4 id="codelensproviderextract"><a class="header" href="#codelensproviderextract"><code>CodeLensProvider::extract</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract(&amp;self, ast: &amp;Node) -&gt; Vec&lt;CodeLens&gt;
<span class="boring">}</span></code></pre></pre>
<p>Extracts code lenses from an AST through recursive traversal.</p>
<p><strong>Supported Node Types</strong>:</p>
<ul>
<li><code>NodeKind::Subroutine</code>: Adds “Run Test” lens for test functions, “X references” lens for all subs</li>
<li><code>NodeKind::Package</code>: Adds “X references” lens</li>
</ul>
<p><strong>Test Function Detection Patterns</strong>:</p>
<ul>
<li><code>test_*</code> - Standard test prefix</li>
<li><code>*_test</code> - Alternative test suffix</li>
<li><code>t_*</code> - Short test prefix</li>
<li><code>test</code> - Standalone test function</li>
<li><code>ok_*</code>, <code>is_*</code>, <code>like_*</code>, <code>can_*</code> - Test::More style</li>
</ul>
<h4 id="resolve_code_lens"><a class="header" href="#resolve_code_lens"><code>resolve_code_lens</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn resolve_code_lens(lens: CodeLens, reference_count: usize) -&gt; CodeLens
<span class="boring">}</span></code></pre></pre>
<p>Resolves a code lens by adding reference count command.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Checks if lens has <code>data</code> but no <code>command</code> (unresolved references lens)</li>
<li>Extracts symbol name from <code>data</code></li>
<li>Creates command with formatted reference count</li>
<li>Returns resolved lens with <code>editor.action.findReferences</code> command</li>
</ol>
<h4 id="get_shebang_lens"><a class="header" href="#get_shebang_lens"><code>get_shebang_lens</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn get_shebang_lens(source: &amp;str) -&gt; Option&lt;CodeLens&gt;
<span class="boring">}</span></code></pre></pre>
<p>Detects shebang line and returns “Run Script” lens if present.</p>
<p><strong>Detection Pattern</strong>: <code>#!/...perl...</code> at start of file</p>
<h3 id="example-usage-1"><a class="header" href="#example-usage-1">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::{Parser, code_lens_provider::{CodeLensProvider, resolve_code_lens}};

let source = r#"#!/usr/bin/perl
package MyApp;

sub test_basic {
    ok(1, "test passes");
}

sub helper {
    return 42;
}
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

let provider = CodeLensProvider::new(source.to_string());
let mut lenses = provider.extract(&amp;ast);

// Add shebang lens
if let Some(shebang) = get_shebang_lens(source) {
    lenses.push(shebang);
}

// Resolve reference lenses (typically done by LSP server)
for lens in &amp;mut lenses {
    if lens.command.is_none() {
        *lens = resolve_code_lens(lens.clone(), 3); // 3 references found
    }
}

// Lenses now contain:
// - "▶ Run Script" at line 0 (shebang)
// - "▶ Run Test" above test_basic
// - "3 references" for test_basic
// - "3 references" for helper
// - "3 references" for MyApp package
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-1"><a class="header" href="#performance-characteristics-1">Performance Characteristics</a></h3>
<ul>
<li><strong>AST Traversal</strong>: Single-pass recursive descent, &lt;1ms for typical files</li>
<li><strong>Position Calculation</strong>: UTF-8 byte offset to line/column conversion, ~1μs per position</li>
<li><strong>Memory Usage</strong>: ~100 bytes per lens (typical file has 5-20 lenses)</li>
</ul>
<h3 id="test-coverage-1"><a class="header" href="#test-coverage-1">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_code_lens_reference_test.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Code lens extraction for subroutines (test and non-test)</li>
<li>Shebang detection and “Run Script” lens</li>
<li>Reference counting resolution</li>
<li>Integration with LSP server protocol</li>
</ul>
<p><strong>Test Scenarios</strong>:</p>
<ul>
<li>Multiple function calls with reference counting</li>
<li>Unused functions (0 references)</li>
<li>Test function naming patterns</li>
<li>Shebang presence/absence</li>
</ul>
<hr />
<h2 id="inlay-hints-provider"><a class="header" href="#inlay-hints-provider">Inlay Hints Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/inlay_hints_provider.rs</code>
<strong>LSP Method</strong>: <code>textDocument/inlayHint</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_inlayHint">LSP 3.17 Inlay Hint</a></p>
<h3 id="purpose-2"><a class="header" href="#purpose-2">Purpose</a></h3>
<p>Displays inline type information and parameter names to improve code readability without cluttering the source. Shows parameter labels for function calls, inferred types for variables, and intermediate types for method chains.</p>
<h3 id="lsp-workflow-integration-2"><a class="header" href="#lsp-workflow-integration-2">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST traversal to identify function calls, variable declarations, method chains</li>
<li><strong>Index</strong>: Uses builtin signatures from <code>builtin_signatures_phf</code> for parameter names</li>
<li><strong>Navigate</strong>: No direct integration</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Type inference for Perl expressions (arrays, hashes, function return types)</li>
</ul>
<h3 id="configuration-2"><a class="header" href="#configuration-2">Configuration</a></h3>
<h4 id="inlayhintconfig"><a class="header" href="#inlayhintconfig"><code>InlayHintConfig</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InlayHintConfig {
    pub parameter_hints: bool,    // Enable/disable parameter name hints
    pub type_hints: bool,          // Enable/disable type annotation hints
    pub chained_hints: bool,       // Enable/disable chained method type hints
    pub max_length: usize,         // Maximum hint label length (default: 30)
}

impl Default for InlayHintConfig {
    fn default() -&gt; Self {
        Self {
            parameter_hints: true,
            type_hints: true,
            chained_hints: true,
            max_length: 30,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-types-1"><a class="header" href="#key-types-1">Key Types</a></h3>
<h4 id="inlayhint"><a class="header" href="#inlayhint"><code>InlayHint</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct InlayHint {
    pub position: Position,         // Where to display the hint
    pub label: String,              // Hint text
    pub kind: InlayHintKind,        // Type or Parameter
    pub tooltip: Option&lt;String&gt;,    // Additional information
    pub padding_left: bool,         // Add space before hint
    pub padding_right: bool,        // Add space after hint
}
<span class="boring">}</span></code></pre></pre>
<h4 id="inlayhintkind"><a class="header" href="#inlayhintkind"><code>InlayHintKind</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum InlayHintKind {
    Type = 1,       // Type annotation
    Parameter = 2,  // Parameter name
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-methods-2"><a class="header" href="#key-methods-2">Key Methods</a></h3>
<h4 id="inlayhintsprovidernew"><a class="header" href="#inlayhintsprovidernew"><code>InlayHintsProvider::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(source: String) -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates provider with default configuration.</p>
<h4 id="inlayhintsproviderwith_config"><a class="header" href="#inlayhintsproviderwith_config"><code>InlayHintsProvider::with_config</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn with_config(source: String, config: InlayHintConfig) -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates provider with custom configuration.</p>
<h4 id="inlayhintsproviderextract"><a class="header" href="#inlayhintsproviderextract"><code>InlayHintsProvider::extract</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract(&amp;self, ast: &amp;Node) -&gt; Vec&lt;InlayHint&gt;
<span class="boring">}</span></code></pre></pre>
<p>Extracts all inlay hints from the AST.</p>
<h4 id="inlayhintsproviderextract_range"><a class="header" href="#inlayhintsproviderextract_range"><code>InlayHintsProvider::extract_range</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_range(&amp;self, ast: &amp;Node, range: Range) -&gt; Vec&lt;InlayHint&gt;
<span class="boring">}</span></code></pre></pre>
<p>Extracts inlay hints within a specific range (performance optimization for visible viewport).</p>
<h3 id="supported-patterns-1"><a class="header" href="#supported-patterns-1">Supported Patterns</a></h3>
<h4 id="parameter-hints"><a class="header" href="#parameter-hints">Parameter Hints</a></h4>
<p>Shows parameter names for function calls using builtin signatures or common function knowledge:</p>
<pre><code class="language-perl"># Displays: push(ARRAY: @array, list: "value")
push(@array, "value");

# Displays: substr(string: $str, offset: 0, length: 5, replacement: "new")
substr($str, 0, 5, "new");

# Displays: open(FILEHANDLE: FH, mode: "&lt;", filename: "file.txt")
open(FH, "&lt;", "file.txt");
</code></pre>
<p><strong>Smart Filtering</strong>: Skips hints for clear arguments:</p>
<ul>
<li>Short string literals (&lt;20 chars, alphanumeric)</li>
<li>Long descriptive variable names (&gt;5 chars)</li>
</ul>
<h4 id="type-hints"><a class="header" href="#type-hints">Type Hints</a></h4>
<p>Shows inferred types for variable declarations:</p>
<pre><code class="language-perl"># Displays: my $arr: ARRAY = [1, 2, 3];
my $arr = [1, 2, 3];

# Displays: my $hash: HASH = { key =&gt; "value" };
my $hash = { key =&gt; "value" };

# Displays: my $result: ARRAY = split(/,/, $input);
my $result = split(/,/, $input);
</code></pre>
<p><strong>Type Inference Rules</strong>:</p>
<ul>
<li><code>[]</code> → <code>ARRAY</code></li>
<li><code>{}</code> → <code>HASH</code></li>
<li><code>"..."</code> → <code>string</code></li>
<li><code>42</code> → <code>number</code></li>
<li><code>qr//</code> → <code>Regexp</code></li>
<li><code>split</code>, <code>keys</code>, <code>values</code>, <code>grep</code>, <code>map</code> → <code>ARRAY</code></li>
<li><code>new</code> → <code>object</code></li>
</ul>
<h4 id="chained-hints"><a class="header" href="#chained-hints">Chained Hints</a></h4>
<p>Shows intermediate types in method chains:</p>
<pre><code class="language-perl"># Displays: $result /* ARRAY */ -&gt;map(...)
my $result = split(/,/, $input)-&gt;map(...);
</code></pre>
<h3 id="example-usage-2"><a class="header" href="#example-usage-2">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::{Parser, inlay_hints_provider::{InlayHintsProvider, InlayHintConfig}};

let source = r#"
my $arr = [1, 2, 3];
push(@array, "value");
substr($string, 0, 5, "replacement");
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

// Use default configuration
let provider = InlayHintsProvider::new(source.to_string());
let hints = provider.extract(&amp;ast);

// Or customize configuration
let config = InlayHintConfig {
    parameter_hints: true,
    type_hints: false,  // Disable type hints
    chained_hints: true,
    max_length: 20,
};
let custom_provider = InlayHintsProvider::with_config(source.to_string(), config);
let custom_hints = custom_provider.extract(&amp;ast);

// Convert to JSON for LSP
for hint in hints {
    let json = hint.to_json();
    println!("{}", json);
}
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-2"><a class="header" href="#performance-characteristics-2">Performance Characteristics</a></h3>
<ul>
<li><strong>AST Traversal</strong>: Single-pass recursive descent</li>
<li><strong>Hint Generation</strong>: &lt;100μs per function call/variable declaration</li>
<li><strong>Range-Based Extraction</strong>: Optimized for viewport rendering (~50% reduction for visible area)</li>
<li><strong>Memory Usage</strong>: ~80 bytes per hint</li>
</ul>
<h3 id="test-coverage-2"><a class="header" href="#test-coverage-2">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-parser/src/inlay_hints_provider.rs</code> (internal tests)</p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Parameter hints for builtin functions (<code>push</code>, <code>substr</code>, <code>open</code>)</li>
<li>Type hints for arrays, hashes, function calls</li>
<li>Smart filtering for clear arguments</li>
<li>Inferred return types</li>
</ul>
<p><strong>Test Status</strong>:</p>
<ul>
<li>Tests acknowledge new AST structure may not fully support inlay hints yet</li>
<li>Empty results acceptable during AST migration</li>
<li>Focus on ensuring no crashes and proper structure</li>
</ul>
<hr />
<h2 id="document-highlights-provider"><a class="header" href="#document-highlights-provider">Document Highlights Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/document_highlight.rs</code>
<strong>LSP Method</strong>: <code>textDocument/documentHighlight</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_documentHighlight">LSP 3.17 Document Highlight</a></p>
<h3 id="purpose-3"><a class="header" href="#purpose-3">Purpose</a></h3>
<p>Highlights all occurrences of a symbol when the cursor is positioned on it, distinguishing between read and write access. Supports variables (scalars, arrays, hashes), functions, methods, and identifiers with proper scope awareness.</p>
<h3 id="lsp-workflow-integration-3"><a class="header" href="#lsp-workflow-integration-3">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST traversal to find all symbol occurrences</li>
<li><strong>Index</strong>: No workspace indexing (single-document scope)</li>
<li><strong>Navigate</strong>: Provides visual feedback for symbol usage</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Write/read access detection through parent node analysis</li>
</ul>
<h3 id="key-types-2"><a class="header" href="#key-types-2">Key Types</a></h3>
<h4 id="documenthighlight"><a class="header" href="#documenthighlight"><code>DocumentHighlight</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct DocumentHighlight {
    pub location: SourceLocation,       // Byte offset range
    pub kind: DocumentHighlightKind,    // Text, Read, or Write
}
<span class="boring">}</span></code></pre></pre>
<h4 id="documenthighlightkind"><a class="header" href="#documenthighlightkind"><code>DocumentHighlightKind</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum DocumentHighlightKind {
    Text = 1,   // Regular text occurrence
    Read = 2,   // Read access to symbol
    Write = 3,  // Write access (declaration, assignment, increment)
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-methods-3"><a class="header" href="#key-methods-3">Key Methods</a></h3>
<h4 id="documenthighlightprovidernew"><a class="header" href="#documenthighlightprovidernew"><code>DocumentHighlightProvider::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates a new stateless document highlight provider.</p>
<h4 id="documenthighlightproviderfind_highlights"><a class="header" href="#documenthighlightproviderfind_highlights"><code>DocumentHighlightProvider::find_highlights</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_highlights(
    &amp;self,
    ast: &amp;Node,
    source: &amp;str,
    byte_offset: usize,
) -&gt; Vec&lt;DocumentHighlight&gt;
<span class="boring">}</span></code></pre></pre>
<p>Finds all highlights for the symbol at the given position.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Find the node at the cursor byte offset</li>
<li>Extract symbol information (name, sigil, type)</li>
<li>Recursively collect all matching symbols in the AST</li>
<li>Determine highlight kind (Write/Read) based on parent context</li>
<li>Deduplicate by location, preferring Write over Read</li>
</ol>
<p><strong>Write Access Detection</strong>:</p>
<ul>
<li>Variable declarations (<code>my $x</code>, <code>our @ISA</code>)</li>
<li>Left side of assignments (<code>$x = ...</code>)</li>
<li>Increment/decrement operations (<code>$x++</code>, <code>--$x</code>)</li>
</ul>
<p><strong>Read Access</strong>: All other occurrences</p>
<h3 id="supported-symbol-types"><a class="header" href="#supported-symbol-types">Supported Symbol Types</a></h3>
<h4 id="variables"><a class="header" href="#variables">Variables</a></h4>
<pre><code class="language-perl">my $foo = 42;    # Write
print $foo;      # Read
$foo = $foo + 1; # Write (LHS), Read (RHS)
my $bar = $foo * 2; # Read
</code></pre>
<p><strong>Symbol Info</strong>:</p>
<ul>
<li>Name: <code>foo</code></li>
<li>Sigil: <code>$</code></li>
<li>Highlights: All 5 occurrences with appropriate kinds</li>
</ul>
<h4 id="functions"><a class="header" href="#functions">Functions</a></h4>
<pre><code class="language-perl">sub calculate {  # Declaration
    return 42;
}

my $result = calculate();  # Call
calculate();               # Call
print calculate();         # Call
</code></pre>
<p><strong>Symbol Info</strong>:</p>
<ul>
<li>Name: <code>calculate</code></li>
<li>Sigil: None</li>
<li>Highlights: All 4 occurrences (declaration + 3 calls)</li>
</ul>
<h4 id="methods"><a class="header" href="#methods">Methods</a></h4>
<pre><code class="language-perl">sub process { ... }  # Declaration

$obj-&gt;process();     # Call
$other-&gt;process();   # Call
</code></pre>
<p><strong>Symbol Info</strong>:</p>
<ul>
<li>Name: <code>process</code></li>
<li>Sigil: None</li>
<li>Is Method: true</li>
<li>Highlights: Only method calls (not function declarations)</li>
</ul>
<h3 id="parent-context-analysis"><a class="header" href="#parent-context-analysis">Parent Context Analysis</a></h3>
<p>The provider uses parent node analysis to determine highlight kinds:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Declaration context
NodeKind::VariableDeclaration { variable, .. } =&gt; Write

// Assignment context
NodeKind::Assignment { lhs, .. } =&gt; Write (if match on LHS), Read (otherwise)

// Increment/decrement context
NodeKind::Unary { op: "++"|"--", operand } =&gt; Write
<span class="boring">}</span></code></pre></pre>
<h3 id="deduplication-strategy"><a class="header" href="#deduplication-strategy">Deduplication Strategy</a></h3>
<p>When the same position has multiple potential highlights (e.g., assignment LHS is both declaration and write):</p>
<ol>
<li>Group by <code>(start, end)</code> byte offset</li>
<li>Prefer <code>Write (3)</code> over <code>Read (2)</code> over <code>Text (1)</code></li>
<li>Sort final results by start position</li>
</ol>
<h3 id="example-usage-3"><a class="header" href="#example-usage-3">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::{Parser, document_highlight::DocumentHighlightProvider};

let source = r#"
my $foo = 42;
print $foo;
$foo = $foo + 1;
my $bar = $foo * 2;
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

let provider = DocumentHighlightProvider::new();

// Find highlights for $foo at byte offset 4 (first occurrence)
let highlights = provider.find_highlights(&amp;ast, source, 4);

// Results:
// [
//   DocumentHighlight { location: 3..7 (my $foo), kind: Write },
//   DocumentHighlight { location: 23..27 (print $foo), kind: Read },
//   DocumentHighlight { location: 31..35 ($foo = ...), kind: Write },
//   DocumentHighlight { location: 38..42 (... $foo + 1), kind: Read },
//   DocumentHighlight { location: 59..63 ($foo * 2), kind: Read },
// ]
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-3"><a class="header" href="#performance-characteristics-3">Performance Characteristics</a></h3>
<ul>
<li><strong>Node Finding</strong>: Single AST traversal, &lt;50μs for typical files</li>
<li><strong>Symbol Matching</strong>: O(n) where n = AST node count</li>
<li><strong>Deduplication</strong>: HashMap-based, O(h) where h = highlight count</li>
<li><strong>Memory Usage</strong>: ~50 bytes per highlight</li>
</ul>
<h3 id="test-coverage-3"><a class="header" href="#test-coverage-3">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_document_highlight_test.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Scalar variable highlighting with write/read detection</li>
<li>Subroutine call highlighting</li>
<li>Method call highlighting (incomplete implementation acknowledged)</li>
<li>Statement modifier highlighting (Issue #191 fixes)</li>
<li>Empty results for non-symbol positions</li>
</ul>
<p><strong>Known Issues</strong>:</p>
<ul>
<li>Test acknowledges some patterns may return 0 results during implementation refinement</li>
<li>Focus on API correctness rather than complete coverage</li>
</ul>
<hr />
<h2 id="folding-ranges-provider"><a class="header" href="#folding-ranges-provider">Folding Ranges Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/folding.rs</code>
<strong>LSP Method</strong>: <code>textDocument/foldingRange</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_foldingRange">LSP 3.17 Folding Range</a></p>
<h3 id="purpose-4"><a class="header" href="#purpose-4">Purpose</a></h3>
<p>Enables code folding/collapsing in editors for logical code sections including subroutines, blocks, control structures, classes, heredocs, and import statement groups. Optimized for large Perl files with byte offset-based ranges.</p>
<h3 id="lsp-workflow-integration-4"><a class="header" href="#lsp-workflow-integration-4">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST traversal for structural elements + lexer for heredocs</li>
<li><strong>Index</strong>: No workspace indexing (single-document scope)</li>
<li><strong>Navigate</strong>: Provides visual code organization</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Groups consecutive import statements automatically</li>
</ul>
<h3 id="key-types-3"><a class="header" href="#key-types-3">Key Types</a></h3>
<h4 id="foldingrange"><a class="header" href="#foldingrange"><code>FoldingRange</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct FoldingRange {
    pub start_offset: usize,            // Starting byte offset
    pub end_offset: usize,              // Ending byte offset
    pub kind: Option&lt;FoldingRangeKind&gt;, // Optional classification
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Performance Note</strong>: Uses byte offsets (not line numbers) for &lt;1μs range calculation per fold region. LSP server converts to line numbers during serialization.</p>
<h4 id="foldingrangekind"><a class="header" href="#foldingrangekind"><code>FoldingRangeKind</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum FoldingRangeKind {
    Comment,  // Multi-line comments, POD, DATA sections
    Imports,  // Consecutive use/require statements
    Region,   // Code blocks, subs, classes, heredocs
}
<span class="boring">}</span></code></pre></pre>
<h3 id="key-methods-4"><a class="header" href="#key-methods-4">Key Methods</a></h3>
<h4 id="foldingrangeextractornew"><a class="header" href="#foldingrangeextractornew"><code>FoldingRangeExtractor::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates a new folding range extractor with empty state.</p>
<h4 id="foldingrangeextractorextract"><a class="header" href="#foldingrangeextractorextract"><code>FoldingRangeExtractor::extract</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract(&amp;mut self, ast: &amp;Node) -&gt; Vec&lt;FoldingRange&gt;
<span class="boring">}</span></code></pre></pre>
<p>Extracts all folding ranges from the AST.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Clear previous ranges</li>
<li>Recursively visit all AST nodes</li>
<li>Create ranges for foldable constructs (multi-line only)</li>
<li>Return cloned vector</li>
</ol>
<h4 id="foldingrangeextractorextract_heredoc_ranges"><a class="header" href="#foldingrangeextractorextract_heredoc_ranges"><code>FoldingRangeExtractor::extract_heredoc_ranges</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn extract_heredoc_ranges(text: &amp;str) -&gt; Vec&lt;FoldingRange&gt;
<span class="boring">}</span></code></pre></pre>
<p>Extracts heredoc folding ranges using the lexer (separate from AST).</p>
<p><strong>Rationale</strong>: Heredocs may span multiple tokens and require special lexer-based handling for accurate byte offset ranges.</p>
<h3 id="supported-constructs"><a class="header" href="#supported-constructs">Supported Constructs</a></h3>
<h4 id="packages"><a class="header" href="#packages">Packages</a></h4>
<pre><code class="language-perl">package MyApp::Controller {
    # Package body
    sub handler { ... }
}

# Or bare packages (multi-line scope)
package MyApp::Model;
# ... module content ...
</code></pre>
<p><strong>Fold Range</strong>: Entire package declaration to closing brace or next package</p>
<h4 id="subroutines-and-methods"><a class="header" href="#subroutines-and-methods">Subroutines and Methods</a></h4>
<pre><code class="language-perl">sub calculate {
    my $x = shift;
    return $x * 2;
}

method process($arg) {
    return $arg + 1;
}
</code></pre>
<p><strong>Fold Range</strong>: Subroutine/method body block</p>
<h4 id="control-structures"><a class="header" href="#control-structures">Control Structures</a></h4>
<pre><code class="language-perl">if ($condition) {
    # Then branch
} elsif ($other) {
    # Elsif branch
} else {
    # Else branch
}

while ($x &lt; 10) {
    # Loop body
}

for (my $i = 0; $i &lt; 10; $i++) {
    # Loop body
}

foreach my $item (@list) {
    # Loop body
}
</code></pre>
<p><strong>Fold Range</strong>: Each block (if/elsif/else, while, for, foreach)</p>
<h4 id="phase-blocks"><a class="header" href="#phase-blocks">Phase Blocks</a></h4>
<pre><code class="language-perl">BEGIN {
    # Initialization
}

END {
    # Cleanup
}

CHECK { ... }
INIT { ... }
</code></pre>
<p><strong>Fold Range</strong>: Phase block body</p>
<h4 id="classes-corinnaobjectpad"><a class="header" href="#classes-corinnaobjectpad">Classes (Corinna/Object::Pad)</a></h4>
<pre><code class="language-perl">class MyClass {
    field $x;
    method process { ... }
}
</code></pre>
<p><strong>Fold Range</strong>: Class body</p>
<h4 id="arrays-and-hashes"><a class="header" href="#arrays-and-hashes">Arrays and Hashes</a></h4>
<pre><code class="language-perl">my @array = (
    "element1",
    "element2",
    "element3",
);

my %hash = (
    key1 =&gt; "value1",
    key2 =&gt; "value2",
);
</code></pre>
<p><strong>Fold Range</strong>: Array/hash literal with elements</p>
<h4 id="import-groups"><a class="header" href="#import-groups">Import Groups</a></h4>
<pre><code class="language-perl">use strict;
use warnings;
use Data::Dumper;
use JSON::XS;
use MyApp::Config;
# Folded as single group
</code></pre>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Track consecutive <code>use</code>/<code>no</code> statements</li>
<li>Create single folding range spanning first to last import</li>
<li>Reset on non-import statement</li>
<li>Mark as <code>FoldingRangeKind::Imports</code></li>
</ol>
<h4 id="data-sections"><a class="header" href="#data-sections">DATA Sections</a></h4>
<pre><code class="language-perl">__DATA__
Large data content
can be folded
</code></pre>
<p><strong>Fold Range</strong>: DATA section body (marked as Comment)</p>
<h4 id="heredocs"><a class="header" href="#heredocs">Heredocs</a></h4>
<pre><code class="language-perl">my $text = &lt;&lt;'EOF';
Multi-line
heredoc content
EOF
</code></pre>
<p><strong>Extraction</strong>: Uses <code>FoldingRangeExtractor::extract_heredoc_ranges(text)</code> with lexer-based detection</p>
<h3 id="example-usage-4"><a class="header" href="#example-usage-4">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::{Parser, folding::{FoldingRangeExtractor, FoldingRangeKind}};

let source = r#"
package MyApp;
use strict;
use warnings;
use Data::Dumper;

sub calculate {
    my $x = shift;
    if ($x &gt; 0) {
        return $x * 2;
    }
    return 0;
}

my @data = (
    1, 2, 3,
    4, 5, 6,
);
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

let mut extractor = FoldingRangeExtractor::new();
let mut ranges = extractor.extract(&amp;ast);

// Add heredoc ranges
let heredoc_ranges = FoldingRangeExtractor::extract_heredoc_ranges(source);
ranges.extend(heredoc_ranges);

// Results include:
// - Package body (Region)
// - Import group: use strict + use warnings + use Data::Dumper (Imports)
// - Subroutine calculate body (Region)
// - If block inside calculate (Region)
// - Array literal @data (Region)
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-4"><a class="header" href="#performance-characteristics-4">Performance Characteristics</a></h3>
<ul>
<li><strong>Memory Footprint</strong>: 24 bytes per range (optimized for large files)</li>
<li><strong>Range Calculation</strong>: &lt;1μs per fold region</li>
<li><strong>AST Traversal</strong>: Single-pass recursive descent</li>
<li><strong>LSP Serialization</strong>: Direct mapping to protocol types with line conversion</li>
</ul>
<h3 id="test-coverage-4"><a class="header" href="#test-coverage-4">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_folding_ranges_test.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Subroutine folding</li>
<li>Nested block folding (if, while inside subs)</li>
<li>Import group detection (consecutive use statements)</li>
<li>Multi-statement blocks</li>
</ul>
<p><strong>Test Expectations</strong>:</p>
<ul>
<li>At least 4 ranges for nested structures</li>
<li>Proper JSON array response format</li>
</ul>
<hr />
<h2 id="type-definition-provider"><a class="header" href="#type-definition-provider">Type Definition Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/type_definition.rs</code>
<strong>LSP Method</strong>: <code>textDocument/typeDefinition</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_typeDefinition">LSP 3.17 Type Definition</a></p>
<h3 id="purpose-5"><a class="header" href="#purpose-5">Purpose</a></h3>
<p>Provides go-to-type-definition functionality for Perl objects and blessed references, navigating from variable usage to the package/class definition. Supports constructor calls, method calls, blessed references, and <code>isa</code> checks.</p>
<h3 id="lsp-workflow-integration-5"><a class="header" href="#lsp-workflow-integration-5">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST analysis to extract type information from expressions</li>
<li><strong>Index</strong>: Searches across open documents for package definitions</li>
<li><strong>Navigate</strong>: Creates LocationLink to package declarations</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Type inference from blessed references and constructor patterns</li>
</ul>
<h3 id="key-methods-5"><a class="header" href="#key-methods-5">Key Methods</a></h3>
<h4 id="typedefinitionprovidernew"><a class="header" href="#typedefinitionprovidernew"><code>TypeDefinitionProvider::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new() -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates a new stateless type definition provider.</p>
<h4 id="typedefinitionproviderfind_type_definition"><a class="header" href="#typedefinitionproviderfind_type_definition"><code>TypeDefinitionProvider::find_type_definition</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_type_definition(
    &amp;self,
    ast: &amp;Node,
    line: u32,
    character: u32,
    uri: &amp;str,
    documents: &amp;HashMap&lt;String, String&gt;,
) -&gt; Option&lt;Vec&lt;LocationLink&gt;&gt;
<span class="boring">}</span></code></pre></pre>
<p>Finds type definition for a position in the AST.</p>
<p><strong>Returns</strong>: <code>LocationLink</code> array with package definition locations, or <code>None</code> if no type found</p>
<h3 id="supported-patterns-2"><a class="header" href="#supported-patterns-2">Supported Patterns</a></h3>
<h4 id="constructor-calls"><a class="header" href="#constructor-calls">Constructor Calls</a></h4>
<pre><code class="language-perl">my $obj = Package::Name-&gt;new();
#         ^^^^^^^^^^^^^ - Extracts "Package::Name"
</code></pre>
<p><strong>Type Extraction</strong>:</p>
<ul>
<li>Pattern: <code>Identifier -&gt; Identifier("new")</code></li>
<li>Result: Package name from left side of <code>-&gt;</code></li>
</ul>
<h4 id="method-calls"><a class="header" href="#method-calls">Method Calls</a></h4>
<pre><code class="language-perl">$obj-&gt;method();
# Type inferred from $obj declaration (limited support)
</code></pre>
<p><strong>Type Extraction</strong>:</p>
<ul>
<li>Attempts to trace <code>$obj</code> variable to its declaration</li>
<li>Limited to simple cases (<code>$self</code>, <code>$this</code> recognized)</li>
</ul>
<h4 id="blessed-references"><a class="header" href="#blessed-references">Blessed References</a></h4>
<pre><code class="language-perl">bless {}, 'MyClass';
#         ^^^^^^^^ - Extracts "MyClass"

bless $ref, $class;
#           ^^^^^^ - Extracts from variable/identifier
</code></pre>
<p><strong>Type Extraction</strong>:</p>
<ul>
<li>Pattern: <code>bless</code> function call with 2 arguments</li>
<li>Second argument is the package name (string or identifier)</li>
</ul>
<h4 id="isa-checks"><a class="header" href="#isa-checks">ISA Checks</a></h4>
<pre><code class="language-perl">$obj isa MyClass
#       ^^^^^^^^ - Extracts "MyClass"
</code></pre>
<p><strong>Type Extraction</strong>:</p>
<ul>
<li>Pattern: <code>Binary { op: "isa", right: ... }</code></li>
<li>Right side is package name</li>
</ul>
<h4 id="package-qualified-identifiers"><a class="header" href="#package-qualified-identifiers">Package-Qualified Identifiers</a></h4>
<pre><code class="language-perl">Package::Name::method()
# ^^^^^^^^^^^^^ - Extracts "Package::Name"
</code></pre>
<p><strong>Type Extraction</strong>:</p>
<ul>
<li>Pattern: Identifier containing <code>::</code></li>
<li>Package is everything except the last component</li>
</ul>
<h3 id="example-usage-5"><a class="header" href="#example-usage-5">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::Parser;
use perl_lsp::features::type_definition::TypeDefinitionProvider;
use std::collections::HashMap;

let source = r#"
package MyClass;

sub new {
    my $class = shift;
    bless {}, $class;
}

sub method {
    print "Hello\n";
}

package main;

my $obj = MyClass-&gt;new();
$obj-&gt;method();
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

let provider = TypeDefinitionProvider::new();
let uri = "file:///test.pl";

let mut documents = HashMap::new();
documents.insert(uri.to_string(), source.to_string());

// Find type definition for MyClass-&gt;new() at line 14, character 10
let result = provider.find_type_definition(&amp;ast, 14, 10, uri, &amp;documents);

// Result contains LocationLink to "package MyClass;" declaration
assert!(result.is_some());
let locations = result.unwrap();
assert_eq!(locations.len(), 1);
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-5"><a class="header" href="#performance-characteristics-5">Performance Characteristics</a></h3>
<ul>
<li><strong>Type Extraction</strong>: Pattern matching on AST nodes, &lt;10μs</li>
<li><strong>Package Search</strong>: Linear AST traversal, &lt;100ms for typical files</li>
<li><strong>Cross-Document Search</strong>: O(d × n) where d = documents, n = AST nodes</li>
<li><strong>Memory Usage</strong>: Minimal (stateless provider)</li>
</ul>
<h3 id="limitations"><a class="header" href="#limitations">Limitations</a></h3>
<ul>
<li><strong>Object Type Inference</strong>: Limited to simple variable patterns (<code>$self</code>, <code>$this</code>)</li>
<li><strong>Cross-File Resolution</strong>: Searches only open documents, not full workspace</li>
<li><strong>Position Calculation</strong>: Simplified implementation (Issue #196 improvements planned)</li>
<li><strong>Return Values</strong>: May return dummy <code>(0, 0)</code> positions in some cases</li>
</ul>
<h3 id="test-coverage-5"><a class="header" href="#test-coverage-5">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_type_definition_tests.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Basic package definition finding</li>
<li>Constructor call type extraction</li>
<li>CRLF and emoji position handling</li>
<li>Response format validation (array or null)</li>
<li>Non-dummy position verification</li>
</ul>
<p><strong>Known Issues</strong>:</p>
<ul>
<li>Tests focus on API correctness over complete functionality</li>
<li>Position calculations need refinement (acknowledged in tests)</li>
<li>Type inference for complex variable tracking not implemented</li>
</ul>
<hr />
<h2 id="implementation-provider"><a class="header" href="#implementation-provider">Implementation Provider</a></h2>
<p><strong>Module</strong>: <code>crates/perl-parser/src/implementation_provider.rs</code>
<strong>LSP Method</strong>: <code>textDocument/implementation</code>
<strong>LSP Specification</strong>: <a href="https://microsoft.github.io/language-server-protocol/specifications/lsp/3.17/specification/#textDocument_implementation">LSP 3.17 Implementation</a></p>
<h3 id="purpose-6"><a class="header" href="#purpose-6">Purpose</a></h3>
<p>Finds implementations of types and methods in Perl code, including subclasses that inherit from a base class using <code>@ISA</code> or <code>use parent</code>, and overridden methods in derived classes. Supports workspace-wide implementation search with optional workspace indexing.</p>
<h3 id="lsp-workflow-integration-6"><a class="header" href="#lsp-workflow-integration-6">LSP Workflow Integration</a></h3>
<ul>
<li><strong>Parse</strong>: AST analysis to identify packages, inheritance, methods</li>
<li><strong>Index</strong>: Optional workspace index for cross-file inheritance tracking</li>
<li><strong>Navigate</strong>: Provides go-to-implementation functionality</li>
<li><strong>Complete</strong>: No direct integration</li>
<li><strong>Analyze</strong>: Inheritance analysis for implementation relationships</li>
</ul>
<h3 id="key-types-4"><a class="header" href="#key-types-4">Key Types</a></h3>
<h4 id="implementationprovider"><a class="header" href="#implementationprovider"><code>ImplementationProvider</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ImplementationProvider {
    workspace_index: Option&lt;std::sync::Arc&lt;WorkspaceIndex&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p><strong>Workspace Integration</strong>: Optional <code>WorkspaceIndex</code> for comprehensive cross-file implementation finding (5MB memory overhead for implementation metadata).</p>
<h3 id="key-methods-6"><a class="header" href="#key-methods-6">Key Methods</a></h3>
<h4 id="implementationprovidernew"><a class="header" href="#implementationprovidernew"><code>ImplementationProvider::new</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn new(workspace_index: Option&lt;std::sync::Arc&lt;WorkspaceIndex&gt;&gt;) -&gt; Self
<span class="boring">}</span></code></pre></pre>
<p>Creates a new implementation provider with optional workspace indexing.</p>
<p><strong>Examples</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::implementation_provider::ImplementationProvider;

// Without workspace indexing (single-file analysis)
let provider = ImplementationProvider::new(None);

// With workspace indexing (cross-file inheritance)
use std::sync::Arc;
use perl_parser::workspace_index::WorkspaceIndex;
let workspace_index = Arc::new(WorkspaceIndex::new());
let provider = ImplementationProvider::new(Some(workspace_index));
<span class="boring">}</span></code></pre></pre>
<h4 id="implementationproviderfind_implementations"><a class="header" href="#implementationproviderfind_implementations"><code>ImplementationProvider::find_implementations</code></a></h4>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub fn find_implementations(
    &amp;self,
    ast: &amp;Node,
    line: u32,
    character: u32,
    uri: &amp;str,
    documents: &amp;HashMap&lt;String, String&gt;,
) -&gt; Vec&lt;LocationLink&gt;
<span class="boring">}</span></code></pre></pre>
<p>Finds implementations at the given position.</p>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Find the node at cursor position</li>
<li>Extract implementation target (Package, Method, BlessedType)</li>
<li>Search documents for implementations</li>
<li>Return LocationLink array</li>
</ol>
<h3 id="supported-inheritance-patterns"><a class="header" href="#supported-inheritance-patterns">Supported Inheritance Patterns</a></h3>
<h4 id="use-parent"><a class="header" href="#use-parent"><code>use parent</code></a></h4>
<pre><code class="language-perl">package Animal;
sub speak { die "Abstract" }

package Dog;
use parent 'Animal';
#          ^^^^^^^^ - Inheritance detected
sub speak { "Woof!" }
</code></pre>
<p><strong>Detection</strong>:</p>
<ul>
<li>Pattern: <code>Use { module: "parent", args: ["Animal"] }</code></li>
<li>All args checked against base package name</li>
</ul>
<h4 id="use-base"><a class="header" href="#use-base"><code>use base</code></a></h4>
<pre><code class="language-perl">package Cat;
use base 'Animal';
#        ^^^^^^^^ - Inheritance detected
sub speak { "Meow!" }
</code></pre>
<p><strong>Detection</strong>: Same as <code>use parent</code></p>
<h4 id="isa-assignment"><a class="header" href="#isa-assignment"><code>@ISA</code> Assignment</a></h4>
<pre><code class="language-perl">package Bird;
our @ISA = ('Animal');
#          ^^^^^^^^^^ - Inheritance detected
sub speak { "Chirp!" }

# Or variable form
our @ISA = ($parent_class);
</code></pre>
<p><strong>Detection</strong>:</p>
<ul>
<li>Pattern: <code>VariableDeclaration { declarator: "our", variable: "@ISA", initializer: ... }</code></li>
<li>Initializer checked for parent package name</li>
</ul>
<h3 id="implementation-finding-strategies"><a class="header" href="#implementation-finding-strategies">Implementation Finding Strategies</a></h3>
<h4 id="package-implementations-subclasses"><a class="header" href="#package-implementations-subclasses">Package Implementations (Subclasses)</a></h4>
<p>Finds all classes that inherit from a base package:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For base package "Animal", finds:
// - Dog (use parent 'Animal')
// - Cat (use parent 'Animal')
// - Bird (our @ISA = ('Animal'))
<span class="boring">}</span></code></pre></pre>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Parse all documents in workspace</li>
<li>Find packages with inheritance from base</li>
<li>Use workspace index if available for optimized search</li>
<li>Return LocationLink to package declarations</li>
</ol>
<h4 id="method-implementations-overrides"><a class="header" href="#method-implementations-overrides">Method Implementations (Overrides)</a></h4>
<p>Finds all overridden methods in subclasses:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// For Animal::speak, finds:
// - Dog::speak
// - Cat::speak
// - Bird::speak
<span class="boring">}</span></code></pre></pre>
<p><strong>Algorithm</strong>:</p>
<ol>
<li>Find all package implementations (subclasses)</li>
<li>For each subclass, search AST for method with same name</li>
<li>Return LocationLink to method declarations</li>
</ol>
<h3 id="example-usage-6"><a class="header" href="#example-usage-6">Example Usage</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::{Parser, implementation_provider::ImplementationProvider};
use std::collections::HashMap;

let source = r#"
package Animal;
sub new { bless {}, shift }
sub speak { die "Abstract method" }

package Dog;
use parent 'Animal';
sub speak { "Woof!" }

package Cat;
use parent 'Animal';
sub speak { "Meow!" }

package main;
my $pet = Animal-&gt;new();
"#;

let mut parser = Parser::new(source);
let ast = parser.parse().unwrap();

let provider = ImplementationProvider::new(None);
let uri = "file:///test.pl";

let mut documents = HashMap::new();
documents.insert(uri.to_string(), source.to_string());

// Find implementations of Animal at line 1 (package declaration)
let implementations = provider.find_implementations(&amp;ast, 1, 8, uri, &amp;documents);

// Results contain LocationLink to Dog and Cat package declarations
assert_eq!(implementations.len(), 2);
<span class="boring">}</span></code></pre></pre>
<h3 id="performance-characteristics-6"><a class="header" href="#performance-characteristics-6">Performance Characteristics</a></h3>
<ul>
<li><strong>Implementation Finding</strong>: &lt;100ms for typical inheritance hierarchies</li>
<li><strong>Memory Usage</strong>: &lt;5MB for implementation metadata</li>
<li><strong>Workspace Indexing</strong>: Leverages cached inheritance relationships</li>
<li><strong>Cross-Document Search</strong>: O(d × n) where d = documents, n = AST nodes per document</li>
</ul>
<h3 id="test-coverage-6"><a class="header" href="#test-coverage-6">Test Coverage</a></h3>
<p><strong>Test File</strong>: <code>crates/perl-lsp/tests/lsp_implementation_tests.rs</code></p>
<p><strong>Coverage</strong>:</p>
<ul>
<li>Finding subclasses via <code>use parent</code></li>
<li>Finding method overrides in derived classes</li>
<li>Response format validation (array or null)</li>
<li>Position verification (non-dummy coordinates)</li>
</ul>
<p><strong>Test Scenarios</strong>:</p>
<ul>
<li>Multiple subclasses inheriting from base</li>
<li>Multiple method overrides across inheritance hierarchy</li>
<li>No implementations (returns empty array or null)</li>
</ul>
<hr />
<h2 id="common-patterns-across-providers"><a class="header" href="#common-patterns-across-providers">Common Patterns Across Providers</a></h2>
<h3 id="position-handling"><a class="header" href="#position-handling">Position Handling</a></h3>
<p>All providers use consistent byte offset → UTF-16 line/column conversion:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use perl_parser::position::offset_to_utf16_line_col;

let (line, col) = offset_to_utf16_line_col(source_text, byte_offset);
<span class="boring">}</span></code></pre></pre>
<p><strong>Performance</strong>: ~1μs per conversion with proper UTF-8/UTF-16 handling</p>
<h3 id="ast-traversal"><a class="header" href="#ast-traversal">AST Traversal</a></h3>
<p>Providers implement recursive descent traversal with pattern matching:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn visit_node(&amp;self, node: &amp;Node, context: &amp;mut Context) {
    match &amp;node.kind {
        NodeKind::Program { statements } =&gt; {
            for stmt in statements {
                self.visit_node(stmt, context);
            }
        }
        NodeKind::Subroutine { body, .. } =&gt; {
            // Process subroutine
            self.visit_node(body, context);
        }
        // ... other patterns
        _ =&gt; {}
    }
}
<span class="boring">}</span></code></pre></pre>
<h3 id="lsp-response-format"><a class="header" href="#lsp-response-format">LSP Response Format</a></h3>
<p>All providers return JSON-compatible structures using <code>serde_json</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use serde_json::{Value, json};

let response = json!({
    "range": {
        "start": { "line": start_line, "character": start_col },
        "end": { "line": end_line, "character": end_col }
    },
    "kind": kind_value
});
<span class="boring">}</span></code></pre></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<p>Providers gracefully handle missing data:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Return empty Vec instead of error
pub fn find_symbols(&amp;self, ...) -&gt; Vec&lt;Symbol&gt; {
    match self.internal_find(...) {
        Some(results) =&gt; results,
        None =&gt; Vec::new(),  // Graceful degradation
    }
}

// Return None for optional results
pub fn find_definition(&amp;self, ...) -&gt; Option&lt;Location&gt; {
    let node = self.find_node_at_position(...)?;
    self.extract_definition(node)
}
<span class="boring">}</span></code></pre></pre>
<h2 id="testing-best-practices"><a class="header" href="#testing-best-practices">Testing Best Practices</a></h2>
<h3 id="integration-testing"><a class="header" href="#integration-testing">Integration Testing</a></h3>
<p>All providers have LSP integration tests using the test harness:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use support::lsp_harness::LspHarness;

let mut harness = LspHarness::new();
harness.initialize(None).expect("Failed to initialize");
harness.open(uri, source).expect("Failed to open file");

let response = harness.request("textDocument/METHOD", params)
    .expect("Request failed");
<span class="boring">}</span></code></pre></pre>
<h3 id="test-structure"><a class="header" href="#test-structure">Test Structure</a></h3>
<p>Provider tests follow consistent patterns:</p>
<ol>
<li><strong>Setup</strong>: Initialize LSP server and open test document</li>
<li><strong>Request</strong>: Send LSP method request with test position</li>
<li><strong>Validate</strong>: Check response format (array/null/object)</li>
<li><strong>Verify</strong>: Validate content (ranges, kinds, positions)</li>
</ol>
<h3 id="position-testing"><a class="header" href="#position-testing">Position Testing</a></h3>
<p>Tests verify proper UTF-16 position handling:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Test with CRLF line endings and emojis
let source = "package Test;\r\n# 🎉 Comment\r\nsub new { ... }\r\n";

let response = harness.request(...).expect("Failed");

// Verify non-dummy positions
if let Some(locations) = response.as_array() {
    for loc in locations {
        let line = loc["range"]["start"]["line"].as_u64().unwrap();
        let char = loc["range"]["start"]["character"].as_u64().unwrap();
        assert!(line &gt; 0 || char &gt; 0, "Expected non-(0,0) position");
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="viewport-based-extraction"><a class="header" href="#viewport-based-extraction">Viewport-Based Extraction</a></h3>
<p>Providers support range-based extraction for visible editor regions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Only extract hints/ranges in visible viewport
let range = Range::new(
    Position::new(visible_start_line, 0),
    Position::new(visible_end_line, 0),
);

let hints = provider.extract_range(ast, range);  // ~50% reduction
<span class="boring">}</span></code></pre></pre>
<h3 id="caching-strategies"><a class="header" href="#caching-strategies">Caching Strategies</a></h3>
<ul>
<li><strong>Code Lens</strong>: Two-phase resolution (extract → lazy resolve with reference count)</li>
<li><strong>Folding Ranges</strong>: Byte offset storage for fast LSP line conversion</li>
<li><strong>Type Definition</strong>: Stateless provider (no caching needed)</li>
</ul>
<h3 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h3>
<ul>
<li><strong>Shared State</strong>: Use <code>Arc&lt;WorkspaceIndex&gt;</code> for cross-provider workspace access</li>
<li><strong>Minimal Cloning</strong>: Return references where possible, clone only for LSP serialization</li>
<li><strong>Lazy Evaluation</strong>: Code lens resolution deferred until client requests</li>
</ul>
<h2 id="migration-notes"><a class="header" href="#migration-notes">Migration Notes</a></h2>
<h3 id="from-v2-to-v3-parser"><a class="header" href="#from-v2-to-v3-parser">From v2 to v3 Parser</a></h3>
<p>Several providers acknowledge ongoing AST migration:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Inlay hints test (inlay_hints_provider.rs)
// Note: Inlay hints may not work with new AST structure yet
// For now just ensure it doesn't crash - empty result is acceptable
<span class="boring">}</span></code></pre></pre>
<p><strong>Impact</strong>:</p>
<ul>
<li><strong>Code Lens</strong>: Fully migrated, all tests passing</li>
<li><strong>Document Links</strong>: Fully migrated (line-based, no AST dependency)</li>
<li><strong>Inlay Hints</strong>: Partial migration, some patterns may return empty results</li>
<li><strong>Document Highlights</strong>: Fully migrated with Issue #191 fixes</li>
<li><strong>Folding Ranges</strong>: Fully migrated with lexer integration</li>
<li><strong>Type Definition</strong>: Basic migration complete, position calculation improvements planned</li>
<li><strong>Implementation</strong>: Fully migrated, workspace index integration ready</li>
</ul>
<h2 id="see-also"><a class="header" href="#see-also">See Also</a></h2>
<ul>
<li><a href="LSP_IMPLEMENTATION_GUIDE.html">LSP Implementation Guide</a> - Server architecture and request handling</li>
<li><a href="WORKSPACE_NAVIGATION_GUIDE.html">Workspace Navigation Guide</a> - Cross-file navigation features</li>
<li><a href="API_DOCUMENTATION_STANDARDS.html">API Documentation Standards</a> - Documentation requirements for providers</li>
<li><a href="POSITION_TRACKING_GUIDE.html">Position Tracking Guide</a> - UTF-16/UTF-8 position conversion details</li>
</ul>
<h2 id="related-issues"><a class="header" href="#related-issues">Related Issues</a></h2>
<ul>
<li><strong>Issue #191</strong>: Document Highlights fixes for statement modifiers and regex operations</li>
<li><strong>Issue #196</strong>: Type Definition position calculation improvements</li>
<li><strong>Issue #207</strong>: DAP integration (separate from LSP providers)</li>
<li><strong>Issue #160/SPEC-149</strong>: API documentation infrastructure enforcement</li>
</ul>
<hr />
<p><strong>Document Version</strong>: 1.0.0
<strong>Last Updated</strong>: 2025-01-31
<strong>Maintainer</strong>: Perl LSP Documentation Team</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../lsp/implementation-guide.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../lsp/feature-implementation.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../lsp/implementation-guide.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../lsp/feature-implementation.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
