<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Cancellation System - Perl LSP Documentation</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Comprehensive documentation for the perl-lsp project - a production-ready Perl Language Server Protocol implementation">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Perl LSP Documentation</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/EffortlessMetrics/tree-sitter-perl-rs" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lsp-cancellation-protocol-compliance-specification"><a class="header" href="#lsp-cancellation-protocol-compliance-specification">LSP Cancellation Protocol Compliance Specification</a></h1>
<!-- Labels: lsp:enhancement, cancellation:protocol-compliance, parser:integration, threading:adaptive -->
<h2 id="executive-summary"><a class="header" href="#executive-summary">Executive Summary</a></h2>
<p>This specification defines the enhanced LSP cancellation protocol compliance for the Perl Language Server based on finalized Issue #48 requirements. The specification addresses JSON-RPC 2.0 <code>$/cancelRequest</code> handling with comprehensive provider integration, thread-safe cancellation tokens, and performance-optimized cancellation overhead (&lt;1ms).</p>
<h2 id="lsp-protocol-foundation"><a class="header" href="#lsp-protocol-foundation">LSP Protocol Foundation</a></h2>
<h3 id="json-rpc-20-compliance-requirements"><a class="header" href="#json-rpc-20-compliance-requirements">JSON-RPC 2.0 Compliance Requirements</a></h3>
<p><strong>Core Protocol Specification:</strong></p>
<ul>
<li><strong>Cancellation Notification</strong>: <code>$/cancelRequest</code> with proper JSON-RPC 2.0 structure</li>
<li><strong>Error Response</strong>: -32800 (RequestCancelled) error code per LSP 3.17+ specification</li>
<li><strong>No Response Rule</strong>: Cancellation notifications never produce responses</li>
<li><strong>Request ID Matching</strong>: Exact Value comparison for cancellation identification</li>
</ul>
<p><strong>Current Implementation Status</strong> ✅ <strong>FUNCTIONAL</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Current implementation in /crates/perl-parser/src/lsp_server.rs:533-537
if request.method == "$/cancelRequest" {
    if let Some(idv) = request.params.as_ref().and_then(|p| p.get("id")).cloned() {
        self.cancel_mark(&amp;idv);
    }
    return None; // Notifications don't get responses
}
<span class="boring">}</span></code></pre></pre>
<h3 id="enhanced-protocol-requirements-issue-48"><a class="header" href="#enhanced-protocol-requirements-issue-48">Enhanced Protocol Requirements (Issue #48)</a></h3>
<h4 id="ac1-json-rpc-20-protocol-enhancement"><a class="header" href="#ac1-json-rpc-20-protocol-enhancement">AC1: JSON-RPC 2.0 Protocol Enhancement</a></h4>
<p><strong>Requirement</strong>: Enhanced <code>$/cancelRequest</code> notification processing with provider context awareness.</p>
<p><strong>Technical Specification</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Enhanced cancellation request structure with provider context
#[derive(Debug, Clone)]
pub struct CancellationRequest {
    /// JSON-RPC 2.0 request ID to cancel
    pub id: Value,
    /// LSP method being cancelled for context-aware cleanup
    pub method_context: Option&lt;String&gt;,
    /// Timestamp for cancellation latency tracking
    pub timestamp: std::time::Instant,
    /// Provider-specific cleanup requirements
    pub cleanup_context: ProviderCleanupContext,
}

/// Provider-specific cleanup context for enhanced cancellation
#[derive(Debug, Clone)]
pub enum ProviderCleanupContext {
    /// Completion provider with symbol resolution state
    Completion { workspace_symbols: bool, cross_file: bool },
    /// Workspace symbol search with indexing state
    WorkspaceSymbol { indexing_active: bool, file_count: usize },
    /// References provider with cross-file navigation state
    References { qualified_search: bool, dual_pattern: bool },
    /// Definition provider with incremental parsing state
    Definition { parsing_active: bool, file_uri: Option&lt;String&gt; },
    /// Hover provider with documentation resolution state
    Hover { doc_resolution: bool },
    /// Generic provider without specific cleanup requirements
    Generic,
}
<span class="boring">}</span></code></pre></pre>
<h4 id="ac2-thread-safe-cancellation-token-architecture"><a class="header" href="#ac2-thread-safe-cancellation-token-architecture">AC2: Thread-Safe Cancellation Token Architecture</a></h4>
<p><strong>Requirement</strong>: Thread-safe cancellation tokens with atomic operations and provider integration.</p>
<p><strong>Enhanced Cancellation Token Design</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Enhanced cancellation token with Perl LSP context and atomic operations
pub struct PerlLspCancellationToken {
    /// Thread-safe cancellation state using atomic boolean
    cancelled: Arc&lt;AtomicBool&gt;,
    /// Original request ID for tracking and cleanup
    request_id: Value,
    /// LSP provider context for targeted cleanup
    provider_context: ProviderCleanupContext,
    /// Workspace operations to terminate gracefully
    workspace_operations: Arc&lt;Mutex&lt;Vec&lt;WorkspaceOperationId&gt;&gt;&gt;,
    /// Cancellation timestamp for performance tracking
    created_at: std::time::Instant,
    /// Cancellation latency threshold for performance validation
    latency_threshold: std::time::Duration,
}

impl PerlLspCancellationToken {
    /// Create new cancellation token with provider context
    pub fn new(
        request_id: Value,
        provider_context: ProviderCleanupContext,
        latency_threshold: Option&lt;std::time::Duration&gt;,
    ) -&gt; Self {
        Self {
            cancelled: Arc::new(AtomicBool::new(false)),
            request_id,
            provider_context,
            workspace_operations: Arc::new(Mutex::new(Vec::new())),
            created_at: std::time::Instant::now(),
            latency_threshold: latency_threshold.unwrap_or(std::time::Duration::from_millis(1)),
        }
    }

    /// Check cancellation with atomic operation (lock-free)
    /// Returns true if operation should abort immediately
    pub fn is_cancelled(&amp;self) -&gt; bool {
        self.cancelled.load(Ordering::Relaxed)
    }

    /// Check cancellation with performance tracking and context validation
    pub fn is_cancelled_with_context(&amp;self) -&gt; Result&lt;bool, CancellationError&gt; {
        let cancelled = self.cancelled.load(Ordering::Relaxed);

        // Track cancellation check latency for performance validation
        if cancelled {
            let check_latency = self.created_at.elapsed();
            if check_latency &gt; self.latency_threshold {
                return Err(CancellationError::LatencyThresholdExceeded(check_latency));
            }
        }

        Ok(cancelled)
    }

    /// Cancel token with provider-specific cleanup and performance tracking
    pub fn cancel_with_cleanup(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Mark as cancelled with atomic operation
        self.cancelled.store(true, Ordering::Relaxed);

        // Perform provider-specific cleanup based on context
        match &amp;self.provider_context {
            ProviderCleanupContext::Completion { workspace_symbols, cross_file } =&gt; {
                if *workspace_symbols {
                    self.cleanup_workspace_symbol_resolution()?;
                }
                if *cross_file {
                    self.cleanup_cross_file_navigation()?;
                }
            },
            ProviderCleanupContext::WorkspaceSymbol { indexing_active, .. } =&gt; {
                if *indexing_active {
                    self.cleanup_workspace_indexing()?;
                }
            },
            ProviderCleanupContext::References { qualified_search, dual_pattern } =&gt; {
                if *qualified_search || *dual_pattern {
                    self.cleanup_dual_pattern_search()?;
                }
            },
            ProviderCleanupContext::Definition { parsing_active, .. } =&gt; {
                if *parsing_active {
                    self.cleanup_incremental_parsing()?;
                }
            },
            _ =&gt; {} // Generic cleanup or no specific cleanup required
        }

        Ok(())
    }

    /// Register workspace operation for cancellation tracking
    pub fn register_workspace_operation(&amp;self, operation_id: WorkspaceOperationId) {
        if let Ok(mut ops) = self.workspace_operations.lock() {
            ops.push(operation_id);
        }
    }

    /// Cleanup functions for provider-specific resource management
    fn cleanup_workspace_symbol_resolution(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel ongoing workspace symbol indexing and cleanup temporary data
        Ok(())
    }

    fn cleanup_cross_file_navigation(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel cross-file reference resolution and cleanup file handles
        Ok(())
    }

    fn cleanup_workspace_indexing(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Interrupt workspace indexing operations and preserve consistency
        Ok(())
    }

    fn cleanup_dual_pattern_search(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel dual indexing searches (qualified/bare function names)
        Ok(())
    }

    fn cleanup_incremental_parsing(&amp;self) -&gt; Result&lt;(), CancellationError&gt; {
        // Gracefully terminate incremental parsing without corruption
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="ac3-comprehensive-lsp-provider-integration"><a class="header" href="#ac3-comprehensive-lsp-provider-integration">AC3: Comprehensive LSP Provider Integration</a></h4>
<p><strong>Requirement</strong>: Integration with all LSP providers including completion, hover, definition, references, workspace symbols, and call hierarchy.</p>
<p><strong>Provider Integration Schema</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// LSP Provider cancellation integration points
pub trait CancellableProvider {
    /// Provider-specific cancellation handling with context
    fn handle_cancellation(
        &amp;mut self,
        token: &amp;PerlLspCancellationToken
    ) -&gt; Result&lt;(), CancellationError&gt;;

    /// Check if provider supports graceful cancellation
    fn supports_cancellation(&amp;self) -&gt; bool { true }

    /// Get provider-specific cleanup requirements
    fn cleanup_context(&amp;self) -&gt; ProviderCleanupContext;
}

/// Enhanced completion provider with cancellation support
impl CancellableProvider for CompletionProvider {
    fn handle_cancellation(
        &amp;mut self,
        token: &amp;PerlLspCancellationToken
    ) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel workspace symbol resolution
        self.workspace_index.cancel_symbol_resolution(token)?;

        // Cancel cross-file module resolution
        self.module_resolver.cancel_resolution(token)?;

        // Cleanup temporary completion data
        self.completion_cache.clear_pending();

        Ok(())
    }

    fn cleanup_context(&amp;self) -&gt; ProviderCleanupContext {
        ProviderCleanupContext::Completion {
            workspace_symbols: self.workspace_symbols_enabled,
            cross_file: self.cross_file_enabled,
        }
    }
}

/// Enhanced workspace symbol provider with cancellation support
impl CancellableProvider for WorkspaceSymbolProvider {
    fn handle_cancellation(
        &amp;mut self,
        token: &amp;PerlLspCancellationToken
    ) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel ongoing file indexing operations
        self.file_indexer.cancel_indexing(token)?;

        // Cancel symbol search across multiple files
        self.symbol_searcher.cancel_search(token)?;

        // Preserve index consistency during cancellation
        self.workspace_index.ensure_consistency()?;

        Ok(())
    }

    fn cleanup_context(&amp;self) -&gt; ProviderCleanupContext {
        ProviderCleanupContext::WorkspaceSymbol {
            indexing_active: self.file_indexer.is_active(),
            file_count: self.workspace_index.file_count(),
        }
    }
}

/// Enhanced references provider with dual-pattern cancellation
impl CancellableProvider for ReferencesProvider {
    fn handle_cancellation(
        &amp;mut self,
        token: &amp;PerlLspCancellationToken
    ) -&gt; Result&lt;(), CancellationError&gt; {
        // Cancel qualified name search (Package::function)
        self.qualified_searcher.cancel_search(token)?;

        // Cancel bare name search (function)
        self.bare_searcher.cancel_search(token)?;

        // Cancel cross-file reference resolution
        self.cross_file_resolver.cancel_resolution(token)?;

        Ok(())
    }

    fn cleanup_context(&amp;self) -&gt; ProviderCleanupContext {
        ProviderCleanupContext::References {
            qualified_search: self.qualified_search_active,
            dual_pattern: self.dual_pattern_enabled,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="ac4-enhanced-error-response-handling"><a class="header" href="#ac4-enhanced-error-response-handling">AC4: Enhanced Error Response Handling</a></h4>
<p><strong>Requirement</strong>: Proper -32800 error code responses with enhanced error context and performance tracking.</p>
<p><strong>Error Response Enhancement</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Enhanced cancellation error with comprehensive context
#[derive(Debug, Clone)]
pub struct CancellationError {
    /// LSP error code (-32800 for RequestCancelled)
    pub code: i32,
    /// Human-readable error message
    pub message: String,
    /// Additional error context for debugging
    pub data: Option&lt;serde_json::Value&gt;,
    /// Provider that was cancelled
    pub provider: String,
    /// Cancellation latency for performance tracking
    pub latency: std::time::Duration,
    /// Request ID that was cancelled
    pub request_id: Value,
}

impl CancellationError {
    /// Create standard RequestCancelled error with context
    pub fn request_cancelled(
        provider: String,
        latency: std::time::Duration,
        request_id: Value,
    ) -&gt; Self {
        Self {
            code: -32800,
            message: format!("Request cancelled in {} provider", provider),
            data: Some(json!({
                "provider": provider,
                "latency_ms": latency.as_millis(),
                "request_id": request_id
            })),
            provider,
            latency,
            request_id,
        }
    }

    /// Create latency threshold exceeded error
    pub fn latency_threshold_exceeded(latency: std::time::Duration) -&gt; Self {
        Self {
            code: -32800,
            message: format!("Cancellation latency exceeded threshold: {}ms", latency.as_millis()),
            data: Some(json!({
                "latency_ms": latency.as_millis(),
                "threshold_exceeded": true
            })),
            provider: "cancellation_system".to_string(),
            latency,
            request_id: json!(null),
        }
    }
}

/// Enhanced error response creation with performance context
pub fn cancelled_response_with_context(
    id: &amp;Value,
    error: CancellationError,
) -&gt; JsonRpcResponse {
    JsonRpcResponse {
        jsonrpc: "2.0".to_string(),
        id: Some(id.clone()),
        result: None,
        error: Some(JsonRpcError {
            code: error.code,
            message: error.message,
            data: error.data,
        }),
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="performance-requirements"><a class="header" href="#performance-requirements">Performance Requirements</a></h2>
<h3 id="ac12-cancellation-overhead-specification"><a class="header" href="#ac12-cancellation-overhead-specification">AC12: Cancellation Overhead Specification</a></h3>
<p><strong>Performance Targets</strong>:</p>
<ul>
<li><strong>Cancellation Check Latency</strong>: &lt;100μs per check (well under 1ms requirement)</li>
<li><strong>Cancellation Response Time</strong>: &lt;50ms from notification to error response</li>
<li><strong>Memory Overhead</strong>: &lt;1MB additional memory usage for cancellation infrastructure</li>
<li><strong>Thread Contention</strong>: Zero lock contention for cancellation checks using atomic operations</li>
</ul>
<p><strong>Performance Validation Framework</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Performance tracking for cancellation operations
pub struct CancellationPerformanceTracker {
    /// Total cancellation checks performed
    check_count: AtomicU64,
    /// Total check latency for average calculation
    total_check_latency: AtomicU64,
    /// Maximum observed check latency
    max_check_latency: AtomicU64,
    /// Cancellation response times
    response_times: Arc&lt;Mutex&lt;Vec&lt;std::time::Duration&gt;&gt;&gt;,
}

impl CancellationPerformanceTracker {
    /// Record cancellation check latency
    pub fn record_check_latency(&amp;self, latency: std::time::Duration) {
        self.check_count.fetch_add(1, Ordering::Relaxed);
        self.total_check_latency.fetch_add(latency.as_nanos() as u64, Ordering::Relaxed);

        // Update maximum latency if this exceeds current max
        let latency_nanos = latency.as_nanos() as u64;
        self.max_check_latency.fetch_max(latency_nanos, Ordering::Relaxed);
    }

    /// Calculate average check latency
    pub fn average_check_latency(&amp;self) -&gt; std::time::Duration {
        let count = self.check_count.load(Ordering::Relaxed);
        let total = self.total_check_latency.load(Ordering::Relaxed);

        if count &gt; 0 {
            std::time::Duration::from_nanos(total / count)
        } else {
            std::time::Duration::from_nanos(0)
        }
    }

    /// Get performance metrics for validation
    pub fn get_metrics(&amp;self) -&gt; CancellationMetrics {
        CancellationMetrics {
            total_checks: self.check_count.load(Ordering::Relaxed),
            average_latency: self.average_check_latency(),
            max_latency: std::time::Duration::from_nanos(
                self.max_check_latency.load(Ordering::Relaxed)
            ),
            response_times: self.response_times.lock().unwrap().clone(),
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="integration-with-adaptive-threading-rust_test_threads2"><a class="header" href="#integration-with-adaptive-threading-rust_test_threads2">Integration with Adaptive Threading (RUST_TEST_THREADS=2)</a></h2>
<h3 id="ac10-thread-configuration-compatibility"><a class="header" href="#ac10-thread-configuration-compatibility">AC10: Thread Configuration Compatibility</a></h3>
<p><strong>Requirement</strong>: Enhanced compatibility with adaptive threading configuration, particularly <code>RUST_TEST_THREADS=2</code> environment.</p>
<p><strong>Adaptive Cancellation Configuration</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Adaptive cancellation configuration for different threading environments
pub struct AdaptiveCancellationConfig {
    /// Thread count from environment or default
    pub thread_count: usize,
    /// Cancellation check frequency based on thread contention
    pub check_frequency: usize,
    /// Timeout scaling factor for constrained environments
    pub timeout_multiplier: f32,
    /// Cancellation latency threshold adjustment
    pub latency_threshold: std::time::Duration,
}

impl AdaptiveCancellationConfig {
    /// Create configuration from environment variables
    pub fn from_environment() -&gt; Self {
        let thread_count = std::env::var("RUST_TEST_THREADS")
            .ok()
            .and_then(|s| s.parse().ok())
            .unwrap_or(num_cpus::get());

        let (check_frequency, timeout_multiplier, latency_threshold) = match thread_count {
            0..=2 =&gt; (
                25,   // More frequent checks in constrained environments
                3.0,  // 3x longer timeouts
                std::time::Duration::from_micros(500), // Higher latency tolerance
            ),
            3..=4 =&gt; (
                50,   // Moderate check frequency
                2.0,  // 2x longer timeouts
                std::time::Duration::from_micros(200),
            ),
            _ =&gt; (
                100,  // Standard check frequency
                1.0,  // Standard timeouts
                std::time::Duration::from_micros(100), // Strict latency requirement
            ),
        };

        Self {
            thread_count,
            check_frequency,
            timeout_multiplier,
            latency_threshold,
        }
    }

    /// Get cancellation check interval based on thread configuration
    pub fn check_interval(&amp;self, operation_count: usize) -&gt; bool {
        operation_count % self.check_frequency == 0
    }

    /// Get timeout with scaling factor applied
    pub fn scaled_timeout(&amp;self, base_timeout: std::time::Duration) -&gt; std::time::Duration {
        base_timeout.mul_f32(self.timeout_multiplier)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="error-handling-and-graceful-degradation"><a class="header" href="#error-handling-and-graceful-degradation">Error Handling and Graceful Degradation</a></h2>
<h3 id="ac5-multiple-concurrent-cancellation-handling"><a class="header" href="#ac5-multiple-concurrent-cancellation-handling">AC5: Multiple Concurrent Cancellation Handling</a></h3>
<p><strong>Requirement</strong>: Support for cancelling multiple concurrent requests without interference or resource contention.</p>
<p><strong>Concurrent Cancellation Management</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Thread-safe cancellation registry for managing multiple concurrent cancellations
pub struct CancellationRegistry {
    /// Active cancellation tokens indexed by request ID
    tokens: Arc&lt;RwLock&lt;HashMap&lt;Value, Arc&lt;PerlLspCancellationToken&gt;&gt;&gt;&gt;,
    /// Performance tracking across all cancellations
    performance_tracker: Arc&lt;CancellationPerformanceTracker&gt;,
    /// Configuration for adaptive threading
    config: AdaptiveCancellationConfig,
}

impl CancellationRegistry {
    /// Register new cancellation token
    pub fn register_token(
        &amp;self,
        request_id: Value,
        provider_context: ProviderCleanupContext,
    ) -&gt; Arc&lt;PerlLspCancellationToken&gt; {
        let token = Arc::new(PerlLspCancellationToken::new(
            request_id.clone(),
            provider_context,
            Some(self.config.latency_threshold),
        ));

        self.tokens.write().unwrap().insert(request_id, token.clone());
        token
    }

    /// Cancel specific request and cleanup resources
    pub fn cancel_request(&amp;self, request_id: &amp;Value) -&gt; Result&lt;(), CancellationError&gt; {
        let start = std::time::Instant::now();

        if let Some(token) = self.tokens.read().unwrap().get(request_id) {
            token.cancel_with_cleanup()?;

            // Remove from registry
            self.tokens.write().unwrap().remove(request_id);

            // Track performance
            let latency = start.elapsed();
            self.performance_tracker.record_check_latency(latency);

            Ok(())
        } else {
            // Request not found or already completed
            Ok(())
        }
    }

    /// Cancel multiple requests efficiently
    pub fn cancel_multiple_requests(
        &amp;self,
        request_ids: &amp;[Value],
    ) -&gt; Vec&lt;Result&lt;(), CancellationError&gt;&gt; {
        request_ids.iter()
            .map(|id| self.cancel_request(id))
            .collect()
    }

    /// Cleanup completed requests to prevent memory leaks
    pub fn cleanup_completed_requests(&amp;self) {
        self.tokens.write().unwrap().retain(|_, token| {
            !token.is_cancelled()
        });
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementation-integration-points"><a class="header" href="#implementation-integration-points">Implementation Integration Points</a></h2>
<h3 id="lsp-server-integration"><a class="header" href="#lsp-server-integration">LSP Server Integration</a></h3>
<p><strong>Enhanced LSP Server with Cancellation Registry</strong>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Enhanced LspServer with comprehensive cancellation support
impl LspServer {
    /// Initialize cancellation registry with adaptive configuration
    pub fn new_with_cancellation() -&gt; Self {
        let config = AdaptiveCancellationConfig::from_environment();
        let cancellation_registry = Arc::new(CancellationRegistry::new(config));

        Self {
            // ... existing fields ...
            cancellation_registry,
            // ... other fields ...
        }
    }

    /// Enhanced request handling with provider-aware cancellation
    pub fn handle_request_with_cancellation(
        &amp;mut self,
        request: JsonRpcRequest
    ) -&gt; Option&lt;JsonRpcResponse&gt; {
        let id = request.id.clone();

        // Handle $/cancelRequest with enhanced context
        if request.method == "$/cancelRequest" {
            return self.handle_cancellation_request(request);
        }

        // Register cancellation token for trackable requests
        let cancellation_token = if let Some(ref request_id) = id {
            let provider_context = self.determine_provider_context(&amp;request.method);
            Some(self.cancellation_registry.register_token(
                request_id.clone(),
                provider_context,
            ))
        } else {
            None
        };

        // Check for existing cancellation before processing
        if let Some(ref request_id) = id {
            if let Some(token) = cancellation_token.as_ref() {
                if token.is_cancelled() {
                    return Some(cancelled_response_with_context(
                        request_id,
                        CancellationError::request_cancelled(
                            request.method.clone(),
                            std::time::Duration::from_nanos(0),
                            request_id.clone(),
                        ),
                    ));
                }
            }
        }

        // Process request with cancellation token
        self.process_request_with_token(request, cancellation_token)
    }

    /// Enhanced cancellation request handling
    fn handle_cancellation_request(
        &amp;mut self,
        request: JsonRpcRequest
    ) -&gt; Option&lt;JsonRpcResponse&gt; {
        if let Some(params) = request.params.as_ref() {
            if let Some(cancel_id) = params.get("id") {
                if let Err(error) = self.cancellation_registry.cancel_request(cancel_id) {
                    eprintln!("Cancellation error: {:?}", error);
                }
            }
        }
        None // Notifications don't get responses per LSP spec
    }

    /// Determine provider context from LSP method
    fn determine_provider_context(&amp;self, method: &amp;str) -&gt; ProviderCleanupContext {
        match method {
            "textDocument/completion" =&gt; ProviderCleanupContext::Completion {
                workspace_symbols: true,
                cross_file: true,
            },
            "workspace/symbol" =&gt; ProviderCleanupContext::WorkspaceSymbol {
                indexing_active: true,
                file_count: self.workspace_index.file_count(),
            },
            "textDocument/references" =&gt; ProviderCleanupContext::References {
                qualified_search: true,
                dual_pattern: true,
            },
            "textDocument/definition" =&gt; ProviderCleanupContext::Definition {
                parsing_active: true,
                file_uri: None,
            },
            "textDocument/hover" =&gt; ProviderCleanupContext::Hover {
                doc_resolution: true,
            },
            _ =&gt; ProviderCleanupContext::Generic,
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="backward-compatibility-and-migration"><a class="header" href="#backward-compatibility-and-migration">Backward Compatibility and Migration</a></h2>
<h3 id="compatibility-requirements"><a class="header" href="#compatibility-requirements">Compatibility Requirements</a></h3>
<p><strong>Existing API Preservation</strong>:</p>
<ul>
<li>All existing <code>cancel_mark</code>, <code>cancel_clear</code>, and <code>is_cancelled</code> methods remain functional</li>
<li><code>early_cancel_or!</code> macro continues to work with enhanced token system</li>
<li>No breaking changes to LSP client interfaces</li>
<li>Graceful fallback to basic cancellation if enhanced features unavailable</li>
</ul>
<p><strong>Migration Strategy</strong>:</p>
<ol>
<li><strong>Phase 1</strong>: Deploy enhanced cancellation infrastructure alongside existing system</li>
<li><strong>Phase 2</strong>: Migrate LSP providers to use enhanced cancellation tokens</li>
<li><strong>Phase 3</strong>: Enable performance tracking and adaptive threading integration</li>
<li><strong>Phase 4</strong>: Deprecate legacy cancellation methods while maintaining compatibility</li>
</ol>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>This LSP Cancellation Protocol Compliance Specification provides a comprehensive enhancement framework for Issue #48, addressing all acceptance criteria while maintaining full backward compatibility. The specification ensures &lt;1ms cancellation overhead, thread-safe operations with atomic primitives, and comprehensive LSP provider integration.</p>
<p>Key architectural benefits:</p>
<ul>
<li><strong>Performance</strong>: Atomic operations eliminate lock contention for cancellation checks</li>
<li><strong>Scalability</strong>: Adaptive threading configuration optimizes for different environments</li>
<li><strong>Reliability</strong>: Provider-specific cleanup ensures graceful resource management</li>
<li><strong>Maintainability</strong>: Clear separation of concerns and comprehensive error handling</li>
<li><strong>Compatibility</strong>: Full LSP 3.17+ protocol compliance with enhanced context</li>
</ul>
<p>The enhanced cancellation system integrates seamlessly with the existing Perl LSP ecosystem, preserving ~100% Perl syntax coverage, incremental parsing performance, and enterprise security standards while providing robust cancellation capabilities across all LSP providers.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../lsp/feature-implementation.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../lsp/error-handling.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../lsp/feature-implementation.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../lsp/error-handling.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
