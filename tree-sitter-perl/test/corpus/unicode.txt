==========================================
Unicode identifiers
==========================================

use utf8;

my $caf√© = "coffee";
my $œÄ = 3.14159;
my $Œî = 0.001;
my $–ø—Ä–∏–≤–µ—Ç = "hello";
my $„Åì„Çì„Å´„Å°„ÅØ = "hello";
my $üê™ = "camel";

sub Œ£ {
    my $sum = 0;
    $sum += $_ for @_;
    return $sum;
}

package Œ©::Module;

---

(source_file
  (use_statement
    (identifier))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (float))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (float))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (subroutine_declaration_statement
    (identifier)
    (block
      (assignment_expression
        (variable_declaration
          (scalar_variable))
        (assignment_operator)
        (integer))
      (postfix_expression
        (augmented_assignment_expression
          (scalar_variable)
          (assignment_operator)
          (special_scalar_variable))
        (postfix_operator)
        (special_array_variable))
      (return_expression
        (scalar_variable))))
  (package_statement
    (qualified_name)))

==========================================
Unicode in strings
==========================================

my $string = "caf√©";
my $quoted = "She said, "Hello!"";
my $emoji = "Perl üê™ is fun! üéâ";
my $mixed = "ASCII and Œ∫Œ±ŒªŒ∑ŒºŒ≠œÅŒ± and ‰Ω†Â•Ω";
my $escaped = "\x{263A} \x{1F42A} \x{2764}";
my $named = "\N{LATIN SMALL LETTER E WITH ACUTE}";
my $combining = "e\x{0301}";

---

(source_file
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content))))

==========================================
Unicode in regex
==========================================

/caf√©/;
/\x{263A}/;
/\p{Greek}/;
/\p{Script=Arabic}/;
/[Œ±-œâ]/;
/\N{SNOWMAN}/;
/[üê™üê´üê≠üêπ]/;

$text =~ s/caf√©/coffee/g;
$text =~ /Œ∫Œ±œÜŒ≠/i;

---

(source_file
  (expression_statement
    (match_regexp
      (regexp_content)))
  (expression_statement
    (match_regexp
      (regexp_content
        (escape_sequence))))
  (expression_statement
    (match_regexp
      (regexp_content
        (escape_sequence))))
  (expression_statement
    (match_regexp
      (regexp_content
        (escape_sequence))))
  (expression_statement
    (match_regexp
      (regexp_content)))
  (expression_statement
    (match_regexp
      (regexp_content
        (escape_sequence))))
  (expression_statement
    (match_regexp
      (regexp_content)))
  (expression_statement
    (binary_expression
      (scalar
        (varname))
      (substitution_regexp
        (regexp_content)
        (replacement)
        (substitution_regexp_modifiers))))
  (expression_statement
    (binary_expression
      (scalar
        (varname))
      (match_regexp
        (regexp_content)
        (match_regexp_modifiers)))))

==========================================
Encoding pragmas
==========================================

use utf8;
no utf8;
use encoding 'utf8';
use open ':utf8';
use open IN => ':utf8';
use open OUT => ':utf8';
use open ':std', ':utf8';
use open IO => ':encoding(UTF-8)';

binmode(STDOUT, ":utf8");
binmode(STDIN, ":encoding(UTF-8)");

---

(source_file
  (use_statement
    (package))
  (use_statement
    (package))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (list_expression
      (autoquoted_bareword)
      (string_literal
        (string_content))))
  (use_statement
    (package)
    (list_expression
      (autoquoted_bareword)
      (string_literal
        (string_content))))
  (use_statement
    (package)
    (list_expression
      (string_literal
        (string_content))
      (string_literal
        (string_content))))
  (use_statement
    (package)
    (list_expression
      (autoquoted_bareword)
      (string_literal
        (string_content))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (interpolated_string_literal
          (string_content))))))

==========================================
Unicode normalization
==========================================

use Unicode::Normalize;

my $nfc = NFC($string);
my $nfd = NFD($string);
my $nfkc = NFKC($string);
my $nfkd = NFKD($string);

my $composed = "\x{00E9}";
my $decomposed = "\x{0065}\x{0301}";

if (NFC($composed) eq NFC($decomposed)) {
    print "Equivalent\n";
}

---

(source_file
  (use_statement
    (package))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (scalar
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (scalar
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (scalar
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (scalar
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (interpolated_string_literal
        (string_content
          (escape_sequence)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (interpolated_string_literal
        (string_content
          (escape_sequence)
          (escape_sequence)))))
  (conditional_statement
    (equality_expression
      (function_call_expression
        (function)
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (scalar
          (varname))))
    (block
      (expression_statement
        (ambiguous_function_call_expression
          (function)
          (interpolated_string_literal
            (string_content
              (escape_sequence))))))))

==========================================
Unicode properties in identifiers
==========================================

use utf8;

my $‚Ñµ‚ÇÄ = "aleph null";
my $x¬≤ = "x squared";
my $H‚ÇÇO = "water";
my $Œ£‚Åø = "sum";
my $‚à´∆í = "integral";
my $‚àö2 = 1.414;
my $‚àû = "infinity";

sub Œ±_Œ≤_Œ≥ {
    return "Greek";
}

---

(source_file
  (use_statement
    (identifier))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (float))
  (assignment_expression
    (variable_declaration
      (scalar_variable))
    (assignment_operator)
    (string_literal
      (string_content)))
  (subroutine_declaration_statement
    (identifier)
    (block
      (return_expression
        (string_literal
          (string_content))))))

==========================================
Unicode case operations
==========================================

use utf8;

my $lower = lc("CAF√â");
my $upper = uc("caf√©");
my $title = ucfirst("√©cole");
my $folded = fc("Stra√üe");

my $greek_lower = lc("ŒëŒíŒìŒî");
my $greek_upper = uc("Œ±Œ≤Œ≥Œ¥");

---

(source_file
  (use_statement
    (package))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func1op_call_expression
        (interpolated_string_literal
          (string_content))))))
