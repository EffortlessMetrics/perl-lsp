==================
Indirect object syntax
==================

new Point 1, 2;
new Point(1, 2);
new Point;

print FH "line\n";
print STDERR "error\n";
printf FH "%s\n", $data;

close FH;
open FH, $file;

method Object @args;
invoke Package 'arg';

---

(source_file
  (statement)
  (statement)
  (statement)
  (statement)
  (statement)
  (statement)
  (statement)
  (statement)
  (statement)
  (statement))

==================
No indirect pragma
==================

no indirect;
new Point;  # Still parses, runtime error

no indirect 'fatal';
new Widget;  # Still parses, dies at runtime

use indirect;
new Object;  # Allowed again

---

(source_file
  (use_statement
    (package))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (bareword)))
  (comment)
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (bareword)))
  (comment)
  (use_statement
    (package))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (bareword)))
  (comment))

==================
CORE namespace overrides
==================

*CORE::GLOBAL::open = sub { die "blocked" };
*CORE::GLOBAL::die = \&my_die;
*CORE::GLOBAL::exit = sub { print "intercepted exit\n" };

CORE::open(my $fh, "<", $file);
CORE::print("using core print\n");
CORE::die("using core die\n");

&CORE::open($fh, $file);
&CORE::close($fh);

---

(source_file
  (expression_statement
    (assignment_expression
      (glob
        (varname))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content))))))))
  (expression_statement
    (assignment_expression
      (glob
        (varname))
      (refgen_expression
        (function
          (varname)))))
  (expression_statement
    (assignment_expression
      (glob
        (varname))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (escape_sequence)))))))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (variable_declaration
          (scalar
            (varname)))
        (interpolated_string_literal
          (string_content))
        (scalar
          (varname)))))
  (expression_statement
    (function_call_expression
      (function)
      (interpolated_string_literal
        (string_content
          (escape_sequence)))))
  (expression_statement
    (function_call_expression
      (function)
      (interpolated_string_literal
        (string_content
          (escape_sequence)))))
  (expression_statement
    (function_call_expression
      (function
        (varname))
      (list_expression
        (scalar
          (varname))
        (scalar
          (varname)))))
  (expression_statement
    (function_call_expression
      (function
        (varname))
      (scalar
        (varname)))))

==================
Package VERSION syntax
==================

package My::Module 1.23;
package My::Module v1.2.3;
package My::Module 1.23 { }
package My::Module v1.2.3 { }

our $VERSION = '1.23';
our $VERSION = 1.23;
our $VERSION = v1.2.3;
our $VERSION = qv('1.2.3');

---

(source_file
  (package_statement
    (package)
    (number))
  (package_statement
    (package)
    (version))
  (package_statement
    (package)
    (number)
    (block))
  (package_statement
    (package)
    (version)
    (block))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (string_literal
        (string_content))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (number)))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (ambiguous_function_call_expression
        (function)
        (binary_expression
          (number)
          (number)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (string_literal
          (string_content))))))

==================
__SUB__ token
==================

sub factorial {
    my $n = shift;
    return 1 if $n <= 1;
    return $n * __SUB__->($n - 1);
}

my $code = sub {
    my $self = __SUB__;
    return $self;
};

sub wrapper {
    my $orig = __SUB__;
    return sub { $orig->(@_) };
}

---

(source_file
  (subroutine_declaration_statement
    (bareword)
    (block
      (expression_statement
        (assignment_expression
          (variable_declaration
            (scalar
              (varname)))
          (func1op_call_expression)))
      (expression_statement
        (postfix_conditional_expression
          (return_expression
            (number))
          (relational_expression
            (scalar
              (varname))
            (number))))
      (expression_statement
        (return_expression
          (binary_expression
            (scalar
              (varname))
            (coderef_call_expression
              (func0op_call_expression)
              (binary_expression
                (scalar
                  (varname))
                (number))))))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (variable_declaration
                (scalar
                  (varname)))
              (func0op_call_expression)))
          (expression_statement
            (return_expression
              (scalar
                (varname))))))))
  (subroutine_declaration_statement
    (bareword)
    (block
      (expression_statement
        (assignment_expression
          (variable_declaration
            (scalar
              (varname)))
          (func0op_call_expression)))
      (expression_statement
        (return_expression
          (anonymous_subroutine_expression
            (block
              (expression_statement
                (coderef_call_expression
                  (scalar
                    (varname))
                  (array
                    (varname)))))))))))

==================
Sort with custom comparators
==================

my @sorted = sort @list;
my @sorted = sort { $a cmp $b } @list;
my @sorted = sort { $a <=> $b } @list;
my @sorted = sort { $b cmp $a } @list;

my @complex = sort {
    $a->{priority} <=> $b->{priority}
        ||
    $a->{name} cmp $b->{name}
} @items;

my @sorted = sort mysort @list;
my @sorted = sort Package::compare @list;

---

(source_file
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (block
          (expression_statement
            (equality_expression
              (scalar
                (varname))
              (scalar
                (varname)))))
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (block
          (expression_statement
            (equality_expression
              (scalar
                (varname))
              (scalar
                (varname)))))
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (block
          (expression_statement
            (equality_expression
              (scalar
                (varname))
              (scalar
                (varname)))))
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (block
          (expression_statement
            (binary_expression
              (equality_expression
                (hash_element_expression
                  (scalar
                    (varname))
                  (autoquoted_bareword))
                (hash_element_expression
                  (scalar
                    (varname))
                  (autoquoted_bareword)))
              (equality_expression
                (hash_element_expression
                  (scalar
                    (varname))
                  (autoquoted_bareword))
                (hash_element_expression
                  (scalar
                    (varname))
                  (autoquoted_bareword))))))
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (function)
        (array
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (array
          (varname)))
      (sort_expression
        (function)
        (array
          (varname))))))

==================
Sort pragmas
==================

use sort 'stable';
use sort 'defaults';
use sort '_quicksort';
use sort '_mergesort';

no sort 'stable';

use sort 'stable', '_mergesort';

{
    use sort 'stable';
    my @sorted = sort { $a <=> $b } @nums;
}

---

(source_file
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (string_literal
      (string_content)))
  (use_statement
    (package)
    (list_expression
      (string_literal
        (string_content))
      (string_literal
        (string_content))))
  (block_statement
    (use_statement
      (package)
      (string_literal
        (string_content)))
    (expression_statement
      (assignment_expression
        (variable_declaration
          (array
            (varname)))
        (sort_expression
          (block
            (expression_statement
              (equality_expression
                (scalar
                  (varname))
                (scalar
                  (varname)))))
          (array
            (varname)))))))

==================
CORE with prototypes
==================

CORE::push(@array, $item);
CORE::pop(@array);
CORE::shift(@array);
CORE::unshift(@array, @items);

CORE::substr($string, 0, 5);
CORE::index($string, "pattern");
CORE::sprintf("%d", $number);

CORE::ref($var);
CORE::defined($var);
CORE::undef($var);

---

(source_file
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (array
          (varname))
        (scalar
          (varname)))))
  (expression_statement
    (function_call_expression
      (function)
      (array
        (varname))))
  (expression_statement
    (function_call_expression
      (function)
      (array
        (varname))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (array
          (varname))
        (array
          (varname)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (scalar
          (varname))
        (number)
        (number))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (scalar
          (varname))
        (interpolated_string_literal
          (string_content)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (interpolated_string_literal
          (string_content))
        (scalar
          (varname)))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname)))))

==================
Version comparisons
==================

use 5.036;
use v5.36.0;
require 5.010;
require v5.10.0;

if ($] >= 5.036) {
    use feature 'signatures';
}

if ($^V ge v5.36.0) {
    say "Modern Perl";
}

BEGIN { require 5.008 }

---

(source_file
  (use_version_statement
    (number))
  (use_version_statement
    (version))
  (expression_statement
    (require_version_expression
      (number)))
  (expression_statement
    (require_version_expression
      (version)))
  (conditional_statement
    (relational_expression
      (scalar
        (varname))
      (number))
    (block
      (use_statement
        (package)
        (string_literal
          (string_content)))))
  (conditional_statement
    (relational_expression
      (scalar
        (varname))
      (ambiguous_function_call_expression
        (function)
        (binary_expression
          (number)
          (number))))
    (block
      (expression_statement
        (ambiguous_function_call_expression
          (function)
          (interpolated_string_literal
            (string_content))))))
  (phaser_statement
    (block
      (expression_statement
        (require_version_expression
          (number))))))

==================
UNIVERSAL methods
==================

UNIVERSAL::isa($obj, 'Class');
UNIVERSAL::can($obj, 'method');
UNIVERSAL::DOES($obj, 'Role');
UNIVERSAL::VERSION($obj);

$obj->UNIVERSAL::isa('Class');
$obj->UNIVERSAL::can('method');
$obj->UNIVERSAL::DOES('Role');

*UNIVERSAL::new_method = sub { };

---

(source_file
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (scalar
          (varname))
        (string_literal
          (string_content)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (scalar
          (varname))
        (string_literal
          (string_content)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (scalar
          (varname))
        (string_literal
          (string_content)))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname))))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (string_literal
        (string_content))))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (string_literal
        (string_content))))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (string_literal
        (string_content))))
  (expression_statement
    (assignment_expression
      (glob
        (varname))
      (anonymous_subroutine_expression
        (block)))))
