==================
Basic signal handlers
==================

$SIG{INT} = sub { 
    print "Interrupted!\n";
    exit 1;
};

$SIG{TERM} = \&cleanup;

$SIG{HUP} = 'IGNORE';
$SIG{PIPE} = 'DEFAULT';

$SIG{ALRM} = sub { die "Timeout\n" };
alarm 10;

$SIG{CHLD} = 'IGNORE';

---

(source_file
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (escape_sequence)))))
          (expression_statement
            (func1op_call_expression
              (number)))))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (refgen_expression
        (function
          (varname)))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (string_literal
        (string_content))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (string_literal
        (string_content))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (escape_sequence)))))))))
  (expression_statement
    (func1op_call_expression
      (number)))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (string_literal
        (string_content)))))

==================
DIE and WARN handlers
==================

$SIG{__DIE__} = sub {
    my $msg = shift;
    print STDERR "Fatal: $msg";
    print STDERR Carp::longmess();
    exit 255;
};

$SIG{__WARN__} = sub {
    my $msg = shift;
    return if $msg =~ /Use of uninitialized/;
    print STDERR "Warning: $msg";
    print STDERR Carp::shortmess();
};

local $SIG{__DIE__} = sub {
    my $error = shift;
    log_error($error);
    die $error;
};

---

(source_file
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (variable_declaration
                (scalar
                  (varname)))
              (func1op_call_expression)))
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (ambiguous_function_call_expression
                (function)
                (interpolated_string_literal
                  (string_content
                    (scalar
                      (varname)))))))
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (ambiguous_function_call_expression
                (function)
                (function_call_expression
                  (function)))))
          (expression_statement
            (func1op_call_expression
              (number)))))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (variable_declaration
                (scalar
                  (varname)))
              (func1op_call_expression)))
          (expression_statement
            (postfix_conditional_expression
              (return_expression)
              (binary_expression
                (scalar
                  (varname))
                (match_regexp
                  (regexp_content)))))
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (ambiguous_function_call_expression
                (function)
                (interpolated_string_literal
                  (string_content
                    (scalar
                      (varname)))))))
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (ambiguous_function_call_expression
                (function)
                (function_call_expression
                  (function)))))))))
  (expression_statement
    (assignment_expression
      (localization_expression
        (hash_element_expression
          (container_variable
            (varname))
          (autoquoted_bareword)))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (variable_declaration
                (scalar
                  (varname)))
              (func1op_call_expression)))
          (expression_statement
            (function_call_expression
              (function)
              (scalar
                (varname))))
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (scalar
                (varname)))))))))

==================
Safe signal handling
==================

use POSIX qw(:signal_h);

my $sigset = POSIX::SigSet->new;
$sigset->addset(SIGINT);
$sigset->addset(SIGTERM);

sigprocmask(SIG_BLOCK, $sigset);
# Critical section
sigprocmask(SIG_UNBLOCK, $sigset);

my $action = POSIX::SigAction->new(
    sub { print "Signal received\n" },
    $sigset,
    SA_RESTART
);

sigaction(SIGINT, $action);

---

(source_file
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (method_call_expression
        (bareword)
        (method))))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (bareword)))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (bareword)))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (scalar
          (varname)))))
  (comment)
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (scalar
          (varname)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (method_call_expression
        (bareword)
        (method)
        (list_expression
          (anonymous_subroutine_expression
            (block
              (expression_statement
                (ambiguous_function_call_expression
                  (function)
                  (interpolated_string_literal
                    (string_content
                      (escape_sequence)))))))
          (scalar
            (varname))
          (bareword)))))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (scalar
          (varname))))))

==================
SIGCHLD handling
==================

$SIG{CHLD} = sub {
    while ((my $pid = waitpid(-1, WNOHANG)) > 0) {
        print "Child $pid exited with status $?\n";
        delete $children{$pid};
    }
};

use POSIX ":sys_wait_h";

$SIG{CHLD} = sub {
    my $pid;
    do {
        $pid = waitpid(-1, WNOHANG);
        if (WIFEXITED($?)) {
            my $exit_code = WEXITSTATUS($?);
            print "Child $pid exited with code $exit_code\n";
        } elsif (WIFSIGNALED($?)) {
            my $signal = WTERMSIG($?);
            print "Child $pid killed by signal $signal\n";
        }
    } while $pid > 0;
};

---

(source_file
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (loop_statement
            (relational_expression
              (assignment_expression
                (variable_declaration
                  (scalar
                    (varname)))
                (function_call_expression
                  (function)
                  (list_expression
                    (unary_expression
                      (number))
                    (bareword))))
              (number))
            (block
              (expression_statement
                (ambiguous_function_call_expression
                  (function)
                  (interpolated_string_literal
                    (string_content
                      (scalar
                        (varname))
                      (scalar
                        (varname))
                      (escape_sequence)))))
              (expression_statement
                (func1op_call_expression
                  (hash_element_expression
                    (container_variable
                      (varname))
                    (scalar
                      (varname)))))))))))
  (use_statement
    (package)
    (interpolated_string_literal
      (string_content)))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (variable_declaration
              (scalar
                (varname))))
          (expression_statement
            (postfix_loop_expression
              (do_expression
                (block
                  (expression_statement
                    (assignment_expression
                      (scalar
                        (varname))
                      (function_call_expression
                        (function)
                        (list_expression
                          (unary_expression
                            (number))
                          (bareword)))))
                  (conditional_statement
                    (function_call_expression
                      (function)
                      (scalar
                        (varname)))
                    (block
                      (expression_statement
                        (assignment_expression
                          (variable_declaration
                            (scalar
                              (varname)))
                          (function_call_expression
                            (function)
                            (scalar
                              (varname)))))
                      (expression_statement
                        (ambiguous_function_call_expression
                          (function)
                          (interpolated_string_literal
                            (string_content
                              (scalar
                                (varname))
                              (scalar
                                (varname))
                              (escape_sequence))))))
                    (elsif
                      (function_call_expression
                        (function)
                        (scalar
                          (varname)))
                      (block
                        (expression_statement
                          (assignment_expression
                            (variable_declaration
                              (scalar
                                (varname)))
                            (function_call_expression
                              (function)
                              (scalar
                                (varname)))))
                        (expression_statement
                          (ambiguous_function_call_expression
                            (function)
                            (interpolated_string_literal
                              (string_content
                                (scalar
                                  (varname))
                                (scalar
                                  (varname))
                                (escape_sequence))))))))))
              (relational_expression
                (scalar
                  (varname))
                (number)))))))))

==================
Signal sets and masks
==================

use POSIX qw(:signal_h);

my $oldset = POSIX::SigSet->new;
my $newset = POSIX::SigSet->new;

$newset->fillset();
$newset->delset(SIGALRM);

sigprocmask(SIG_SETMASK, $newset, $oldset);

if ($newset->ismember(SIGINT)) {
    print "SIGINT is in the set\n";
}

sigsuspend($newset);
sigpending($oldset);

---

(source_file
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (method_call_expression
        (bareword)
        (method))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (method_call_expression
        (bareword)
        (method))))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)))
  (expression_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (bareword)))
  (expression_statement
    (function_call_expression
      (function)
      (list_expression
        (bareword)
        (scalar
          (varname))
        (scalar
          (varname)))))
  (conditional_statement
    (method_call_expression
      (scalar
        (varname))
      (method)
      (bareword))
    (block
      (expression_statement
        (ambiguous_function_call_expression
          (function)
          (interpolated_string_literal
            (string_content
              (escape_sequence)))))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname))))
  (expression_statement
    (function_call_expression
      (function)
      (scalar
        (varname)))))

==================
Alarm and timeout
==================

eval {
    local $SIG{ALRM} = sub { die "timeout\n" };
    alarm 5;
    # Long running operation
    my $result = slow_operation();
    alarm 0;
    return $result;
};
alarm 0;
if ($@ && $@ eq "timeout\n") {
    handle_timeout();
}

use Time::HiRes qw(alarm);
alarm 2.5;  # 2.5 seconds

$SIG{ALRM} = sub {
    die "Timed out after $timeout seconds\n";
};

---

(source_file
  (expression_statement
    (eval_expression
      (block
        (expression_statement
          (assignment_expression
            (localization_expression
              (hash_element_expression
                (container_variable
                  (varname))
                (autoquoted_bareword)))
            (anonymous_subroutine_expression
              (block
                (expression_statement
                  (ambiguous_function_call_expression
                    (function)
                    (interpolated_string_literal
                      (string_content
                        (escape_sequence)))))))))
        (expression_statement
          (func1op_call_expression
            (number)))
        (comment)
        (expression_statement
          (assignment_expression
            (variable_declaration
              (scalar
                (varname)))
            (function_call_expression
              (function))))
        (expression_statement
          (func1op_call_expression
            (number)))
        (expression_statement
          (return_expression
            (scalar
              (varname)))))))
  (expression_statement
    (func1op_call_expression
      (number)))
  (conditional_statement
    (binary_expression
      (scalar
        (varname))
      (equality_expression
        (scalar
          (varname))
        (interpolated_string_literal
          (string_content
            (escape_sequence)))))
    (block
      (expression_statement
        (function_call_expression
          (function)))))
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (expression_statement
    (func1op_call_expression
      (number)))
  (comment)
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (scalar
                    (varname))
                  (escape_sequence))))))))))

==================
Signal in fork
==================

my $pid = fork();
if (!defined $pid) {
    die "Cannot fork: $!";
} elsif ($pid == 0) {
    # Child process
    $SIG{INT} = 'DEFAULT';
    $SIG{TERM} = sub { 
        cleanup_child();
        exit 0;
    };
    exec(@command) or die "exec failed: $!";
} else {
    # Parent process
    $SIG{INT} = sub {
        kill 'TERM', $pid;
        waitpid($pid, 0);
        exit 1;
    };
    waitpid($pid, 0);
}

---

(source_file
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (func0op_call_expression)))
  (conditional_statement
    (unary_expression
      (func1op_call_expression
        (scalar
          (varname))))
    (block
      (expression_statement
        (ambiguous_function_call_expression
          (function)
          (interpolated_string_literal
            (string_content
              (scalar
                (varname)))))))
    (elsif
      (equality_expression
        (scalar
          (varname))
        (number))
      (block
        (comment)
        (expression_statement
          (assignment_expression
            (hash_element_expression
              (container_variable
                (varname))
              (autoquoted_bareword))
            (string_literal
              (string_content))))
        (expression_statement
          (assignment_expression
            (hash_element_expression
              (container_variable
                (varname))
              (autoquoted_bareword))
            (anonymous_subroutine_expression
              (block
                (expression_statement
                  (function_call_expression
                    (function)))
                (expression_statement
                  (func1op_call_expression
                    (number)))))))
        (expression_statement
          (lowprec_logical_expression
            (function_call_expression
              (function)
              (array
                (varname)))
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (scalar
                    (varname))))))))
      (else
        (block
          (comment)
          (expression_statement
            (assignment_expression
              (hash_element_expression
                (container_variable
                  (varname))
                (autoquoted_bareword))
              (anonymous_subroutine_expression
                (block
                  (expression_statement
                    (ambiguous_function_call_expression
                      (function)
                      (list_expression
                        (string_literal
                          (string_content))
                        (scalar
                          (varname)))))
                  (expression_statement
                    (function_call_expression
                      (function)
                      (list_expression
                        (scalar
                          (varname))
                        (number))))
                  (expression_statement
                    (func1op_call_expression
                      (number)))))))
          (expression_statement
            (function_call_expression
              (function)
              (list_expression
                (scalar
                  (varname))
                (number)))))))))

==================
Signal handling in loops
==================

my $continue = 1;
$SIG{INT} = sub { $continue = 0 };
$SIG{TERM} = sub { $continue = 0 };

while ($continue) {
    do_work();
    
    if ($got_sighup) {
        reload_config();
        $got_sighup = 0;
    }
}

$SIG{HUP} = sub { $got_sighup = 1 };

for (my $i = 0; $continue && $i < 100; $i++) {
    process($i);
}

---

(source_file
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (number)))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (scalar
                (varname))
              (number)))))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (scalar
                (varname))
              (number)))))))
  (loop_statement
    (scalar
      (varname))
    (block
      (expression_statement
        (function_call_expression
          (function)))
      (conditional_statement
        (scalar
          (varname))
        (block
          (expression_statement
            (function_call_expression
              (function)))
          (expression_statement
            (assignment_expression
              (scalar
                (varname))
              (number)))))))
  (expression_statement
    (assignment_expression
      (hash_element_expression
        (container_variable
          (varname))
        (autoquoted_bareword))
      (anonymous_subroutine_expression
        (block
          (expression_statement
            (assignment_expression
              (scalar
                (varname))
              (number)))))))
  (cstyle_for_statement
    (expression_statement
      (assignment_expression
        (variable_declaration
          (scalar
            (varname)))
        (number)))
    (expression_statement
      (binary_expression
        (scalar
          (varname))
        (relational_expression
          (scalar
            (varname))
          (number))))
    (postinc_expression
      (scalar
        (varname)))
    (block
      (expression_statement
        (function_call_expression
          (function)
          (scalar
            (varname)))))))

==================
Deferred signals
==================

use sigtrap qw(die normal-signals);

use sigtrap 'handler' => \&my_handler, 'normal-signals';

use sigtrap qw(
    die     untrapped
    handler my_handler INT QUIT
    stack-trace any SEGV BUS
);

BEGIN {
    use Config;
    if ($Config{d_sigaction}) {
        print "Safe signals are available\n";
    }
}

---

(source_file
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (use_statement
    (package)
    (list_expression
      (string_literal
        (string_content))
      (refgen_expression
        (function
          (varname)))
      (string_literal
        (string_content))))
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (phaser_statement
    (block
      (use_statement
        (package))
      (conditional_statement
        (hash_element_expression
          (container_variable
            (varname))
          (autoquoted_bareword))
        (block
          (expression_statement
            (ambiguous_function_call_expression
              (function)
              (interpolated_string_literal
                (string_content
                  (escape_sequence))))))))))

==================
IPC signals
==================

use IPC::Signal qw(sig_num sig_name);

my $signum = sig_num('HUP');
my $signame = sig_name(1);

kill 'USR1', $pid;
kill USR1 => $pid;
kill -USR1 => $pgrp;
kill 0, $pid;  # Check if process exists

my $count = kill 0, @pids;

if (kill 0, $pid) {
    print "Process $pid is alive\n";
}

raise(SIGTERM);

---

(source_file
  (use_statement
    (package)
    (quoted_word_list
      (string_content)))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (string_literal
          (string_content)))))
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (function_call_expression
        (function)
        (number))))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (list_expression
        (string_literal
          (string_content))
        (scalar
          (varname)))))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (list_expression
        (autoquoted_bareword)
        (scalar
          (varname)))))
  (expression_statement
    (list_expression
      (binary_expression
        (bareword)
        (autoquoted_bareword))
      (scalar
        (varname))))
  (expression_statement
    (ambiguous_function_call_expression
      (function)
      (list_expression
        (number)
        (scalar
          (varname)))))
  (comment)
  (expression_statement
    (assignment_expression
      (variable_declaration
        (scalar
          (varname)))
      (ambiguous_function_call_expression
        (function)
        (list_expression
          (number)
          (array
            (varname))))))
  (conditional_statement
    (ambiguous_function_call_expression
      (function)
      (list_expression
        (number)
        (scalar
          (varname))))
    (block
      (expression_statement
        (ambiguous_function_call_expression
          (function)
          (interpolated_string_literal
            (string_content
              (scalar
                (varname))
              (escape_sequence)))))))
  (expression_statement
    (function_call_expression
      (function)
      (bareword))))
