warning: profiles for the non root package will be ignored, specify profiles at the workspace root:
package:   /home/steven/code/tree-sitter-perl/crates/perl-lexer/Cargo.toml
workspace: /home/steven/code/tree-sitter-perl/Cargo.toml
warning: unused variable: `indented`
   --> crates/perl-lexer/src/lib.rs:300:13
    |
300 |         let indented = if self.current_char() == Some('~') {
    |             ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_indented`
    |
    = note: `#[warn(unused_variables)]` on by default

warning: unused variable: `delimiter`
   --> crates/perl-lexer/src/lib.rs:318:13
    |
318 |         let delimiter = if self.position < self.input.len() {
    |             ^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_delimiter`

warning: unused variable: `delim`
   --> crates/perl-lexer/src/lib.rs:326:33
    |
326 | ...                   let delim = self.input[delim_start..self.position].to_string();
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_delim`

warning: unused variable: `delim`
   --> crates/perl-lexer/src/lib.rs:340:33
    |
340 | ...                   let delim = self.input[delim_start..self.position].to_string();
    |                           ^^^^^ help: if this is intentional, prefix it with an underscore: `_delim`

warning: method `matches_bytes` is never used
   --> crates/perl-lexer/src/lib.rs:240:8
    |
54  | impl<'a> PerlLexer<'a> {
    | ---------------------- method in this implementation
...
240 |     fn matches_bytes(&self, pattern: &[u8]) -> bool {
    |        ^^^^^^^^^^^^^
    |
    = note: `#[warn(dead_code)]` on by default

warning: constant `KEYWORDS` is never used
    --> crates/perl-lexer/src/lib.rs:1479:7
     |
1479 | const KEYWORDS: &[&str] = &[
     |       ^^^^^^^^

warning: constant `COMPOUND_SECOND_CHARS` is never used
    --> crates/perl-lexer/src/lib.rs:1510:7
     |
1510 | const COMPOUND_SECOND_CHARS: &[u8] = b"=<>&|+->.~*";
     |       ^^^^^^^^^^^^^^^^^^^^^

warning: `perl-lexer` (lib) generated 7 warnings
   Compiling tree-sitter-perl v0.1.0 (/home/steven/code/tree-sitter-perl/crates/tree-sitter-perl-rs)
warning: unused import: `std::collections::VecDeque`
 --> crates/tree-sitter-perl-rs/src/parser_v2.rs:7:5
  |
7 | use std::collections::VecDeque;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^^^
  |
  = note: `#[warn(unused_imports)]` on by default

warning: unused import: `PerlParser`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:6:31
  |
6 | use crate::pure_rust_parser::{PerlParser, AstNode, PureRustPerlParser};
  |                               ^^^^^^^^^^

warning: unused import: `crate::error::ParseError`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:8:5
  |
8 | use crate::error::ParseError;
  |     ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0599]: no variant or associated item named `My` found for enum `token_compat::TokenType` in the current scope
  --> crates/tree-sitter-perl-rs/src/working_parser.rs:74:41
   |
74 |         if self.match_token(&TokenType::My) {
   |                                         ^^ variant or associated item not found in `TokenType`
   |
  ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
   |
10 | pub enum TokenType {
   | ------------------ variant or associated item `My` not found for this enum

error[E0599]: no variant or associated item named `If` found for enum `token_compat::TokenType` in the current scope
  --> crates/tree-sitter-perl-rs/src/working_parser.rs:79:41
   |
79 |         if self.match_token(&TokenType::If) {
   |                                         ^^ variant or associated item not found in `TokenType`
   |
  ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
   |
10 | pub enum TokenType {
   | ------------------ variant or associated item `If` not found for this enum

error[E0599]: no variant or associated item named `Sub` found for enum `token_compat::TokenType` in the current scope
  --> crates/tree-sitter-perl-rs/src/working_parser.rs:84:41
   |
84 |         if self.match_token(&TokenType::Sub) {
   |                                         ^^^ variant or associated item not found in `TokenType`
   |
  ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
   |
10 | pub enum TokenType {
   | ------------------ variant or associated item `Sub` not found for this enum

error[E0599]: no variant or associated item named `Assign` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:104:41
    |
104 |         if self.match_token(&TokenType::Assign) {
    |                                         ^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `Assign` not found for this enum

error[E0559]: variant `NodeKind::VariableDeclaration` has no field named `name`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:110:21
    |
110 |                     name: Box::new(var),
    |                     ^^^^ `NodeKind::VariableDeclaration` does not have this field
    |
    = note: available fields are: `declarator`, `variables`

error[E0559]: variant `NodeKind::VariableDeclaration` has no field named `value`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:111:21
    |
111 |                     value: Some(Box::new(value)),
    |                     ^^^^^ `NodeKind::VariableDeclaration` does not have this field
    |
    = note: available fields are: `declarator`, `variables`

error[E0559]: variant `NodeKind::VariableDeclaration` has no field named `name`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:120:17
    |
120 |                 name: Box::new(var),
    |                 ^^^^ `NodeKind::VariableDeclaration` does not have this field
    |
    = note: available fields are: `declarator`, `variables`

error[E0559]: variant `NodeKind::VariableDeclaration` has no field named `value`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:121:17
    |
121 |                 value: None,
    |                 ^^^^^ `NodeKind::VariableDeclaration` does not have this field
    |
    = note: available fields are: `declarator`, `variables`

error[E0599]: no variant or associated item named `Else` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:143:58
    |
143 |         let else_block = if self.match_token(&TokenType::Else) {
    |                                                          ^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `Else` not found for this enum

error[E0599]: no variant named `If` found for enum `NodeKind`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:151:23
    |
151 |             NodeKind::If {
    |                       ^^ variant not found in `NodeKind`
    |
   ::: crates/tree-sitter-perl-rs/src/ast.rs:334:1
    |
334 | pub enum NodeKind {
    | ----------------- variant `If` not found here

error[E0599]: no variant named `Function` found for enum `NodeKind`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:177:23
    |
177 |             NodeKind::Function {
    |                       ^^^^^^^^ variant not found in `NodeKind`
    |
   ::: crates/tree-sitter-perl-rs/src/ast.rs:334:1
    |
334 | pub enum NodeKind {
    | ----------------- variant `Function` not found here

error[E0599]: no variant or associated item named `Assign` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:212:41
    |
212 |         if self.match_token(&TokenType::Assign) {
    |                                         ^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `Assign` not found for this enum

error[E0063]: missing field `op` in initializer of `NodeKind`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:218:17
    |
218 |                 NodeKind::Assignment {
    |                 ^^^^^^^^^^^^^^^^^^^^ missing `op`

error[E0599]: no variant or associated item named `String` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:286:41
    |
286 |         if self.check_token(&TokenType::String) {
    |                                         ^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `String` not found for this enum
    |
help: there is a variant with a similar name
    |
286 |         if self.check_token(&TokenType::StringEq) {
    |                                               ++

error[E0599]: no variant or associated item named `ScalarSigil` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:296:41
    |
296 |         if self.check_token(&TokenType::ScalarSigil) ||
    |                                         ^^^^^^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `ScalarSigil` not found for this enum

error[E0599]: no variant or associated item named `ArraySigil` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:297:41
    |
297 |            self.check_token(&TokenType::ArraySigil) ||
    |                                         ^^^^^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `ArraySigil` not found for this enum

error[E0599]: no variant or associated item named `HashSigil` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:298:41
    |
298 |            self.check_token(&TokenType::HashSigil) {
    |                                         ^^^^^^^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `HashSigil` not found for this enum

error[E0559]: variant `NodeKind::Variable` has no field named `sigil`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:308:42
    |
308 |                     NodeKind::Variable { sigil, name },
    |                                          ^^^^^ `NodeKind::Variable` does not have this field
    |
    = note: all struct fields are already assigned

error[E0599]: no variant named `Identifier` found for enum `NodeKind`
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:319:27
    |
319 |                 NodeKind::Identifier { name },
    |                           ^^^^^^^^^^ variant not found in `NodeKind`
    |
   ::: crates/tree-sitter-perl-rs/src/ast.rs:334:1
    |
334 | pub enum NodeKind {
    | ----------------- variant `Identifier` not found here

error[E0599]: no variant or associated item named `And` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:340:24
    |
340 |             TokenType::And, TokenType::Or,
    |                        ^^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `And` not found for this enum

error[E0599]: no variant or associated item named `Or` found for enum `token_compat::TokenType` in the current scope
   --> crates/tree-sitter-perl-rs/src/working_parser.rs:340:40
    |
340 |             TokenType::And, TokenType::Or,
    |                                        ^^ variant or associated item not found in `TokenType`
    |
   ::: crates/tree-sitter-perl-rs/src/token_compat.rs:10:1
    |
10  | pub enum TokenType {
    | ------------------ variant or associated item `Or` not found for this enum

warning: unused import: `pest::Parser`
 --> crates/tree-sitter-perl-rs/src/benchmark_parser.rs:7:5
  |
7 | use pest::Parser;
  |     ^^^^^^^^^^^^

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:276:40
    |
271 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
272 |             
273 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
276 |                 NodeKind::Assignment { left, op, right },
    |                                        ^^^^ move out of `left` occurs here
277 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
273 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:276:50
    |
270 |             let right = Box::new(self.parse_assignment()?);
    |                 ----- binding `right` declared here
...
274 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
275 |             return Ok(Node::new(
276 |                 NodeKind::Assignment { left, op, right },
    |                                                  ^^^^^ move out of `right` occurs here
277 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
274 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:296:36
    |
291 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
292 |             
293 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
296 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
297 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
293 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:296:46
    |
290 |             let right = Box::new(self.parse_and()?);
    |                 ----- binding `right` declared here
...
294 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
295 |             expr = Node::new(
296 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
297 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
294 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:316:36
    |
311 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
312 |             
313 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
316 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
317 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
313 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:316:46
    |
310 |             let right = Box::new(self.parse_equality()?);
    |                 ----- binding `right` declared here
...
314 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
315 |             expr = Node::new(
316 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
317 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
314 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:341:36
    |
336 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
337 |             
338 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
341 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
342 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
338 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:341:46
    |
335 |             let right = Box::new(self.parse_relational()?);
    |                 ----- binding `right` declared here
...
339 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
340 |             expr = Node::new(
341 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
342 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
339 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:370:36
    |
365 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
366 |             
367 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
370 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
371 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
367 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:370:46
    |
364 |             let right = Box::new(self.parse_additive()?);
    |                 ----- binding `right` declared here
...
368 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
369 |             expr = Node::new(
370 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
371 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
368 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:565:36
    |
560 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
561 |             
562 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
565 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
566 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
562 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:565:46
    |
559 |             let right = Box::new(self.parse_multiplicative()?);
    |                 ----- binding `right` declared here
...
563 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
564 |             expr = Node::new(
565 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
566 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
563 |             let right_ref = &right.clone();
    |                                   ++++++++

error[E0505]: cannot move out of `left` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:585:36
    |
580 |             let left = Box::new(expr);
    |                 ---- binding `left` declared here
581 |             
582 |             let left_ref = &left;
    |                            ----- borrow of `left` occurs here
...
585 |                 NodeKind::Binary { left, op, right },
    |                                    ^^^^ move out of `left` occurs here
586 |                 self.span_locations(left_ref, right_ref)
    |                                     -------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
582 |             let left_ref = &left.clone();
    |                                 ++++++++

error[E0505]: cannot move out of `right` because it is borrowed
   --> crates/tree-sitter-perl-rs/src/parser.rs:585:46
    |
579 |             let right = Box::new(self.parse_unary()?);
    |                 ----- binding `right` declared here
...
583 |             let right_ref = &right;
    |                             ------ borrow of `right` occurs here
584 |             expr = Node::new(
585 |                 NodeKind::Binary { left, op, right },
    |                                              ^^^^^ move out of `right` occurs here
586 |                 self.span_locations(left_ref, right_ref)
    |                                               --------- borrow later used here
    |
help: consider cloning the value if the performance cost is acceptable
    |
583 |             let right_ref = &right.clone();
    |                                   ++++++++

warning: unused variable: `is_foreach`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:411:13
    |
411 |         let is_foreach = self.peek_text() == "foreach";
    |             ^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_is_foreach`
    |
    = note: `#[warn(unused_variables)]` on by default

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:602:28
    |
584 |         let mut expr = self.parse_or()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
...
597 |                     condition: Box::new(expr),
    |                                         ---- value moved here
...
602 |                     start: expr.location.start, 
    |                            ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
597 |                     condition: Box::new(expr.clone()),
    |                                             ++++++++

error[E0382]: use of moved value: `else_expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:603:26
    |
593 |             let else_expr = Box::new(self.parse_expression()?);
    |                 --------- move occurs because `else_expr` has type `Box<ast::Node>`, which does not implement the `Copy` trait
...
599 |                     else_expr,
    |                     --------- value moved here
...
603 |                     end: else_expr.location.end 
    |                          ^^^^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
599 |                     else_expr: else_expr.clone(),
    |                              +++++++++++++++++++

warning: unused variable: `op_start`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:615:17
    |
615 |             let op_start = self.current_pos();
    |                 ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_op_start`

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:878:36
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
874 |                             array: Box::new(expr),
    |                                             ---- value moved here
...
878 |                             start: expr.location.start,
    |                                    ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
874 |                         NodeKind::ArrayAccess {
875 ~                             array: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
874 |                             array: Box::new(expr.clone()),
    |                                                 ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:894:36
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
890 |                             hash: Box::new(expr),
    |                                            ---- value moved here
...
894 |                             start: expr.location.start,
    |                                    ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
890 |                         NodeKind::HashAccess {
891 ~                             hash: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
890 |                             hash: Box::new(expr.clone()),
    |                                                ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:927:36
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
922 |                             object: Box::new(expr),
    |                                              ---- value moved here
...
927 |                             start: expr.location.start,
    |                                    ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
922 |                         NodeKind::MethodCall {
923 ~                             object: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
922 |                             object: Box::new(expr.clone()),
    |                                                  ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:940:36
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
936 |                             expr: Box::new(expr),
    |                                            ---- value moved here
...
940 |                             start: expr.location.start,
    |                                    ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
936 |                         NodeKind::Dereference {
937 ~                             expr: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
936 |                             expr: Box::new(expr.clone()),
    |                                                ++++++++

error[E0382]: use of moved value: `deref`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:941:34
    |
933 |                     let deref = self.parse_unary()?;
    |                         ----- move occurs because `deref` has type `ast::Node`, which does not implement the `Copy` trait
...
937 |                             type_: Box::new(deref),
    |                                             ----- value moved here
...
941 |                             end: deref.location.end,
    |                                  ^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider cloning the value if the performance cost is acceptable
    |
937 |                             type_: Box::new(deref.clone()),
    |                                                  ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:957:32
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
953 |                         array: Box::new(expr),
    |                                         ---- value moved here
...
957 |                         start: expr.location.start,
    |                                ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
953 |                     NodeKind::ArrayAccess {
954 ~                         array: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
953 |                         array: Box::new(expr.clone()),
    |                                             ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:973:32
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
969 |                         hash: Box::new(expr),
    |                                        ---- value moved here
...
973 |                         start: expr.location.start,
    |                                ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
969 |                     NodeKind::HashAccess {
970 ~                         hash: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
969 |                         hash: Box::new(expr.clone()),
    |                                            ++++++++

error[E0382]: use of moved value: `expr`
   --> crates/tree-sitter-perl-rs/src/parser_v2.rs:987:32
    |
858 |         let mut expr = self.parse_primary()?;
    |             -------- move occurs because `expr` has type `ast::Node`, which does not implement the `Copy` trait
859 |         
860 |         loop {
    |         ---- inside of this loop
...
984 |                         operand: Box::new(expr),
    |                                           ---- value moved here
...
987 |                         start: expr.location.start,
    |                                ^^^^^^^^^^^^^^^^^^^ value used here after move
    |
help: consider moving the expression out of the loop so it is only moved once
    |
860 ~         let mut value = Box::new(expr);
861 ~         loop {
862 |             self.skip_whitespace();
...
984 |                         op,
985 ~                         operand: value,
    |
help: consider cloning the value if the performance cost is acceptable
    |
984 |                         operand: Box::new(expr.clone()),
    |                                               ++++++++

error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1045:16
     |
1041 |             let id_token = self.advance();
     |                            ---- mutable borrow occurs here
...
1045 |             if self.check(&TokenType::LeftParen) {
     |                ^^^^ immutable borrow occurs here
...
1071 |                 SourceLocation { start: id_token.start, end: id_token.end }
     |                                         -------------- mutable borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1046:17
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1046 |                 self.advance();
     |                 ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1049:17
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1049 |                 self.skip_whitespace();
     |                 ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1050:24
     |
1041 |             let id_token = self.advance();
     |                            ---- mutable borrow occurs here
...
1050 |                 while !self.check(&TokenType::RightParen) && !self.is_at_end() {
     |                        ^^^^ immutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- mutable borrow later used here

error[E0502]: cannot borrow `*self` as immutable because it is also borrowed as mutable
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1050:63
     |
1041 |             let id_token = self.advance();
     |                            ---- mutable borrow occurs here
...
1050 |                 while !self.check(&TokenType::RightParen) && !self.is_at_end() {
     |                                                               ^^^^ immutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- mutable borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1051:31
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1051 |                     args.push(self.parse_expression()?);
     |                               ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1052:21
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1052 |                     self.skip_whitespace();
     |                     ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1054:25
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1054 |                     if !self.match_token(&TokenType::Comma) {
     |                         ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1057:21
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1057 |                     self.skip_whitespace();
     |                     ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

error[E0499]: cannot borrow `*self` as mutable more than once at a time
    --> crates/tree-sitter-perl-rs/src/parser_v2.rs:1060:17
     |
1041 |             let id_token = self.advance();
     |                            ---- first mutable borrow occurs here
...
1060 |                 self.consume(&TokenType::RightParen)?;
     |                 ^^^^ second mutable borrow occurs here
...
1064 |                     SourceLocation { start: id_token.start, end: self.current_pos() }
     |                                             -------------- first borrow later used here

warning: unused variable: `pattern_start`
   --> crates/tree-sitter-perl-rs/src/context_aware_parser.rs:177:34
    |
177 | ...                   pattern_start: usize,
    |                       ^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_pattern_start`

warning: unused variable: `quoted`
   --> crates/tree-sitter-perl-rs/src/runtime_heredoc_handler.rs:111:21
    |
111 |                 let quoted = !cap.get(1).unwrap().as_str().is_empty();
    |                     ^^^^^^ help: if this is intentional, prefix it with an underscore: `_quoted`

warning: unused variable: `recovery_state`
   --> crates/tree-sitter-perl-rs/src/understanding_parser.rs:219:9
    |
219 |         recovery_state: &mut RecoveryState,
    |         ^^^^^^^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_recovery_state`

warning: unused variable: `context`
   --> crates/tree-sitter-perl-rs/src/dynamic_delimiter_recovery.rs:179:48
    |
179 |     fn try_resolve_variable(&self, expr: &str, context: &ParseContext) -> Option<&PossibleValue> {
    |                                                ^^^^^^^ help: if this is intentional, prefix it with an underscore: `_context`

warning: unused variable: `tokens`
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:491:29
    |
491 |     fn build_context(&self, tokens: &[Token], position: usize) -> ParseContext {
    |                             ^^^^^^ help: if this is intentional, prefix it with an underscore: `_tokens`

warning: unused variable: `position`
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:491:47
    |
491 |     fn build_context(&self, tokens: &[Token], position: usize) -> ParseContext {
    |                                               ^^^^^^^^ help: if this is intentional, prefix it with an underscore: `_position`

warning: variable does not need to be mutable
   --> crates/tree-sitter-perl-rs/src/heredoc_recovery.rs:492:13
    |
492 |         let mut context = ParseContext {
    |             ----^^^^^^^
    |             |
    |             help: remove this `mut`
    |
    = note: `#[warn(unused_mut)]` on by default

warning: unused variable: `e`
  --> crates/tree-sitter-perl-rs/src/disambiguated_parser.rs:31:23
   |
31 |             .map_err(|e| {
   |                       ^ help: if this is intentional, prefix it with an underscore: `_e`

Some errors have detailed explanations: E0063, E0382, E0499, E0502, E0505, E0559, E0599.
For more information about an error, try `rustc --explain E0063`.
warning: `tree-sitter-perl` (lib) generated 14 warnings
error: could not compile `tree-sitter-perl` (lib) due to 55 previous errors; 14 warnings emitted
