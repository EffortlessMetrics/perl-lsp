// Build script - panics are acceptable for build failures.
#![allow(clippy::pedantic, clippy::panic)]

use std::env;
use std::fs;
use std::path::{Path, PathBuf};

#[derive(serde::Deserialize)]
struct Feature {
    id: String,
    area: Option<String>,
    advertised: Option<bool>,
}

#[derive(serde::Deserialize)]
struct Catalog {
    feature: Vec<Feature>,
}

fn read_catalog() -> Result<Catalog, Box<dyn std::error::Error>> {
    println!("cargo:rerun-if-env-changed=FEATURES_TOML_OVERRIDE");

    if let Ok(override_path) = env::var("FEATURES_TOML_OVERRIDE") {
        let path = PathBuf::from(override_path);
        if path.exists() {
            println!("cargo:rerun-if-changed={}", path.display());
            let content = fs::read_to_string(&path)?;
            return Ok(toml::from_str(&content)?);
        }
    }

    let manifest_dir = PathBuf::from(env::var("CARGO_MANIFEST_DIR")?);
    let workspace_features =
        manifest_dir.parent().and_then(Path::parent).map(|p| p.join("features.toml"));
    let vendored = manifest_dir.join("features_sot.toml");

    let source_path = if let Some(path) = workspace_features {
        if path.exists() {
            path
        } else if vendored.exists() {
            vendored
        } else {
            return Err("features.toml not found in workspace root or as vendored copy".into());
        }
    } else if vendored.exists() {
        vendored
    } else {
        return Err("features.toml not found".into());
    };

    println!("cargo:rerun-if-changed={}", source_path.display());
    let content = fs::read_to_string(source_path)?;
    Ok(toml::from_str(&content)?)
}

fn generate_catalog_module() -> Result<(), Box<dyn std::error::Error>> {
    let out_dir = PathBuf::from(env::var("OUT_DIR")?);
    let dest_path = out_dir.join("dap_feature_catalog.rs");

    let default_features = vec![
        "dap.breakpoints.basic".to_string(),
        "dap.core".to_string(),
        "dap.inline_values".to_string(),
    ];

    let advertised_debug_features = match read_catalog() {
        Ok(catalog) => {
            let mut features: Vec<String> = catalog
                .feature
                .into_iter()
                .filter(|feature| {
                    feature.area.as_deref() == Some("debug") && feature.advertised.unwrap_or(false)
                })
                .map(|feature| feature.id)
                .collect();
            features.sort();
            features.dedup();
            features
        }
        Err(error) => {
            eprintln!("Warning: failed to load DAP feature catalog from features.toml: {error}");
            default_features
        }
    };

    let mut code = String::new();
    code.push_str("// @generated by build.rs; DO NOT EDIT.\n");
    code.push_str("#[allow(dead_code, clippy::all)]\n\n");
    code.push_str("pub const ADVERTISED_DAP_FEATURES: &[&str] = &[\n");
    for feature in &advertised_debug_features {
        code.push_str(&format!("    {:?},\n", feature));
    }
    code.push_str("];\n\n");
    code.push_str("pub fn advertised_features() -> &'static [&'static str] {\n");
    code.push_str("    ADVERTISED_DAP_FEATURES\n");
    code.push_str("}\n\n");
    code.push_str("pub fn has_feature(id: &str) -> bool {\n");
    code.push_str("    ADVERTISED_DAP_FEATURES.contains(&id)\n");
    code.push_str("}\n");

    fs::write(dest_path, code)?;
    Ok(())
}

fn main() -> Result<(), Box<dyn std::error::Error>> {
    generate_catalog_module()
}
