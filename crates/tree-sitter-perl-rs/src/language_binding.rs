//! Tree-sitter language bindings for Perl
//!
//! This module provides the tree-sitter language interface implementation
//! that allows the Perl parser to be used with tree-sitter tools.

use tree_sitter::Language;
use crate::pure_rust_parser::{AstNode, PureRustPerlParser};
use crate::enhanced_full_parser::EnhancedFullParser;
use std::os::raw::{c_char, c_void};
use std::ffi::CString;
use std::ptr;
use std::sync::Mutex;
use std::collections::HashMap;

/// Parser state for tree-sitter integration
pub struct TreeSitterPerlParser {
    /// Internal parser instance
    parser: Mutex<EnhancedFullParser>,
    /// Cached trees for incremental parsing
    tree_cache: Mutex<HashMap<u64, ParsedTree>>,
    /// Next tree ID
    next_tree_id: Mutex<u64>,
}

struct ParsedTree {
    source: String,
    ast: AstNode,
}

impl TreeSitterPerlParser {
    pub fn new() -> Self {
        Self {
            parser: Mutex::new(EnhancedFullParser::new()),
            tree_cache: Mutex::new(HashMap::new()),
            next_tree_id: Mutex::new(1),
        }
    }

    /// Parse source code and return a tree ID
    pub fn parse(&self, source: &str) -> Result<u64, String> {
        let mut parser = self.parser.lock().map_err(|e| format!("Mutex poisoned: {}", e))?;
        let ast = parser.parse(source).map_err(|e| format!("{:?}", e))?;
        
        let mut cache = self.tree_cache.lock().map_err(|e| format!("Mutex poisoned: {}", e))?;
        let mut next_id = self.next_tree_id.lock().map_err(|e| format!("Mutex poisoned: {}", e))?;
        let tree_id = *next_id;
        *next_id += 1;
        
        cache.insert(tree_id, ParsedTree {
            source: source.to_string(),
            ast,
        });
        
        Ok(tree_id)
    }

    /// Get AST for a tree ID
    pub fn get_ast(&self, tree_id: u64) -> Option<AstNode> {
        let cache = self.tree_cache.lock().ok()?;
        cache.get(&tree_id).map(|t| t.ast.clone())
    }

    /// Clean up a tree
    pub fn delete_tree(&self, tree_id: u64) {
        if let Ok(mut cache) = self.tree_cache.lock() {
            cache.remove(&tree_id);
        }
    }
}

// Global parser instance
lazy_static::lazy_static! {
    static ref GLOBAL_PARSER: TreeSitterPerlParser = TreeSitterPerlParser::new();
}

/// Language definition exports for tree-sitter
#[no_mangle]
pub extern "C" fn tree_sitter_perl_pure() -> Language {
    // Return the language object
    // In a real implementation, this would be generated by tree-sitter
    unsafe { Language::from_raw(tree_sitter_perl_language()) }
}

/// External scanner interface
#[repr(C)]
pub struct TSLexer {
    // Tree-sitter lexer fields
    _private: [u8; 0],
}

#[repr(C)]
pub struct TSPoint {
    row: u32,
    column: u32,
}

/// Scanner state for context-sensitive parsing
pub struct ScannerState {
    /// Current context (heredoc, regex, etc.)
    context: Vec<Context>,
    /// Heredoc terminators
    heredoc_terminators: Vec<String>,
}

#[derive(Debug, Clone)]
enum Context {
    Normal,
    Heredoc { terminator: String },
    Regex,
    String,
}

/// Create a new scanner
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_create() -> *mut c_void {
    let state = Box::new(ScannerState {
        context: vec![Context::Normal],
        heredoc_terminators: Vec::new(),
    });
    Box::into_raw(state) as *mut c_void
}

/// Destroy scanner
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_destroy(state: *mut c_void) {
    if !state.is_null() {
        unsafe {
            Box::from_raw(state as *mut ScannerState);
        }
    }
}

/// Serialize scanner state
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_serialize(
    state: *const c_void,
    buffer: *mut c_char,
    buffer_size: u32,
) -> u32 {
    if state.is_null() || buffer.is_null() {
        return 0;
    }

    let state = unsafe { &*(state as *const ScannerState) };
    
    // Simple serialization: store heredoc terminator count and terminators
    let mut data = Vec::new();
    data.push(state.heredoc_terminators.len() as u8);
    for term in &state.heredoc_terminators {
        data.push(term.len() as u8);
        data.extend_from_slice(term.as_bytes());
    }

    let copy_len = data.len().min(buffer_size as usize);
    unsafe {
        ptr::copy_nonoverlapping(data.as_ptr(), buffer as *mut u8, copy_len);
    }
    
    copy_len as u32
}

/// Deserialize scanner state
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_deserialize(
    state: *mut c_void,
    buffer: *const c_char,
    length: u32,
) {
    if state.is_null() || buffer.is_null() || length == 0 {
        return;
    }

    let state = unsafe { &mut *(state as *mut ScannerState) };
    let data = unsafe { std::slice::from_raw_parts(buffer as *const u8, length as usize) };
    
    state.heredoc_terminators.clear();
    
    if let Some(&count) = data.get(0) {
        let mut pos = 1;
        for _ in 0..count {
            if let Some(&len) = data.get(pos) {
                pos += 1;
                if pos + len as usize <= data.len() {
                    if let Ok(term) = std::str::from_utf8(&data[pos..pos + len as usize]) {
                        state.heredoc_terminators.push(term.to_string());
                    }
                    pos += len as usize;
                }
            }
        }
    }
}

/// Scan for external tokens
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_scan(
    state: *mut c_void,
    lexer: *const TSLexer,
    valid_symbols: *const bool,
) -> bool {
    if state.is_null() || lexer.is_null() || valid_symbols.is_null() {
        return false;
    }

    // In a real implementation, this would scan for heredocs, regex, etc.
    // For now, return false to use the main grammar
    false
}

/// Symbol names for debugging
/// NOTE: These are NUL-terminated byte literals for C FFI compatibility.
/// Rust `&str` is NOT NUL-terminated, which would cause undefined behavior
/// when passed to C code expecting C strings.
static SYMBOL_NAMES: &[&[u8]] = &[
    b"source_file\0",
    b"statement\0",
    b"expression\0",
    b"identifier\0",
    b"number\0",
    b"string\0",
    b"scalar_variable\0",
    b"array_variable\0",
    b"hash_variable\0",
    b"subroutine_declaration\0",
    b"package_declaration\0",
    b"use_statement\0",
    b"if_statement\0",
    b"while_statement\0",
    b"for_statement\0",
    b"block\0",
    b"assignment\0",
    b"binary_expression\0",
    b"unary_expression\0",
    b"function_call\0",
    b"method_call\0",
    b"comment\0",
    b"heredoc\0",
    b"regex\0",
    b"ERROR\0",
];

/// Get symbol name
#[no_mangle]
pub extern "C" fn tree_sitter_perl_symbol_name(symbol: u16) -> *const c_char {
    if (symbol as usize) < SYMBOL_NAMES.len() {
        SYMBOL_NAMES[symbol as usize].as_ptr() as *const c_char
    } else {
        ptr::null()
    }
}

/// Field names
/// NOTE: These are NUL-terminated byte literals for C FFI compatibility.
/// Rust `&str` is NOT NUL-terminated, which would cause undefined behavior
/// when passed to C code expecting C strings.
static FIELD_NAMES: &[&[u8]] = &[
    b"name\0",
    b"body\0",
    b"condition\0",
    b"then\0",
    b"else\0",
    b"operator\0",
    b"left\0",
    b"right\0",
    b"function\0",
    b"arguments\0",
    b"object\0",
    b"method\0",
    b"value\0",
    b"pattern\0",
    b"flags\0",
];

/// Get field name
#[no_mangle]
pub extern "C" fn tree_sitter_perl_field_name(field_id: u16) -> *const c_char {
    if (field_id as usize) < FIELD_NAMES.len() {
        FIELD_NAMES[field_id as usize].as_ptr() as *const c_char
    } else {
        ptr::null()
    }
}

/// Language function that returns the tree-sitter language
extern "C" {
    fn tree_sitter_perl_language() -> *const tree_sitter::ffi::TSLanguage;
}

/// Parse function for C API compatibility
#[no_mangle]
pub extern "C" fn tree_sitter_perl_parse(
    source_code: *const c_char,
    source_len: usize,
) -> u64 {
    if source_code.is_null() {
        return 0;
    }

    let source = unsafe {
        std::str::from_utf8_unchecked(std::slice::from_raw_parts(
            source_code as *const u8,
            source_len,
        ))
    };

    match GLOBAL_PARSER.parse(source) {
        Ok(tree_id) => tree_id,
        Err(_) => 0,
    }
}

/// Get S-expression for a parsed tree
#[no_mangle]
pub extern "C" fn tree_sitter_perl_to_sexp(tree_id: u64) -> *mut c_char {
    if let Some(ast) = GLOBAL_PARSER.get_ast(tree_id) {
        let parser = PureRustPerlParser::new();
        let sexp = parser.to_sexp(&ast);
        if let Ok(c_str) = CString::new(sexp) {
            return c_str.into_raw();
        }
    }
    ptr::null_mut()
}

/// Free a string returned by the parser
#[no_mangle]
pub extern "C" fn tree_sitter_perl_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe {
            CString::from_raw(s);
        }
    }
}

/// Delete a parsed tree
#[no_mangle]
pub extern "C" fn tree_sitter_perl_delete_tree(tree_id: u64) {
    GLOBAL_PARSER.delete_tree(tree_id);
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::ffi::CStr;

    #[test]
    fn test_parser_interface() {
        use perl_tdd_support::must;
        let source = "my $x = 42;";
        let tree_id = must(GLOBAL_PARSER.parse(source));
        assert!(tree_id > 0);

        let ast = GLOBAL_PARSER.get_ast(tree_id);
        assert!(ast.is_some());

        GLOBAL_PARSER.delete_tree(tree_id);
        assert!(GLOBAL_PARSER.get_ast(tree_id).is_none());
    }

    #[test]
    fn test_scanner_state() {
        let state = ScannerState {
            context: vec![Context::Normal],
            heredoc_terminators: vec!["EOF".to_string(), "DATA".to_string()],
        };

        let mut buffer = vec![0u8; 100];
        let serialized = tree_sitter_perl_external_scanner_serialize(
            &state as *const _ as *const c_void,
            buffer.as_mut_ptr() as *mut c_char,
            100,
        );
        assert!(serialized > 0);

        let mut new_state = ScannerState {
            context: vec![],
            heredoc_terminators: vec![],
        };
        tree_sitter_perl_external_scanner_deserialize(
            &mut new_state as *mut _ as *mut c_void,
            buffer.as_ptr() as *const c_char,
            serialized,
        );
        assert_eq!(new_state.heredoc_terminators.len(), 2);
        assert_eq!(new_state.heredoc_terminators[0], "EOF");
    }

    /// Proof test: verify symbol names are valid NUL-terminated C strings.
    ///
    /// This test prevents regression of UB where Rust `&str` (NOT NUL-terminated)
    /// was incorrectly passed to C code expecting C strings.
    #[test]
    fn test_symbol_names_are_valid_c_strings() {
        // Test first symbol (index 0)
        let ptr = tree_sitter_perl_symbol_name(0);
        assert!(!ptr.is_null(), "Symbol name at index 0 should not be null");

        // Verify it's a valid C string with NUL terminator
        let c_str = unsafe { CStr::from_ptr(ptr) };
        let s = c_str.to_str().map_err(|e| format!("{:?}", e)).ok().unwrap_or("");
        assert_eq!(s, "source_file", "First symbol should be 'source_file'");

        // Test that the string is properly NUL-terminated within reasonable bounds
        let bytes = unsafe { std::slice::from_raw_parts(ptr as *const u8, 64) };
        let nul_pos = bytes.iter().position(|&b| b == 0);
        assert!(nul_pos.is_some(), "Symbol name must have NUL terminator within 64 bytes");
        if let Some(pos) = nul_pos {
            assert!(pos < 50, "NUL terminator should be within reasonable bounds");
        }

        // Test that out-of-bounds returns null
        let out_of_bounds = tree_sitter_perl_symbol_name(u16::MAX);
        assert!(out_of_bounds.is_null(), "Out of bounds symbol should return null");
    }

    /// Proof test: verify field names are valid NUL-terminated C strings.
    ///
    /// This test prevents regression of UB where Rust `&str` (NOT NUL-terminated)
    /// was incorrectly passed to C code expecting C strings.
    #[test]
    fn test_field_names_are_valid_c_strings() {
        // Test first field (index 0)
        let ptr = tree_sitter_perl_field_name(0);
        assert!(!ptr.is_null(), "Field name at index 0 should not be null");

        // Verify it's a valid C string with NUL terminator
        let c_str = unsafe { CStr::from_ptr(ptr) };
        let s = c_str.to_str().map_err(|e| format!("{:?}", e)).ok().unwrap_or("");
        assert_eq!(s, "name", "First field should be 'name'");

        // Test that the string is properly NUL-terminated within reasonable bounds
        let bytes = unsafe { std::slice::from_raw_parts(ptr as *const u8, 64) };
        let nul_pos = bytes.iter().position(|&b| b == 0);
        assert!(nul_pos.is_some(), "Field name must have NUL terminator within 64 bytes");
        if let Some(pos) = nul_pos {
            assert!(pos < 50, "NUL terminator should be within reasonable bounds");
        }

        // Test that out-of-bounds returns null
        let out_of_bounds = tree_sitter_perl_field_name(u16::MAX);
        assert!(out_of_bounds.is_null(), "Out of bounds field should return null");
    }

    /// Test that all symbol and field names are properly NUL-terminated
    #[test]
    fn test_all_names_have_nul_terminator() {
        // Verify all symbol names
        for i in 0..SYMBOL_NAMES.len() {
            let name = SYMBOL_NAMES[i];
            assert!(
                name.ends_with(&[0u8]),
                "Symbol name at index {} must end with NUL byte",
                i
            );
        }

        // Verify all field names
        for i in 0..FIELD_NAMES.len() {
            let name = FIELD_NAMES[i];
            assert!(
                name.ends_with(&[0u8]),
                "Field name at index {} must end with NUL byte",
                i
            );
        }
    }
}