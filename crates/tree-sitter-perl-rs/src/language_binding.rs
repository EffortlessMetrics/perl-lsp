//! Tree-sitter language bindings for Perl
//!
//! This module provides the tree-sitter language interface implementation
//! that allows the Perl parser to be used with tree-sitter tools.

use tree_sitter::Language;
use crate::pure_rust_parser::{AstNode, PureRustPerlParser};
use crate::enhanced_full_parser::EnhancedFullParser;
use std::os::raw::{c_char, c_void};
use std::ffi::CString;
use std::ptr;
use std::sync::Mutex;
use std::collections::HashMap;

/// Parser state for tree-sitter integration
pub struct TreeSitterPerlParser {
    /// Internal parser instance
    parser: Mutex<EnhancedFullParser>,
    /// Cached trees for incremental parsing
    tree_cache: Mutex<HashMap<u64, ParsedTree>>,
    /// Next tree ID
    next_tree_id: Mutex<u64>,
}

struct ParsedTree {
    source: String,
    ast: AstNode,
}

impl TreeSitterPerlParser {
    pub fn new() -> Self {
        Self {
            parser: Mutex::new(EnhancedFullParser::new()),
            tree_cache: Mutex::new(HashMap::new()),
            next_tree_id: Mutex::new(1),
        }
    }

    /// Parse source code and return a tree ID
    pub fn parse(&self, source: &str) -> Result<u64, String> {
        let mut parser = self.parser.lock().unwrap();
        let ast = parser.parse(source).map_err(|e| format!("{:?}", e))?;
        
        let mut cache = self.tree_cache.lock().unwrap();
        let mut next_id = self.next_tree_id.lock().unwrap();
        let tree_id = *next_id;
        *next_id += 1;
        
        cache.insert(tree_id, ParsedTree {
            source: source.to_string(),
            ast,
        });
        
        Ok(tree_id)
    }

    /// Get AST for a tree ID
    pub fn get_ast(&self, tree_id: u64) -> Option<AstNode> {
        let cache = self.tree_cache.lock().unwrap();
        cache.get(&tree_id).map(|t| t.ast.clone())
    }

    /// Clean up a tree
    pub fn delete_tree(&self, tree_id: u64) {
        let mut cache = self.tree_cache.lock().unwrap();
        cache.remove(&tree_id);
    }
}

// Global parser instance
lazy_static::lazy_static! {
    static ref GLOBAL_PARSER: TreeSitterPerlParser = TreeSitterPerlParser::new();
}

/// Language definition exports for tree-sitter
#[no_mangle]
pub extern "C" fn tree_sitter_perl_pure() -> Language {
    // Return the language object
    // In a real implementation, this would be generated by tree-sitter
    unsafe { Language::from_raw(tree_sitter_perl_language()) }
}

/// External scanner interface
#[repr(C)]
pub struct TSLexer {
    // Tree-sitter lexer fields
    _private: [u8; 0],
}

#[repr(C)]
pub struct TSPoint {
    row: u32,
    column: u32,
}

/// Scanner state for context-sensitive parsing
pub struct ScannerState {
    /// Current context (heredoc, regex, etc.)
    context: Vec<Context>,
    /// Heredoc terminators
    heredoc_terminators: Vec<String>,
}

#[derive(Debug, Clone)]
enum Context {
    Normal,
    Heredoc { terminator: String },
    Regex,
    String,
}

/// Create a new scanner
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_create() -> *mut c_void {
    let state = Box::new(ScannerState {
        context: vec![Context::Normal],
        heredoc_terminators: Vec::new(),
    });
    Box::into_raw(state) as *mut c_void
}

/// Destroy scanner
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_destroy(state: *mut c_void) {
    if !state.is_null() {
        unsafe {
            Box::from_raw(state as *mut ScannerState);
        }
    }
}

/// Serialize scanner state
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_serialize(
    state: *const c_void,
    buffer: *mut c_char,
    buffer_size: u32,
) -> u32 {
    if state.is_null() || buffer.is_null() {
        return 0;
    }

    let state = unsafe { &*(state as *const ScannerState) };
    
    // Simple serialization: store heredoc terminator count and terminators
    let mut data = Vec::new();
    data.push(state.heredoc_terminators.len() as u8);
    for term in &state.heredoc_terminators {
        data.push(term.len() as u8);
        data.extend_from_slice(term.as_bytes());
    }

    let copy_len = data.len().min(buffer_size as usize);
    unsafe {
        ptr::copy_nonoverlapping(data.as_ptr(), buffer as *mut u8, copy_len);
    }
    
    copy_len as u32
}

/// Deserialize scanner state
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_deserialize(
    state: *mut c_void,
    buffer: *const c_char,
    length: u32,
) {
    if state.is_null() || buffer.is_null() || length == 0 {
        return;
    }

    let state = unsafe { &mut *(state as *mut ScannerState) };
    let data = unsafe { std::slice::from_raw_parts(buffer as *const u8, length as usize) };
    
    state.heredoc_terminators.clear();
    
    if let Some(&count) = data.get(0) {
        let mut pos = 1;
        for _ in 0..count {
            if let Some(&len) = data.get(pos) {
                pos += 1;
                if pos + len as usize <= data.len() {
                    if let Ok(term) = std::str::from_utf8(&data[pos..pos + len as usize]) {
                        state.heredoc_terminators.push(term.to_string());
                    }
                    pos += len as usize;
                }
            }
        }
    }
}

/// Scan for external tokens
#[no_mangle]
pub extern "C" fn tree_sitter_perl_external_scanner_scan(
    state: *mut c_void,
    lexer: *const TSLexer,
    valid_symbols: *const bool,
) -> bool {
    if state.is_null() || lexer.is_null() || valid_symbols.is_null() {
        return false;
    }

    // In a real implementation, this would scan for heredocs, regex, etc.
    // For now, return false to use the main grammar
    false
}

/// Symbol names for debugging
static SYMBOL_NAMES: &[&str] = &[
    "source_file",
    "statement",
    "expression",
    "identifier",
    "number",
    "string",
    "scalar_variable",
    "array_variable",
    "hash_variable",
    "subroutine_declaration",
    "package_declaration",
    "use_statement",
    "if_statement",
    "while_statement",
    "for_statement",
    "block",
    "assignment",
    "binary_expression",
    "unary_expression",
    "function_call",
    "method_call",
    "comment",
    "heredoc",
    "regex",
    "ERROR",
];

/// Get symbol name
#[no_mangle]
pub extern "C" fn tree_sitter_perl_symbol_name(symbol: u16) -> *const c_char {
    if (symbol as usize) < SYMBOL_NAMES.len() {
        SYMBOL_NAMES[symbol as usize].as_ptr() as *const c_char
    } else {
        ptr::null()
    }
}

/// Field names
static FIELD_NAMES: &[&str] = &[
    "name",
    "body",
    "condition",
    "then",
    "else",
    "operator",
    "left",
    "right",
    "function",
    "arguments",
    "object",
    "method",
    "value",
    "pattern",
    "flags",
];

/// Get field name
#[no_mangle]
pub extern "C" fn tree_sitter_perl_field_name(field_id: u16) -> *const c_char {
    if (field_id as usize) < FIELD_NAMES.len() {
        FIELD_NAMES[field_id as usize].as_ptr() as *const c_char
    } else {
        ptr::null()
    }
}

/// Language function that returns the tree-sitter language
extern "C" {
    fn tree_sitter_perl_language() -> *const tree_sitter::ffi::TSLanguage;
}

/// Parse function for C API compatibility
#[no_mangle]
pub extern "C" fn tree_sitter_perl_parse(
    source_code: *const c_char,
    source_len: usize,
) -> u64 {
    if source_code.is_null() {
        return 0;
    }

    let source = unsafe {
        std::str::from_utf8_unchecked(std::slice::from_raw_parts(
            source_code as *const u8,
            source_len,
        ))
    };

    match GLOBAL_PARSER.parse(source) {
        Ok(tree_id) => tree_id,
        Err(_) => 0,
    }
}

/// Get S-expression for a parsed tree
#[no_mangle]
pub extern "C" fn tree_sitter_perl_to_sexp(tree_id: u64) -> *mut c_char {
    if let Some(ast) = GLOBAL_PARSER.get_ast(tree_id) {
        let parser = PureRustPerlParser::new();
        let sexp = parser.to_sexp(&ast);
        if let Ok(c_str) = CString::new(sexp) {
            return c_str.into_raw();
        }
    }
    ptr::null_mut()
}

/// Free a string returned by the parser
#[no_mangle]
pub extern "C" fn tree_sitter_perl_free_string(s: *mut c_char) {
    if !s.is_null() {
        unsafe {
            CString::from_raw(s);
        }
    }
}

/// Delete a parsed tree
#[no_mangle]
pub extern "C" fn tree_sitter_perl_delete_tree(tree_id: u64) {
    GLOBAL_PARSER.delete_tree(tree_id);
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_parser_interface() {
        let source = "my $x = 42;";
        let tree_id = GLOBAL_PARSER.parse(source).unwrap();
        assert!(tree_id > 0);
        
        let ast = GLOBAL_PARSER.get_ast(tree_id);
        assert!(ast.is_some());
        
        GLOBAL_PARSER.delete_tree(tree_id);
        assert!(GLOBAL_PARSER.get_ast(tree_id).is_none());
    }

    #[test]
    fn test_scanner_state() {
        let state = ScannerState {
            context: vec![Context::Normal],
            heredoc_terminators: vec!["EOF".to_string(), "DATA".to_string()],
        };

        let mut buffer = vec![0u8; 100];
        let serialized = tree_sitter_perl_external_scanner_serialize(
            &state as *const _ as *const c_void,
            buffer.as_mut_ptr() as *mut c_char,
            100,
        );
        assert!(serialized > 0);

        let mut new_state = ScannerState {
            context: vec![],
            heredoc_terminators: vec![],
        };
        tree_sitter_perl_external_scanner_deserialize(
            &mut new_state as *mut _ as *mut c_void,
            buffer.as_ptr() as *const c_char,
            serialized,
        );
        assert_eq!(new_state.heredoc_terminators.len(), 2);
        assert_eq!(new_state.heredoc_terminators[0], "EOF");
    }
}