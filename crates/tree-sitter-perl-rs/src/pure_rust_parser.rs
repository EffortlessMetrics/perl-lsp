//! Pure Rust Perl parser implementation
//!
//! This module provides a complete Rust-native implementation of the Perl parser
//! using Pest for grammar parsing, without any dependency on tree-sitter's C code.

use pest::{iterators::{Pair, Pairs}, Parser};
use pest_derive::Parser;

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct PerlParser;

// The Rule type is generated by pest_derive


// The Rule enum is generated by pest_derive in this module

/// AST node types for the pure Rust parser
#[derive(Debug, Clone, PartialEq)]
pub enum AstNode {
    // Program structure
    Program(Vec<AstNode>),
    Statement(Box<AstNode>),
    Block(Vec<AstNode>),
    
    // Declarations
    VariableDeclaration {
        scope: String,
        variables: Vec<AstNode>,
        initializer: Option<Box<AstNode>>,
    },
    SubDeclaration {
        name: String,
        prototype: Option<String>,
        attributes: Vec<String>,
        body: Box<AstNode>,
    },
    PackageDeclaration {
        name: String,
        version: Option<String>,
        block: Option<Box<AstNode>>,
    },
    
    // Control flow
    IfStatement {
        condition: Box<AstNode>,
        then_block: Box<AstNode>,
        elsif_clauses: Vec<(AstNode, AstNode)>,
        else_block: Option<Box<AstNode>>,
    },
    UnlessStatement {
        condition: Box<AstNode>,
        block: Box<AstNode>,
        else_block: Option<Box<AstNode>>,
    },
    WhileStatement {
        label: Option<String>,
        condition: Box<AstNode>,
        block: Box<AstNode>,
    },
    ForStatement {
        label: Option<String>,
        init: Option<Box<AstNode>>,
        condition: Option<Box<AstNode>>,
        update: Option<Box<AstNode>>,
        block: Box<AstNode>,
    },
    ForeachStatement {
        label: Option<String>,
        variable: Option<Box<AstNode>>,
        list: Box<AstNode>,
        block: Box<AstNode>,
    },
    
    // Expressions
    BinaryOp {
        op: String,
        left: Box<AstNode>,
        right: Box<AstNode>,
    },
    UnaryOp {
        op: String,
        operand: Box<AstNode>,
    },
    TernaryOp {
        condition: Box<AstNode>,
        true_expr: Box<AstNode>,
        false_expr: Box<AstNode>,
    },
    Assignment {
        target: Box<AstNode>,
        op: String,
        value: Box<AstNode>,
    },
    FunctionCall {
        function: Box<AstNode>,
        args: Vec<AstNode>,
    },
    MethodCall {
        object: Box<AstNode>,
        method: String,
        args: Vec<AstNode>,
    },
    ArrayAccess {
        array: Box<AstNode>,
        index: Box<AstNode>,
    },
    HashAccess {
        hash: Box<AstNode>,
        key: Box<AstNode>,
    },
    
    // Variables
    ScalarVariable(String),
    ArrayVariable(String),
    HashVariable(String),
    
    // References
    ScalarReference(String),
    ArrayReference(String),
    HashReference(String),
    SubroutineReference(String),
    GlobReference(String),
    ArrayElement {
        array: String,
        index: Box<AstNode>,
    },
    HashElement {
        hash: String,
        key: Box<AstNode>,
    },
    
    // Literals
    Number(String),
    String(String),
    Identifier(String),
    Bareword(String),
    Regex {
        pattern: String,
        flags: String,
        named_groups: Vec<String>,
    },
    Substitution {
        pattern: String,
        replacement: String,
        flags: String,
    },
    
    // Special statements
    UseStatement {
        module: String,
        imports: Vec<String>,
    },
    RequireStatement {
        module: String,
    },
    ReturnStatement {
        value: Option<Box<AstNode>>,
    },
    LastStatement {
        label: Option<String>,
    },
    NextStatement {
        label: Option<String>,
    },
    
    // Other
    Comment(String),
    Label(String),
    LabeledBlock {
        label: String,
        block: Box<AstNode>,
    },
    AnonymousSub {
        prototype: Option<String>,
        body: Box<AstNode>,
    },
    List(Vec<AstNode>),
    ArrayRef(Vec<AstNode>),
    HashRef(Vec<AstNode>),
    
    // Additional Perl constructs
    BeginBlock(Box<AstNode>),
    EndBlock(Box<AstNode>),
    CheckBlock(Box<AstNode>),
    InitBlock(Box<AstNode>),
    UnitcheckBlock(Box<AstNode>),
    
    // Quoting constructs
    QwList(Vec<String>),
    QqString(String),
    QxString(String),
    QrRegex {
        pattern: String,
        flags: String,
        named_groups: Vec<String>,
    },
    
    // Here documents
    Heredoc {
        marker: String,
        indented: bool,
        quoted: bool,
        content: String,
    },
    
    // File operations
    Glob(String),
    Readline {
        filehandle: Option<String>,
    },
    
    // Special constructs
    DoBlock(Box<AstNode>),
    EvalBlock(Box<AstNode>),
    EvalString(Box<AstNode>),
    GotoStatement {
        target: String,
    },
    
    // Data sections
    DataSection(String),
    EndSection(String),
    
    // POD
    Pod(String),
}

/// Pure Rust Perl parser implementation
pub struct PureRustPerlParser;

impl PureRustPerlParser {
    pub fn new() -> Self {
        Self
    }

    pub fn parse(&mut self, source: &str) -> Result<AstNode, Box<dyn std::error::Error>> {
        match <PerlParser as Parser<Rule>>::parse(Rule::program, source) {
            Ok(pairs) => self.build_ast(pairs),
            Err(e) => {
                // Attempt partial parsing by trying to parse individual statements
                self.parse_with_recovery(source, e)
            }
        }
    }
    
    fn parse_with_recovery(&mut self, source: &str, original_error: pest::error::Error<Rule>) -> Result<AstNode, Box<dyn std::error::Error>> {
        let mut statements = Vec::new();
        let lines: Vec<&str> = source.lines().collect();
        let mut current_block = String::new();
        let mut brace_count = 0;
        
        for line in lines {
            current_block.push_str(line);
            current_block.push('\n');
            
            // Count braces to handle multi-line statements
            brace_count += line.chars().filter(|&c| c == '{').count() as i32;
            brace_count -= line.chars().filter(|&c| c == '}').count() as i32;
            
            // Try to parse when we have balanced braces or at semicolons
            if (brace_count == 0 && (line.trim().ends_with(';') || line.trim().ends_with('}'))) 
                || line.trim().is_empty() {
                
                let trimmed = current_block.trim();
                if !trimmed.is_empty() && !trimmed.starts_with('#') {
                    // Try to parse as a complete statement with semicolon
                    let with_semi = if !trimmed.ends_with(';') && !trimmed.ends_with('}') {
                        format!("{};", trimmed)
                    } else {
                        trimmed.to_string()
                    };
                    
                    if let Ok(pairs) = <PerlParser as Parser<Rule>>::parse(Rule::statements, &with_semi) {
                        for pair in pairs {
                            for inner_pair in pair.into_inner() {
                                if let Some(node) = self.build_node(inner_pair).unwrap_or(None) {
                                    statements.push(node);
                                }
                            }
                        }
                        current_block.clear();
                    } else {
                        // If that fails, skip and continue
                        current_block.clear();
                    }
                } else if trimmed.starts_with('#') {
                    // Handle comments
                    statements.push(AstNode::Comment(trimmed.to_string()));
                    current_block.clear();
                }
            }
        }
        
        if statements.is_empty() {
            Err(Box::new(original_error))
        } else {
            Ok(AstNode::Program(statements))
        }
    }

    fn extract_named_groups(&self, pattern: &str) -> Vec<String> {
        let mut groups = Vec::new();
        let chars: Vec<char> = pattern.chars().collect();
        let mut i = 0;
        
        while i < chars.len() {
            if i + 3 < chars.len() && &chars[i..i+3] == &['(', '?', '<'] {
                // Found start of named group
                i += 3;
                let mut name = String::new();
                while i < chars.len() && chars[i] != '>' {
                    name.push(chars[i]);
                    i += 1;
                }
                if !name.is_empty() {
                    groups.push(name);
                }
            }
            i += 1;
        }
        
        groups
    }
    
    fn build_ast(&mut self, pairs: Pairs<Rule>) -> Result<AstNode, Box<dyn std::error::Error>> {
        let mut nodes = Vec::new();
        for pair in pairs {
            if let Some(node) = self.build_node(pair)? {
                nodes.push(node);
            }
        }
        if nodes.len() == 1 {
            Ok(nodes.into_iter().next().unwrap())
        } else {
            Ok(AstNode::Program(nodes))
        }
    }

    fn build_node(&mut self, pair: Pair<Rule>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            Rule::program => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if let Some(node) = self.build_node(inner)? {
                        statements.push(node);
                    }
                }
                Ok(Some(AstNode::Program(statements)))
            }
            Rule::statements => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if let Some(node) = self.build_node(inner)? {
                        statements.push(node);
                    }
                }
                Ok(Some(AstNode::Program(statements)))
            }
            Rule::statement => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::expression_statement => {
                let inner = pair.into_inner().next().unwrap();
                if let Some(expr) = self.build_node(inner)? {
                    Ok(Some(AstNode::Statement(Box::new(expr))))
                } else {
                    Ok(None)
                }
            }
            Rule::declaration_statement => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::variable_declaration => {
                let mut inner = pair.into_inner();
                let scope = inner.next().unwrap().as_str().to_string();
                let mut variables = Vec::new();
                let mut initializer = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::variable_list => {
                            for var in p.into_inner() {
                                if let Some(v) = self.build_node(var)? {
                                    variables.push(v);
                                }
                            }
                        }
                        Rule::expression => {
                            initializer = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::VariableDeclaration {
                    scope,
                    variables,
                    initializer,
                }))
            }
            Rule::sub_declaration => {
                let mut inner = pair.into_inner();
                inner.next(); // skip "sub"
                let name = inner.next().unwrap().as_str().to_string();
                let mut prototype = None;
                let mut attributes = Vec::new();
                let mut body = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::prototype => {
                            prototype = Some(p.as_str().to_string());
                        }
                        Rule::attributes => {
                            for attr in p.into_inner() {
                                attributes.push(attr.as_str().to_string());
                            }
                        }
                        Rule::block => {
                            body = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::SubDeclaration {
                    name,
                    prototype,
                    attributes,
                    body: body.unwrap_or_else(|| Box::new(AstNode::Block(vec![]))),
                }))
            }
            Rule::if_statement => {
                let mut inner = pair.into_inner();
                // The first item should be the expression (condition)
                let condition = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                // The second item should be the block
                let then_block = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let mut elsif_clauses = Vec::new();
                let mut else_block = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::elsif_clause => {
                            let mut elsif_inner = p.into_inner();
                            // First is the condition expression
                            let cond = self.build_node(elsif_inner.next().unwrap())?.unwrap();
                            // Second is the block
                            let block = self.build_node(elsif_inner.next().unwrap())?.unwrap();
                            elsif_clauses.push((cond, block));
                        }
                        Rule::else_clause => {
                            let mut else_inner = p.into_inner();
                            // The only item should be the block
                            else_block = self.build_node(else_inner.next().unwrap())?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::IfStatement {
                    condition,
                    then_block,
                    elsif_clauses,
                    else_block,
                }))
            }
            Rule::block => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::statements {
                        for stmt in inner.into_inner() {
                            if let Some(node) = self.build_node(stmt)? {
                                statements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::Block(statements)))
            }
            Rule::expression => {
                self.build_expression(pair)
            }
            Rule::assignment_expression => {
                let mut inner = pair.into_inner();
                let target = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let op = inner.next().unwrap().as_str().to_string();
                let value = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                Ok(Some(AstNode::Assignment { target, op, value }))
            }
            Rule::scalar_variable => {
                Ok(Some(AstNode::ScalarVariable(pair.as_str().to_string())))
            }
            Rule::array_variable => {
                Ok(Some(AstNode::ArrayVariable(pair.as_str().to_string())))
            }
            Rule::hash_variable => {
                Ok(Some(AstNode::HashVariable(pair.as_str().to_string())))
            }
            Rule::number => {
                Ok(Some(AstNode::Number(pair.as_str().to_string())))
            }
            Rule::identifier => {
                Ok(Some(AstNode::Identifier(pair.as_str().to_string())))
            }
            Rule::string | Rule::single_quoted_string | Rule::double_quoted_string => {
                Ok(Some(AstNode::String(pair.as_str().to_string())))
            }
            Rule::qq_string => {
                // Extract the content from qq{...}
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::QqString(inner.as_str().to_string())))
            }
            Rule::heredoc => {
                let inner = pair.into_inner();
                let mut indented = false;
                let mut marker = String::new();
                let mut quoted = false;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::heredoc_indented => {
                            indented = true;
                        }
                        Rule::heredoc_delimiter => {
                            let delimiter_str = p.as_str();
                            let delimiter_inner = p.into_inner().next();
                            if let Some(d) = delimiter_inner {
                                match d.as_rule() {
                                    Rule::heredoc_single_quoted => {
                                        quoted = true;
                                        marker = d.as_str().trim_matches('\'').to_string();
                                    }
                                    Rule::heredoc_double_quoted => {
                                        marker = d.as_str().trim_matches('"').to_string();
                                    }
                                    Rule::heredoc_backtick => {
                                        marker = d.as_str().trim_matches('`').to_string();
                                    }
                                    Rule::heredoc_escaped => {
                                        marker = d.as_str().trim_start_matches('\\').to_string();
                                    }
                                    Rule::bare_heredoc_delimiter => {
                                        marker = d.as_str().to_string();
                                    }
                                    _ => {}
                                }
                            } else {
                                marker = delimiter_str.to_string();
                            }
                        }
                        _ => {}
                    }
                }
                
                // Note: In a real implementation, we would need to collect the heredoc content
                // from subsequent lines until we find the marker. For now, we just create
                // a placeholder.
                Ok(Some(AstNode::Heredoc {
                    marker,
                    indented,
                    quoted,
                    content: String::new(), // This would be filled by a stateful parser
                }))
            }
            Rule::list => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::list_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::List(elements)))
            }
            Rule::array_ref => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::list_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::ArrayRef(elements)))
            }
            Rule::hash_ref => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::hash_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::HashRef(elements)))
            }
            Rule::begin_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::BeginBlock(b)))
            }
            Rule::end_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::EndBlock(b)))
            }
            Rule::check_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::CheckBlock(b)))
            }
            Rule::init_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::InitBlock(b)))
            }
            Rule::unitcheck_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::UnitcheckBlock(b)))
            }
            Rule::qw_list => {
                let mut words = Vec::new();
                for inner in pair.into_inner() {
                    match inner.as_rule() {
                        Rule::qw_paren_items | Rule::qw_bracket_items | 
                        Rule::qw_brace_items | Rule::qw_angle_items |
                        Rule::qw_delimited_items => {
                            // Split the content by whitespace
                            let content = inner.as_str();
                            words.extend(content.split_whitespace().map(|s| s.to_string()));
                        }
                        _ => {}
                    }
                }
                Ok(Some(AstNode::QwList(words)))
            }
            Rule::do_block => {
                let inner = pair.into_inner().next().unwrap();
                let expr = self.build_node(inner)?.map(Box::new);
                Ok(expr.map(|e| AstNode::DoBlock(e)))
            }
            Rule::eval_statement => {
                let inner = pair.into_inner().next().unwrap();
                let expr = self.build_node(inner)?;
                Ok(expr.map(|e| match e {
                    AstNode::Block(_) => AstNode::EvalBlock(Box::new(e)),
                    _ => AstNode::EvalString(Box::new(e)),
                }))
            }
            Rule::goto_statement => {
                let inner = pair.into_inner().next().unwrap();
                let target = match inner.as_rule() {
                    Rule::goto_target => inner.as_str().to_string(),
                    _ => {
                        // For expressions, we need to evaluate them
                        if let Some(expr) = self.build_node(inner)? {
                            format!("{:?}", expr) // Simple representation for now
                        } else {
                            String::new()
                        }
                    }
                };
                Ok(Some(AstNode::GotoStatement { target }))
            }
            Rule::pod_section => {
                Ok(Some(AstNode::Pod(pair.as_str().to_string())))
            }
            Rule::data_section => {
                Ok(Some(AstNode::DataSection(pair.as_str().to_string())))
            }
            Rule::end_section => {
                Ok(Some(AstNode::EndSection(pair.as_str().to_string())))
            }
            Rule::labeled_block => {
                let mut inner = pair.into_inner();
                let label_pair = inner.next().unwrap();
                let label = label_pair.as_str().trim_end_matches(':').to_string();
                let block = self.build_node(inner.next().unwrap())?.map(Box::new);
                Ok(block.map(|b| AstNode::LabeledBlock { label, block: b }))
            }
            Rule::comment => {
                Ok(Some(AstNode::Comment(pair.as_str().to_string())))
            }
            Rule::semicolon | Rule::WHITESPACE => Ok(None),
            Rule::standalone_expression => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::regex => {
                let mut inner = pair.into_inner();
                if let Some(first) = inner.next() {
                    match first.as_rule() {
                        rule if rule == Rule::match_regex => {
                            let mut match_inner = first.into_inner();
                            let pattern = match_inner.next().map(|p| p.as_str().to_string()).unwrap_or_default();
                            let flags = match_inner.next().map(|p| p.as_str().to_string()).unwrap_or_default();
                            
                            // Extract named groups from pattern
                            let named_groups = self.extract_named_groups(&pattern);
                            
                            Ok(Some(AstNode::Regex { pattern, flags, named_groups }))
                        }
                        _ => {
                            let pattern = first.as_str().to_string();
                            let flags = inner.next().map(|p| p.as_str().to_string()).unwrap_or_default();
                            let named_groups = self.extract_named_groups(&pattern);
                            Ok(Some(AstNode::Regex { pattern, flags, named_groups }))
                        }
                    }
                } else {
                    Ok(Some(AstNode::Regex { pattern: String::new(), flags: String::new(), named_groups: Vec::new() }))
                }
            }
            Rule::for_statement => {
                let inner = pair.into_inner();
                let label = None; // TODO: handle label if present
                // Don't skip "for" - it's already consumed by the grammar
                let mut init = None;
                let mut condition = None;
                let mut update = None;
                let mut block = None;
                
                // Parse for loop components
                for p in inner {
                    match p.as_rule() {
                        Rule::for_init => {
                            init = self.build_node(p)?.map(Box::new);
                        }
                        Rule::expression => {
                            if condition.is_none() {
                                condition = self.build_node(p)?.map(Box::new);
                            } else if update.is_none() {
                                update = self.build_node(p)?.map(Box::new);
                            }
                        }
                        Rule::block => {
                            block = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::ForStatement {
                    label,
                    init,
                    condition,
                    update,
                    block: block.unwrap_or_else(|| Box::new(AstNode::Block(vec![]))),
                }))
            }
            Rule::package_declaration => {
                let mut inner = pair.into_inner();
                inner.next(); // skip "package"
                // Accept qualified_name as identifier
                let name = if let Some(name_pair) = inner.next() {
                    name_pair.as_str().to_string()
                } else {
                    String::new()
                };
                let mut version = None;
                let mut block = None;
                for p in inner {
                    match p.as_rule() {
                        Rule::version => version = Some(p.as_str().to_string()),
                        Rule::block => block = self.build_node(p)?.map(Box::new),
                        _ => {}
                    }
                }
                Ok(Some(AstNode::PackageDeclaration { name, version, block }))
            }
            Rule::relational_expression => {
                let mut inner = pair.into_inner();
                let left = if let Some(first) = inner.next() {
                    self.build_node(first)?.map(Box::new)
                } else {
                    return Ok(None);
                };
                if let Some(op_pair) = inner.next() {
                    let op = op_pair.as_str().to_string();
                    let right = if let Some(second) = inner.next() {
                        self.build_node(second)?.map(Box::new)
                    } else {
                        return Ok(left.map(|l| *l));
                    };
                    match (left, right) {
                        (Some(left), Some(right)) => Ok(Some(AstNode::BinaryOp { op, left, right })),
                        (Some(left), None) => Ok(Some(*left)),
                        (None, Some(right)) => Ok(Some(*right)),
                        (None, None) => Ok(None),
                    }
                } else {
                    Ok(left.map(|l| *l))
                }
            }
            Rule::interpolation => {
                // Handle interpolation within strings
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::complex_scalar_interpolation => {
                // ${expr} form
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::complex_array_interpolation => {
                // @{[expr]} form  
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::reference => {
                // Handle variable references
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::scalar_reference => {
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::ScalarReference(inner.as_str().to_string())))
            }
            Rule::array_reference => {
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::ArrayReference(inner.as_str().to_string())))
            }
            Rule::hash_reference => {
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::HashReference(inner.as_str().to_string())))
            }
            Rule::subroutine_reference => {
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::SubroutineReference(inner.as_str().to_string())))
            }
            Rule::glob_reference => {
                let inner = pair.into_inner().next().unwrap();
                Ok(Some(AstNode::GlobReference(inner.as_str().to_string())))
            }
            _ => {
                // For unhandled rules, try to process inner pairs
                let inner: Vec<_> = pair.into_inner().collect();
                if inner.is_empty() {
                    Ok(None)
                } else if inner.len() == 1 {
                    self.build_node(inner.into_iter().next().unwrap())
                } else {
                    let mut nodes = Vec::new();
                    for p in inner {
                        if let Some(node) = self.build_node(p)? {
                            nodes.push(node);
                        }
                    }
                    if nodes.is_empty() {
                        Ok(None)
                    } else if nodes.len() == 1 {
                        Ok(nodes.into_iter().next())
                    } else {
                        Ok(Some(AstNode::List(nodes)))
                    }
                }
            }
        }
    }

    fn build_expression(&mut self, pair: Pair<Rule>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        // This is a simplified expression builder
        // In a full implementation, this would handle operator precedence
        let inner: Vec<_> = pair.into_inner().collect();
        if inner.is_empty() {
            Ok(None)
        } else if inner.len() == 1 {
            self.build_node(inner.into_iter().next().unwrap())
        } else {
            // For now, just return the first node
            self.build_node(inner.into_iter().next().unwrap())
        }
    }

    pub fn to_sexp(&self, node: &AstNode) -> String {
        Self::node_to_sexp(node)
    }

    fn node_to_sexp(node: &AstNode) -> String {
        match node {
            AstNode::Program(children) => {
                // Remove nested source_file in S-expression output
                let mut flat_children = vec![];
                for c in children {
                    let sexp = Self::node_to_sexp(c);
                    if sexp.starts_with("(source_file ") {
                        let inner = sexp.trim_start_matches("(source_file ").trim_end_matches(")");
                        flat_children.push(inner.to_string());
                    } else {
                        flat_children.push(sexp);
                    }
                }
                if flat_children.is_empty() {
                    "(source_file)".to_string()
                } else {
                    format!("(source_file {})", flat_children.join(" "))
                }
            }
            AstNode::Statement(expr) => {
                Self::node_to_sexp(expr)
            }
            AstNode::Block(statements) => {
                let stmt_sexps: Vec<String> = statements.iter().map(Self::node_to_sexp).collect();
                format!("(block {})", stmt_sexps.join(" "))
            }
            AstNode::VariableDeclaration { scope, variables, initializer } => {
                let var_sexps: Vec<String> = variables.iter().map(Self::node_to_sexp).collect();
                let init_sexp = initializer.as_ref().map(|i| Self::node_to_sexp(i)).unwrap_or_default();
                format!("(variable_declaration ({}) {} {})", scope, var_sexps.join(" "), init_sexp)
            }
            AstNode::SubDeclaration { name, body, .. } => {
                format!("(subroutine (identifier {}) {})", name, Self::node_to_sexp(body))
            }
            AstNode::IfStatement { condition, then_block, .. } => {
                format!("(if_statement {} {})", Self::node_to_sexp(condition), Self::node_to_sexp(then_block))
            }
            AstNode::Assignment { target, op, value } => {
                format!("(assignment {} ({}) {})", Self::node_to_sexp(target), op, Self::node_to_sexp(value))
            }
            AstNode::BinaryOp { op, left, right } => {
                format!("(binary_expression {} ({}) {})", Self::node_to_sexp(left), op, Self::node_to_sexp(right))
            }
            AstNode::ScalarVariable(name) => {
                format!("(scalar_variable {})", name)
            }
            AstNode::ArrayVariable(name) => {
                format!("(array_variable {})", name)
            }
            AstNode::HashVariable(name) => {
                format!("(hash_variable {})", name)
            }
            AstNode::ScalarReference(name) => {
                format!("(scalar_reference {})", name)
            }
            AstNode::ArrayReference(name) => {
                format!("(array_reference {})", name)
            }
            AstNode::HashReference(name) => {
                format!("(hash_reference {})", name)
            }
            AstNode::SubroutineReference(name) => {
                format!("(subroutine_reference {})", name)
            }
            AstNode::GlobReference(name) => {
                format!("(glob_reference {})", name)
            }
            AstNode::Number(value) => {
                format!("(number {})", value)
            }
            AstNode::String(value) => {
                format!("(string_literal {})", value)
            }
            AstNode::Identifier(name) => {
                format!("(identifier {})", name)
            }
            AstNode::Comment(content) => {
                format!("(comment {})", content)
            }
            AstNode::List(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                item_sexps.join(" ")
            }
            AstNode::ArrayRef(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                format!("(array_ref {})", item_sexps.join(" "))
            }
            AstNode::HashRef(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                format!("(hash_ref {})", item_sexps.join(" "))
            }
            AstNode::ForStatement { init, condition, update, block, .. } => {
                let mut parts = vec![];
                if let Some(i) = init { parts.push(format!("(init {})", Self::node_to_sexp(i))); }
                if let Some(c) = condition { parts.push(format!("(condition {})", Self::node_to_sexp(c))); }
                if let Some(u) = update { parts.push(format!("(update {})", Self::node_to_sexp(u))); }
                parts.push(format!("(body {})", Self::node_to_sexp(block)));
                format!("(for_statement {})", parts.join(" "))
            }
            AstNode::PackageDeclaration { name, version, block } => {
                let mut parts = vec![format!("(name {})", name)];
                if let Some(v) = version { parts.push(format!("(version {})", v)); }
                if let Some(b) = block { parts.push(format!("(body {})", Self::node_to_sexp(b))); }
                format!("(package_declaration {})", parts.join(" "))
            }
            AstNode::Regex { pattern, flags, named_groups } => {
                let groups_str = if !named_groups.is_empty() {
                    format!(" (named_groups {})", named_groups.join(" "))
                } else {
                    String::new()
                };
                format!("(regex {} {}{})", pattern, flags, groups_str)
            }
            AstNode::BeginBlock(block) => {
                format!("(begin_block {})", Self::node_to_sexp(block))
            }
            AstNode::EndBlock(block) => {
                format!("(end_block {})", Self::node_to_sexp(block))
            }
            AstNode::CheckBlock(block) => {
                format!("(check_block {})", Self::node_to_sexp(block))
            }
            AstNode::InitBlock(block) => {
                format!("(init_block {})", Self::node_to_sexp(block))
            }
            AstNode::UnitcheckBlock(block) => {
                format!("(unitcheck_block {})", Self::node_to_sexp(block))
            }
            AstNode::QwList(words) => {
                let word_list = words.iter().map(|w| format!("(word {})", w)).collect::<Vec<_>>().join(" ");
                format!("(qw_list {})", word_list)
            }
            AstNode::DoBlock(expr) => {
                format!("(do_block {})", Self::node_to_sexp(expr))
            }
            AstNode::EvalBlock(block) => {
                format!("(eval_block {})", Self::node_to_sexp(block))
            }
            AstNode::EvalString(expr) => {
                format!("(eval_string {})", Self::node_to_sexp(expr))
            }
            AstNode::GotoStatement { target } => {
                format!("(goto_statement {})", target)
            }
            AstNode::LabeledBlock { label, block } => {
                format!("(labeled_block {} {})", label, Self::node_to_sexp(block))
            }
            AstNode::Heredoc { marker, indented, quoted, content } => {
                let flags = format!("{}{}",
                    if *indented { "~" } else { "" },
                    if *quoted { "'" } else { "" }
                );
                format!("(heredoc {} {} \"{}\")", marker, flags, content.escape_default())
            }
            AstNode::Pod(content) => {
                format!("(pod {})", content)
            }
            AstNode::DataSection(content) => {
                format!("(data_section {})", content)
            }
            AstNode::EndSection(content) => {
                format!("(end_section {})", content)
            }
            _ => format!("(unhandled_node {:?})", node),
        }
    }
}

impl Default for PureRustPerlParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "$var";
        let result = parser.parse(source);
        assert!(result.is_ok());
        let ast = result.unwrap();
        let sexp = parser.to_sexp(&ast);
        println!("AST: {:?}", ast);
        println!("S-expression: {}", sexp);
    }

    #[test]
    fn test_variable_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "$scalar @array %hash";
        let result = parser.parse(source);
        assert!(result.is_ok());
        let ast = result.unwrap();
        let sexp = parser.to_sexp(&ast);
        println!("S-expression: {}", sexp);
    }

    #[test]
    fn test_assignment_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "my $var = 42;";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Success! AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_function_declaration() {
        let mut parser = PureRustPerlParser::new();
        let source = "sub hello { print 'Hello'; }";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_if_statement() {
        let mut parser = PureRustPerlParser::new();
        let source = "if ($x > 0) { print 'positive'; }";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_array_assignment() {
        let mut parser = PureRustPerlParser::new();
        let source = "@array = (1, 2, 3);";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Array assignment AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_hash_assignment() {
        let mut parser = PureRustPerlParser::new();
        let source = "%hash = (a => 1, b => 2);";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Hash assignment AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
}