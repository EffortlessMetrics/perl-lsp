//! Pure Rust Perl parser implementation
//!
//! This module provides a complete Rust-native implementation of the Perl parser
//! using Pest for grammar parsing, without any dependency on tree-sitter's C code.

use pest::{iterators::{Pair, Pairs}, Parser};
use pest_derive::Parser;
use std::sync::Arc;
use crate::pratt_parser::PrattParser;

#[derive(Parser)]
#[grammar = "grammar.pest"]
pub struct PerlParser;

// The Rule type is generated by pest_derive


// The Rule enum is generated by pest_derive in this module

/// AST node types for the pure Rust parser
#[derive(Debug, Clone, PartialEq)]
pub enum AstNode {
    // Program structure
    Program(Vec<AstNode>),
    Statement(Box<AstNode>),
    Block(Vec<AstNode>),
    
    // Declarations
    VariableDeclaration {
        scope: Arc<str>,
        variables: Vec<AstNode>,
        initializer: Option<Box<AstNode>>,
    },
    SubDeclaration {
        name: Arc<str>,
        prototype: Option<Arc<str>>,
        attributes: Vec<Arc<str>>,
        body: Box<AstNode>,
    },
    FormatDeclaration {
        name: Arc<str>,
        format_lines: Vec<Arc<str>>,
    },
    PackageDeclaration {
        name: Arc<str>,
        version: Option<Arc<str>>,
        block: Option<Box<AstNode>>,
    },
    UseStatement {
        module: Arc<str>,
        version: Option<Arc<str>>,
        import_list: Vec<Arc<str>>,
    },
    RequireStatement {
        module: Arc<str>,
    },
    
    // Control flow
    IfStatement {
        condition: Box<AstNode>,
        then_block: Box<AstNode>,
        elsif_clauses: Vec<(AstNode, AstNode)>,
        else_block: Option<Box<AstNode>>,
    },
    UnlessStatement {
        condition: Box<AstNode>,
        block: Box<AstNode>,
        else_block: Option<Box<AstNode>>,
    },
    GivenStatement {
        expression: Box<AstNode>,
        when_clauses: Vec<(AstNode, AstNode)>,
        default_block: Option<Box<AstNode>>,
    },
    WhileStatement {
        label: Option<Arc<str>>,
        condition: Box<AstNode>,
        block: Box<AstNode>,
    },
    ForStatement {
        label: Option<Arc<str>>,
        init: Option<Box<AstNode>>,
        condition: Option<Box<AstNode>>,
        update: Option<Box<AstNode>>,
        block: Box<AstNode>,
    },
    ForeachStatement {
        label: Option<Arc<str>>,
        variable: Option<Box<AstNode>>,
        list: Box<AstNode>,
        block: Box<AstNode>,
    },
    
    // Expressions
    BinaryOp {
        op: Arc<str>,
        left: Box<AstNode>,
        right: Box<AstNode>,
    },
    UnaryOp {
        op: Arc<str>,
        operand: Box<AstNode>,
    },
    TernaryOp {
        condition: Box<AstNode>,
        true_expr: Box<AstNode>,
        false_expr: Box<AstNode>,
    },
    PostfixDereference {
        expr: Box<AstNode>,
        deref_type: Arc<str>,
    },
    TypeglobSlotAccess {
        typeglob: Box<AstNode>,
        slot: Arc<str>,
    },
    Assignment {
        target: Box<AstNode>,
        op: Arc<str>,
        value: Box<AstNode>,
    },
    FunctionCall {
        function: Box<AstNode>,
        args: Vec<AstNode>,
    },
    MethodCall {
        object: Box<AstNode>,
        method: Arc<str>,
        args: Vec<AstNode>,
    },
    ArrayAccess {
        array: Box<AstNode>,
        index: Box<AstNode>,
    },
    HashAccess {
        hash: Box<AstNode>,
        key: Box<AstNode>,
    },
    
    // Variables
    ScalarVariable(Arc<str>),
    ArrayVariable(Arc<str>),
    HashVariable(Arc<str>),
    TypeglobVariable(Arc<str>),
    
    // References
    ScalarReference(Arc<str>),
    ArrayReference(Arc<str>),
    HashReference(Arc<str>),
    SubroutineReference(Arc<str>),
    GlobReference(Arc<str>),
    ArrayElement {
        array: Arc<str>,
        index: Box<AstNode>,
    },
    HashElement {
        hash: Arc<str>,
        key: Box<AstNode>,
    },
    
    // Literals
    Number(Arc<str>),
    String(Arc<str>),
    Identifier(Arc<str>),
    Bareword(Arc<str>),
    Regex {
        pattern: Arc<str>,
        flags: Arc<str>,
        named_groups: Vec<Arc<str>>,
    },
    Substitution {
        pattern: Arc<str>,
        replacement: Arc<str>,
        flags: Arc<str>,
    },
    ReturnStatement {
        value: Option<Box<AstNode>>,
    },
    LastStatement {
        label: Option<Arc<str>>,
    },
    NextStatement {
        label: Option<Arc<str>>,
    },
    TieStatement {
        variable: Box<AstNode>,
        class: Box<AstNode>,
        args: Vec<AstNode>,
    },
    UntieStatement {
        variable: Box<AstNode>,
    },
    TiedExpression {
        variable: Box<AstNode>,
    },
    
    // Other
    Comment(Arc<str>),
    Label(Arc<str>),
    LabeledBlock {
        label: Arc<str>,
        block: Box<AstNode>,
    },
    AnonymousSub {
        prototype: Option<Arc<str>>,
        body: Box<AstNode>,
    },
    List(Vec<AstNode>),
    ArrayRef(Vec<AstNode>),
    HashRef(Vec<AstNode>),
    
    // Additional Perl constructs
    BeginBlock(Box<AstNode>),
    EndBlock(Box<AstNode>),
    CheckBlock(Box<AstNode>),
    InitBlock(Box<AstNode>),
    UnitcheckBlock(Box<AstNode>),
    
    // Quoting constructs
    QwList(Vec<Arc<str>>),
    QqString(Arc<str>),
    QxString(Arc<str>),
    QrRegex {
        pattern: Arc<str>,
        flags: Arc<str>,
        named_groups: Vec<Arc<str>>,
    },
    
    // Here documents
    Heredoc {
        marker: Arc<str>,
        indented: bool,
        quoted: bool,
        content: Arc<str>,
    },
    
    // File operations
    Glob(Arc<str>),
    Readline {
        filehandle: Option<Arc<str>>,
    },
    
    // Special constructs
    DoBlock(Box<AstNode>),
    EvalBlock(Box<AstNode>),
    EvalString(Box<AstNode>),
    GotoStatement {
        target: Arc<str>,
    },
    
    // Data sections
    DataSection(Arc<str>),
    EndSection(Arc<str>),
    
    // POD
    Pod(Arc<str>),
}

/// Pure Rust Perl parser implementation
pub struct PureRustPerlParser {
    pratt_parser: PrattParser,
}

impl PureRustPerlParser {
    pub fn new() -> Self {
        Self {
            pratt_parser: PrattParser::new(),
        }
    }

    #[inline(always)]
    pub fn parse(&mut self, source: &str) -> Result<AstNode, Box<dyn std::error::Error>> {
        match <PerlParser as Parser<Rule>>::parse(Rule::program, source) {
            Ok(pairs) => self.build_ast(pairs),
            Err(e) => {
                // Attempt partial parsing by trying to parse individual statements
                self.parse_with_recovery(source, e)
            }
        }
    }
    
    fn parse_with_recovery(&mut self, source: &str, original_error: pest::error::Error<Rule>) -> Result<AstNode, Box<dyn std::error::Error>> {
        let mut statements = Vec::new();
        let lines: Vec<&str> = source.lines().collect();
        let mut current_block = String::new();
        let mut brace_count = 0;
        
        for line in lines {
            current_block.push_str(line);
            current_block.push('\n');
            
            // Count braces to handle multi-line statements
            brace_count += line.chars().filter(|&c| c == '{').count() as i32;
            brace_count -= line.chars().filter(|&c| c == '}').count() as i32;
            
            // Try to parse when we have balanced braces or at semicolons
            if (brace_count == 0 && (line.trim().ends_with(';') || line.trim().ends_with('}'))) 
                || line.trim().is_empty() {
                
                let trimmed = current_block.trim();
                if !trimmed.is_empty() && !trimmed.starts_with('#') {
                    // Try to parse as a complete statement with semicolon
                    let with_semi = if !trimmed.ends_with(';') && !trimmed.ends_with('}') {
                        format!("{};", trimmed)
                    } else {
                        trimmed.to_string()
                    };
                    
                    if let Ok(pairs) = <PerlParser as Parser<Rule>>::parse(Rule::statements, &with_semi) {
                        for pair in pairs {
                            for inner_pair in pair.into_inner() {
                                if let Some(node) = self.build_node(inner_pair).unwrap_or(None) {
                                    statements.push(node);
                                }
                            }
                        }
                        current_block.clear();
                    } else {
                        // If that fails, skip and continue
                        current_block.clear();
                    }
                } else if trimmed.starts_with('#') {
                    // Handle comments
                    statements.push(AstNode::Comment(Arc::from(trimmed)));
                    current_block.clear();
                }
            }
        }
        
        if statements.is_empty() {
            Err(Box::new(original_error))
        } else {
            Ok(AstNode::Program(statements))
        }
    }

    fn extract_named_groups(&self, pattern: &str) -> Vec<Arc<str>> {
        let mut groups = Vec::new();
        let chars: Vec<char> = pattern.chars().collect();
        let mut i = 0;
        
        while i < chars.len() {
            if i + 3 < chars.len() && &chars[i..i+3] == &['(', '?', '<'] {
                // Found start of named group
                i += 3;
                let mut name = String::new();
                while i < chars.len() && chars[i] != '>' {
                    name.push(chars[i]);
                    i += 1;
                }
                if !name.is_empty() {
                    groups.push(Arc::from(name));
                }
            }
            i += 1;
        }
        
        groups
    }
    
    fn build_ast(&mut self, pairs: Pairs<Rule>) -> Result<AstNode, Box<dyn std::error::Error>> {
        let mut nodes = Vec::new();
        for pair in pairs {
            if let Some(node) = self.build_node(pair)? {
                nodes.push(node);
            }
        }
        if nodes.len() == 1 {
            Ok(nodes.into_iter().next().unwrap())
        } else {
            Ok(AstNode::Program(nodes))
        }
    }

    #[inline]
    pub(crate) fn build_node(&mut self, pair: Pair<Rule>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        match pair.as_rule() {
            // Fast-path rules
            Rule::simple_assignment => {
                let mut inner = pair.into_inner();
                let var = self.build_node(inner.next().unwrap())?.unwrap();
                let value = self.build_node(inner.next().unwrap())?.unwrap();
                Ok(Some(AstNode::Assignment {
                    target: Box::new(var),
                    op: Arc::from("="),
                    value: Box::new(value),
                }))
            }
            Rule::simple_method_call => {
                let mut inner = pair.into_inner();
                let object = self.build_node(inner.next().unwrap())?.unwrap();
                let method = Arc::from(inner.next().unwrap().as_str());
                Ok(Some(AstNode::MethodCall {
                    object: Box::new(object),
                    method,
                    args: vec![],
                }))
            }
            Rule::simple_function_call => {
                let mut inner = pair.into_inner();
                let func_name = inner.next().unwrap().as_str();
                let func = AstNode::Identifier(Arc::from(func_name));
                let mut args = vec![];
                if let Some(arg) = inner.next() {
                    if let Some(node) = self.build_node(arg)? {
                        args.push(node);
                    }
                }
                Ok(Some(AstNode::FunctionCall {
                    function: Box::new(func),
                    args,
                }))
            }
            Rule::program => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if let Some(node) = self.build_node(inner)? {
                        statements.push(node);
                    }
                }
                Ok(Some(AstNode::Program(statements)))
            }
            Rule::statements => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if let Some(node) = self.build_node(inner)? {
                        statements.push(node);
                    }
                }
                Ok(Some(AstNode::Program(statements)))
            }
            Rule::statement => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::expression_statement => {
                let inner = pair.into_inner().next().unwrap();
                if let Some(expr) = self.build_node(inner)? {
                    Ok(Some(AstNode::Statement(Box::new(expr))))
                } else {
                    Ok(None)
                }
            }
            Rule::declaration_statement => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::variable_declaration => {
                let mut inner = pair.into_inner();
                let scope = Arc::from(inner.next().unwrap().as_str());
                let mut variables = Vec::new();
                let mut initializer = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::variable_list => {
                            for var in p.into_inner() {
                                if let Some(v) = self.build_node(var)? {
                                    variables.push(v);
                                }
                            }
                        }
                        Rule::expression => {
                            initializer = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::VariableDeclaration {
                    scope,
                    variables,
                    initializer,
                }))
            }
            Rule::sub_declaration => {
                let inner = pair.into_inner();
                let mut _sub_modifier = None;
                let mut name = Arc::from("");
                let mut prototype = None;
                let mut attributes = Vec::new();
                let mut body = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::sub_modifier => {
                            _sub_modifier = Some(p.as_str().to_string());
                        }
                        Rule::identifier => {
                            name = Arc::from(p.as_str());
                        }
                        Rule::prototype => {
                            prototype = Some(Arc::from(p.as_str()));
                        }
                        Rule::signature => {
                            prototype = Some(Arc::from(p.as_str()));
                        }
                        Rule::attributes => {
                            for attr in p.into_inner() {
                                attributes.push(Arc::from(attr.as_str()));
                            }
                        }
                        Rule::block => {
                            body = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::SubDeclaration {
                    name,
                    prototype,
                    attributes,
                    body: body.unwrap_or_else(|| Box::new(AstNode::Block(vec![]))),
                }))
            }
            Rule::format_declaration => {
                let inner = pair.into_inner();
                let mut name = Arc::from("");
                let mut format_lines = Vec::new();
                
                for p in inner {
                    match p.as_rule() {
                        Rule::format_name => {
                            name = Arc::from(p.as_str());
                        }
                        Rule::format_lines => {
                            for line in p.into_inner() {
                                if line.as_rule() == Rule::format_line {
                                    format_lines.push(Arc::from(line.as_str()));
                                }
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::FormatDeclaration {
                    name,
                    format_lines,
                }))
            }
            Rule::if_statement => {
                let mut inner = pair.into_inner();
                // The first item should be the expression (condition)
                let condition = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                // The second item should be the block
                let then_block = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let mut elsif_clauses = Vec::new();
                let mut else_block = None;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::elsif_clause => {
                            let mut elsif_inner = p.into_inner();
                            // First is the condition expression
                            let cond = self.build_node(elsif_inner.next().unwrap())?.unwrap();
                            // Second is the block
                            let block = self.build_node(elsif_inner.next().unwrap())?.unwrap();
                            elsif_clauses.push((cond, block));
                        }
                        Rule::else_clause => {
                            let mut else_inner = p.into_inner();
                            // The only item should be the block
                            else_block = self.build_node(else_inner.next().unwrap())?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::IfStatement {
                    condition,
                    then_block,
                    elsif_clauses,
                    else_block,
                }))
            }
            Rule::tie_statement => {
                let mut inner = pair.into_inner();
                let variable = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let class = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let mut args = Vec::new();
                
                for arg in inner {
                    if let Some(node) = self.build_node(arg)? {
                        args.push(node);
                    }
                }
                
                Ok(Some(AstNode::TieStatement {
                    variable,
                    class,
                    args,
                }))
            }
            Rule::untie_statement => {
                let mut inner = pair.into_inner();
                let variable = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                
                Ok(Some(AstNode::UntieStatement {
                    variable,
                }))
            }
            Rule::tied_statement => {
                let mut inner = pair.into_inner();
                let variable = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                
                Ok(Some(AstNode::TiedExpression {
                    variable,
                }))
            }
            Rule::given_statement => {
                let mut inner = pair.into_inner();
                let expression = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let given_block = inner.next().unwrap();
                
                let mut when_clauses = Vec::new();
                let mut default_block = None;
                
                for p in given_block.into_inner() {
                    match p.as_rule() {
                        Rule::when_clause => {
                            let mut when_inner = p.into_inner();
                            let when_cond = when_inner.next().unwrap();
                            let cond = self.build_node(when_cond.into_inner().next().unwrap())?.unwrap();
                            let block = self.build_node(when_inner.next().unwrap())?.unwrap();
                            when_clauses.push((cond, block));
                        }
                        Rule::default_clause => {
                            let mut default_inner = p.into_inner();
                            default_block = Some(Box::new(self.build_node(default_inner.next().unwrap())?.unwrap()));
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::GivenStatement {
                    expression,
                    when_clauses,
                    default_block,
                }))
            }
            Rule::block => {
                let mut statements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::statements {
                        for stmt in inner.into_inner() {
                            if let Some(node) = self.build_node(stmt)? {
                                statements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::Block(statements)))
            }
            Rule::expression => {
                self.build_expression(pair)
            }
            Rule::logical_or_expression => {
                self.build_binary_expression(pair, Rule::logical_or_expression)
            }
            Rule::defined_or_expression => {
                self.build_binary_expression(pair, Rule::defined_or_expression)
            }
            Rule::logical_and_expression => {
                self.build_binary_expression(pair, Rule::logical_and_expression)
            }
            Rule::equality_expression => {
                self.build_binary_expression(pair, Rule::equality_expression)
            }
            Rule::relational_expression => {
                self.build_binary_expression(pair, Rule::relational_expression)
            }
            Rule::isa_expression => {
                self.build_binary_expression(pair, Rule::isa_expression)
            }
            Rule::bitwise_expression => {
                self.build_binary_expression(pair, Rule::bitwise_expression)
            }
            Rule::bitwise_string_expression => {
                self.build_binary_expression(pair, Rule::bitwise_string_expression)
            }
            Rule::assignment_expression => {
                let mut inner = pair.into_inner();
                let target = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                let op = Arc::from(inner.next().unwrap().as_str());
                let value = Box::new(self.build_node(inner.next().unwrap())?.unwrap());
                Ok(Some(AstNode::Assignment { target, op, value }))
            }
            Rule::unary_expression => {
                let mut inner = pair.into_inner();
                let first = inner.next().unwrap();
                
                // Check if it's an operator or operand
                match first.as_rule() {
                    Rule::postfix_expression | Rule::reference => {
                        // No unary operator, just pass through
                        self.build_node(first)
                    }
                    _ => {
                        // It's an operator
                        let op = Arc::from(first.as_str());
                        if let Some(next_pair) = inner.next() {
                            if let Some(operand_node) = self.build_node(next_pair)? {
                                let operand = Box::new(operand_node);
                                Ok(Some(AstNode::UnaryOp { op, operand }))
                            } else {
                                Ok(None)
                            }
                        } else {
                            Ok(None)
                        }
                    }
                }
            }
            Rule::postfix_expression => {
                let mut inner = pair.into_inner();
                let mut expr = self.build_node(inner.next().unwrap())?.unwrap();
                
                // Apply postfix operators
                for postfix_op in inner {
                    match postfix_op.as_rule() {
                        Rule::postfix_operator => {
                            let op_inner = postfix_op.into_inner().next().unwrap();
                            match op_inner.as_rule() {
                                Rule::postfix_dereference => {
                                    let deref_type = op_inner.into_inner().next().unwrap().as_str();
                                    expr = AstNode::PostfixDereference {
                                        expr: Box::new(expr),
                                        deref_type: Arc::from(deref_type),
                                    };
                                }
                                Rule::method_call => {
                                    let mut method_inner = op_inner.into_inner();
                                    let method = Arc::from(method_inner.next().unwrap().as_str());
                                    let args = if let Some(args_pair) = method_inner.next() {
                                        self.parse_arg_list(args_pair)?
                                    } else {
                                        Vec::new()
                                    };
                                    expr = AstNode::MethodCall {
                                        object: Box::new(expr),
                                        method,
                                        args,
                                    };
                                }
                                Rule::typeglob_slot_access => {
                                    let slot = Arc::from(op_inner.into_inner().next().unwrap().as_str());
                                    expr = AstNode::TypeglobSlotAccess {
                                        typeglob: Box::new(expr),
                                        slot,
                                    };
                                }
                                _ => {}
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(expr))
            }
            Rule::scalar_variable => {
                Ok(Some(AstNode::ScalarVariable(Arc::from(pair.as_str()))))
            }
            Rule::array_variable => {
                Ok(Some(AstNode::ArrayVariable(Arc::from(pair.as_str()))))
            }
            Rule::hash_variable => {
                Ok(Some(AstNode::HashVariable(Arc::from(pair.as_str()))))
            }
            Rule::typeglob_variable => {
                Ok(Some(AstNode::TypeglobVariable(Arc::from(pair.as_str()))))
            }
            Rule::number => {
                Ok(Some(AstNode::Number(Arc::from(pair.as_str()))))
            }
            Rule::identifier => {
                Ok(Some(AstNode::Identifier(Arc::from(pair.as_str()))))
            }
            Rule::string | Rule::single_quoted_string | Rule::double_quoted_string => {
                Ok(Some(AstNode::String(Arc::from(pair.as_str()))))
            }
            Rule::q_string => {
                // q strings don't interpolate, so we just return the whole construct as a string
                Ok(Some(AstNode::String(Arc::from(pair.as_str()))))
            }
            Rule::qq_string => {
                // qq strings interpolate, so we mark them differently
                Ok(Some(AstNode::QqString(Arc::from(pair.as_str()))))
            }
            Rule::qx_string => {
                // qx strings are for command execution
                Ok(Some(AstNode::QxString(Arc::from(pair.as_str()))))
            }
            Rule::heredoc => {
                let inner = pair.into_inner();
                let mut indented = false;
                let mut marker = Arc::from("");
                let mut quoted = false;
                
                for p in inner {
                    match p.as_rule() {
                        Rule::heredoc_indented => {
                            indented = true;
                        }
                        Rule::heredoc_delimiter => {
                            let delimiter_str = p.as_str();
                            let delimiter_inner = p.into_inner().next();
                            if let Some(d) = delimiter_inner {
                                match d.as_rule() {
                                    Rule::heredoc_single_quoted => {
                                        quoted = true;
                                        marker = Arc::from(d.as_str().trim_matches('\''));
                                    }
                                    Rule::heredoc_double_quoted => {
                                        marker = Arc::from(d.as_str().trim_matches('"'));
                                    }
                                    Rule::heredoc_backtick => {
                                        marker = Arc::from(d.as_str().trim_matches('`'));
                                    }
                                    Rule::heredoc_escaped => {
                                        marker = Arc::from(d.as_str().trim_start_matches('\\'));
                                    }
                                    Rule::bare_heredoc_delimiter => {
                                        marker = Arc::from(d.as_str());
                                    }
                                    _ => {}
                                }
                            } else {
                                marker = Arc::from(delimiter_str);
                            }
                        }
                        _ => {}
                    }
                }
                
                // Note: In a real implementation, we would need to collect the heredoc content
                // from subsequent lines until we find the marker. For now, we just create
                // a placeholder.
                Ok(Some(AstNode::Heredoc {
                    marker,
                    indented,
                    quoted,
                    content: Arc::from(""), // This would be filled by a stateful parser
                }))
            }
            Rule::list => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::list_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::List(elements)))
            }
            Rule::array_ref => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::list_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::ArrayRef(elements)))
            }
            Rule::hash_ref => {
                let mut elements = Vec::new();
                for inner in pair.into_inner() {
                    if inner.as_rule() == Rule::hash_elements {
                        for elem in inner.into_inner() {
                            if let Some(node) = self.build_node(elem)? {
                                elements.push(node);
                            }
                        }
                    }
                }
                Ok(Some(AstNode::HashRef(elements)))
            }
            Rule::begin_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::BeginBlock(b)))
            }
            Rule::end_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::EndBlock(b)))
            }
            Rule::check_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::CheckBlock(b)))
            }
            Rule::init_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::InitBlock(b)))
            }
            Rule::unitcheck_block => {
                let inner = pair.into_inner().next().unwrap(); // get the block
                let block = self.build_node(inner)?.map(Box::new);
                Ok(block.map(|b| AstNode::UnitcheckBlock(b)))
            }
            Rule::qw_list => {
                let mut words = Vec::new();
                for inner in pair.into_inner() {
                    match inner.as_rule() {
                        Rule::qw_paren_items | Rule::qw_bracket_items | 
                        Rule::qw_brace_items | Rule::qw_angle_items |
                        Rule::qw_delimited_items => {
                            // Split the content by whitespace
                            let content = inner.as_str();
                            words.extend(content.split_whitespace().map(|s| Arc::from(s)));
                        }
                        _ => {}
                    }
                }
                Ok(Some(AstNode::QwList(words)))
            }
            Rule::do_block => {
                let inner = pair.into_inner().next().unwrap();
                let expr = self.build_node(inner)?.map(Box::new);
                Ok(expr.map(|e| AstNode::DoBlock(e)))
            }
            Rule::eval_statement => {
                let inner = pair.into_inner().next().unwrap();
                let expr = self.build_node(inner)?;
                Ok(expr.map(|e| match e {
                    AstNode::Block(_) => AstNode::EvalBlock(Box::new(e)),
                    _ => AstNode::EvalString(Box::new(e)),
                }))
            }
            Rule::goto_statement => {
                let inner = pair.into_inner().next().unwrap();
                let target = match inner.as_rule() {
                    Rule::goto_target => Arc::from(inner.as_str()),
                    _ => {
                        // For expressions, we need to evaluate them
                        if let Some(expr) = self.build_node(inner)? {
                            Arc::from(format!("{:?}", expr)) // Simple representation for now
                        } else {
                            Arc::from("")
                        }
                    }
                };
                Ok(Some(AstNode::GotoStatement { target }))
            }
            Rule::pod_section => {
                Ok(Some(AstNode::Pod(Arc::from(pair.as_str()))))
            }
            Rule::data_section => {
                Ok(Some(AstNode::DataSection(Arc::from(pair.as_str()))))
            }
            Rule::end_section => {
                Ok(Some(AstNode::EndSection(Arc::from(pair.as_str()))))
            }
            Rule::labeled_block => {
                let mut inner = pair.into_inner();
                let label_pair = inner.next().unwrap();
                let label = Arc::from(label_pair.as_str().trim_end_matches(':'));
                let block = self.build_node(inner.next().unwrap())?.map(Box::new);
                Ok(block.map(|b| AstNode::LabeledBlock { label, block: b }))
            }
            Rule::comment => {
                Ok(Some(AstNode::Comment(Arc::from(pair.as_str()))))
            }
            Rule::semicolon | Rule::WHITESPACE => Ok(None),
            Rule::standalone_expression => {
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::regex => {
                let mut inner = pair.into_inner();
                if let Some(first) = inner.next() {
                    match first.as_rule() {
                        rule if rule == Rule::match_regex => {
                            let mut match_inner = first.into_inner();
                            let pattern = match_inner.next().map(|p| Arc::from(p.as_str())).unwrap_or_else(|| Arc::from(""));
                            let flags = match_inner.next().map(|p| Arc::from(p.as_str())).unwrap_or_else(|| Arc::from(""));
                            
                            // Extract named groups from pattern
                            let named_groups = self.extract_named_groups(&pattern);
                            
                            Ok(Some(AstNode::Regex { pattern, flags, named_groups }))
                        }
                        _ => {
                            let pattern = Arc::from(first.as_str());
                            let flags = inner.next().map(|p| Arc::from(p.as_str())).unwrap_or_else(|| Arc::from(""));
                            let named_groups = self.extract_named_groups(&pattern);
                            Ok(Some(AstNode::Regex { pattern, flags, named_groups }))
                        }
                    }
                } else {
                    Ok(Some(AstNode::Regex { pattern: Arc::from(""), flags: Arc::from(""), named_groups: Vec::new() }))
                }
            }
            Rule::for_statement => {
                let inner = pair.into_inner();
                let label = None; // TODO: handle label if present
                // Don't skip "for" - it's already consumed by the grammar
                let mut init = None;
                let mut condition = None;
                let mut update = None;
                let mut block = None;
                
                // Parse for loop components
                for p in inner {
                    match p.as_rule() {
                        Rule::for_init => {
                            init = self.build_node(p)?.map(Box::new);
                        }
                        Rule::expression => {
                            if condition.is_none() {
                                condition = self.build_node(p)?.map(Box::new);
                            } else if update.is_none() {
                                update = self.build_node(p)?.map(Box::new);
                            }
                        }
                        Rule::block => {
                            block = self.build_node(p)?.map(Box::new);
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::ForStatement {
                    label,
                    init,
                    condition,
                    update,
                    block: block.unwrap_or_else(|| Box::new(AstNode::Block(vec![]))),
                }))
            }
            Rule::package_declaration => {
                let mut inner = pair.into_inner();
                inner.next(); // skip "package"
                // Accept qualified_name as identifier
                let name = if let Some(name_pair) = inner.next() {
                    Arc::from(name_pair.as_str())
                } else {
                    Arc::from("")
                };
                let mut version = None;
                let mut block = None;
                for p in inner {
                    match p.as_rule() {
                        Rule::version => version = Some(Arc::from(p.as_str())),
                        Rule::block => block = self.build_node(p)?.map(Box::new),
                        _ => {}
                    }
                }
                Ok(Some(AstNode::PackageDeclaration { name, version, block }))
            }
            Rule::use_statement => {
                let mut inner = pair.into_inner();
                
                let mut module = Arc::from("");
                let mut version = None;
                let mut import_list = Vec::new();
                
                for p in inner {
                    match p.as_rule() {
                        Rule::module_name => module = Arc::from(p.as_str()),
                        Rule::version => version = Some(Arc::from(p.as_str())),
                        Rule::import_list => {
                            for item in p.into_inner() {
                                if item.as_rule() == Rule::import_items {
                                    for import_item in item.into_inner() {
                                        if import_item.as_rule() == Rule::import_item {
                                            import_list.push(Arc::from(import_item.as_str()));
                                        }
                                    }
                                }
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::UseStatement { module, version, import_list }))
            }
            Rule::require_statement => {
                let mut inner = pair.into_inner();
                
                let mut module = Arc::from("");
                
                for p in inner {
                    match p.as_rule() {
                        Rule::module_name => module = Arc::from(p.as_str()),
                        Rule::expression => {
                            // For require expressions, we'll use the expression as the module
                            if let Some(expr) = self.build_node(p)? {
                                module = Arc::from(Self::node_to_sexp(&expr));
                            }
                        }
                        _ => {}
                    }
                }
                
                Ok(Some(AstNode::RequireStatement { module }))
            }
            Rule::interpolation => {
                // Handle interpolation within strings
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::complex_scalar_interpolation => {
                // ${expr} form
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::complex_array_interpolation => {
                // @{[expr]} form  
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::reference => {
                // Handle variable references
                let inner = pair.into_inner().next().unwrap();
                self.build_node(inner)
            }
            Rule::scalar_reference => {
                // Since these are atomic rules, use the whole pair's text
                Ok(Some(AstNode::ScalarReference(Arc::from(pair.as_str()))))
            }
            Rule::array_reference => {
                // Since these are atomic rules, use the whole pair's text
                Ok(Some(AstNode::ArrayReference(Arc::from(pair.as_str()))))
            }
            Rule::hash_reference => {
                // Since these are atomic rules, use the whole pair's text
                Ok(Some(AstNode::HashReference(Arc::from(pair.as_str()))))
            }
            Rule::subroutine_reference => {
                // Since these are atomic rules, use the whole pair's text
                Ok(Some(AstNode::SubroutineReference(Arc::from(pair.as_str()))))
            }
            Rule::glob_reference => {
                // Since these are atomic rules, use the whole pair's text
                Ok(Some(AstNode::GlobReference(Arc::from(pair.as_str()))))
            }
            _ => {
                // For unhandled rules, try to process inner pairs
                let inner: Vec<_> = pair.into_inner().collect();
                if inner.is_empty() {
                    Ok(None)
                } else if inner.len() == 1 {
                    self.build_node(inner.into_iter().next().unwrap())
                } else {
                    let mut nodes = Vec::new();
                    for p in inner {
                        if let Some(node) = self.build_node(p)? {
                            nodes.push(node);
                        }
                    }
                    if nodes.is_empty() {
                        Ok(None)
                    } else if nodes.len() == 1 {
                        Ok(nodes.into_iter().next())
                    } else {
                        Ok(Some(AstNode::List(nodes)))
                    }
                }
            }
        }
    }

    fn build_expression(&mut self, pair: Pair<Rule>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        let inner = pair.into_inner().next().unwrap();
        match inner.as_rule() {
            Rule::assignment_expression => self.build_node(inner),
            Rule::ternary_expression => self.build_ternary_expression(inner),
            _ => self.build_node(inner),
        }
    }
    
    #[inline]
    fn build_ternary_expression(&mut self, pair: Pair<Rule>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        let inner: Vec<_> = pair.into_inner().collect();
        if inner.len() == 1 {
            // No ternary, just pass through
            self.build_node(inner.into_iter().next().unwrap())
        } else if inner.len() == 3 {
            let condition = Box::new(self.build_node(inner[0].clone())?.unwrap());
            let then_expr = Box::new(self.build_node(inner[1].clone())?.unwrap());
            let else_expr = Box::new(self.build_node(inner[2].clone())?.unwrap());
            Ok(Some(AstNode::TernaryOp { condition, true_expr: then_expr, false_expr: else_expr }))
        } else {
            self.build_node(inner.into_iter().next().unwrap())
        }
    }
    
    #[inline]
    fn build_binary_expression(&mut self, pair: Pair<Rule>, _op_rule: Rule) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        let inner: Vec<_> = pair.into_inner().collect();
        if inner.len() == 1 {
            self.build_node(inner.into_iter().next().unwrap())
        } else if inner.len() >= 3 {
            // Build with proper precedence
            self.build_binary_expr_with_precedence(inner)
        } else {
            self.build_node(inner.into_iter().next().unwrap())
        }
    }
    
    fn build_binary_expr_with_precedence(&mut self, pairs: Vec<Pair<Rule>>) -> Result<Option<AstNode>, Box<dyn std::error::Error>> {
        // Build left-associative binary operations with operator precedence
        let mut result = self.build_node(pairs[0].clone())?.unwrap();
        let mut i = 1;
        
        while i < pairs.len() {
            let op = Arc::from(pairs[i].as_str());
            let right = self.build_node(pairs[i + 1].clone())?.unwrap();
            
            // Get operator precedence
            if let Some(op_info) = self.pratt_parser.get_operator_info(&op) {
                // Handle precedence by restructuring the tree if needed
                result = self.apply_precedence(result, op.clone(), right, op_info.precedence.0);
            } else {
                // Unknown operator, use default left-associative
                result = AstNode::BinaryOp {
                    op,
                    left: Box::new(result),
                    right: Box::new(right),
                };
            }
            
            i += 2;
        }
        
        Ok(Some(result))
    }
    
    fn apply_precedence(&self, left: AstNode, op: Arc<str>, right: AstNode, _prec: u8) -> AstNode {
        // For now, simple left-associative. Full Pratt parser implementation would go here
        AstNode::BinaryOp {
            op,
            left: Box::new(left),
            right: Box::new(right),
        }
    }
    
    fn parse_arg_list(&mut self, pair: Pair<Rule>) -> Result<Vec<AstNode>, Box<dyn std::error::Error>> {
        let mut args = Vec::new();
        for arg in pair.into_inner() {
            if let Some(node) = self.build_node(arg)? {
                args.push(node);
            }
        }
        Ok(args)
    }

    pub fn to_sexp(&self, node: &AstNode) -> String {
        Self::node_to_sexp(node)
    }

    fn node_to_sexp(node: &AstNode) -> String {
        match node {
            AstNode::Program(children) => {
                // Remove nested source_file in S-expression output
                let mut flat_children = vec![];
                for c in children {
                    let sexp = Self::node_to_sexp(c);
                    if sexp.starts_with("(source_file ") {
                        let inner = sexp.trim_start_matches("(source_file ").trim_end_matches(")");
                        flat_children.push(inner.to_string());
                    } else {
                        flat_children.push(sexp);
                    }
                }
                if flat_children.is_empty() {
                    "(source_file)".to_string()
                } else {
                    format!("(source_file {})", flat_children.join(" "))
                }
            }
            AstNode::Statement(expr) => {
                Self::node_to_sexp(expr)
            }
            AstNode::Block(statements) => {
                let stmt_sexps: Vec<String> = statements.iter().map(Self::node_to_sexp).collect();
                format!("(block {})", stmt_sexps.join(" "))
            }
            AstNode::VariableDeclaration { scope, variables, initializer } => {
                let var_sexps: Vec<String> = variables.iter().map(Self::node_to_sexp).collect();
                let init_sexp = initializer.as_ref().map(|i| Self::node_to_sexp(i)).unwrap_or_default();
                format!("(variable_declaration ({}) {} {})", scope, var_sexps.join(" "), init_sexp)
            }
            AstNode::SubDeclaration { name, body, .. } => {
                format!("(subroutine (identifier {}) {})", name, Self::node_to_sexp(body))
            }
            AstNode::FormatDeclaration { name, format_lines } => {
                let lines_sexp = format_lines.iter()
                    .map(|line| format!("(format_line \"{}\")", line.replace("\"", "\\\"")))
                    .collect::<Vec<_>>()
                    .join(" ");
                if name.is_empty() {
                    format!("(format_declaration {})", lines_sexp)
                } else {
                    format!("(format_declaration (identifier {}) {})", name, lines_sexp)
                }
            }
            AstNode::IfStatement { condition, then_block, .. } => {
                format!("(if_statement {} {})", Self::node_to_sexp(condition), Self::node_to_sexp(then_block))
            }
            AstNode::GivenStatement { expression, when_clauses, default_block } => {
                let mut result = format!("(given_statement {}", Self::node_to_sexp(expression));
                for (cond, block) in when_clauses {
                    result.push_str(&format!(" (when_clause {} {})", Self::node_to_sexp(cond), Self::node_to_sexp(block)));
                }
                if let Some(default) = default_block {
                    result.push_str(&format!(" (default_clause {})", Self::node_to_sexp(default)));
                }
                result.push(')');
                result
            }
            AstNode::TieStatement { variable, class, args } => {
                let args_str = args.iter().map(|a| Self::node_to_sexp(a)).collect::<Vec<_>>().join(" ");
                format!("(tie_statement {} {} {})", Self::node_to_sexp(variable), Self::node_to_sexp(class), args_str)
            }
            AstNode::UntieStatement { variable } => {
                format!("(untie_statement {})", Self::node_to_sexp(variable))
            }
            AstNode::TiedExpression { variable } => {
                format!("(tied_expression {})", Self::node_to_sexp(variable))
            }
            AstNode::PostfixDereference { expr, deref_type } => {
                format!("(postfix_deref {} {})", Self::node_to_sexp(expr), deref_type)
            }
            AstNode::TypeglobSlotAccess { typeglob, slot } => {
                format!("(typeglob_slot_access {} {})", Self::node_to_sexp(typeglob), slot)
            }
            AstNode::MethodCall { object, method, args } => {
                let args_str = args.iter().map(|a| Self::node_to_sexp(a)).collect::<Vec<_>>().join(" ");
                format!("(method_call {} {} {})", Self::node_to_sexp(object), method, args_str)
            }
            AstNode::Assignment { target, op, value } => {
                format!("(assignment {} ({}) {})", Self::node_to_sexp(target), op, Self::node_to_sexp(value))
            }
            AstNode::BinaryOp { op, left, right } => {
                format!("(binary_expression {} ({}) {})", Self::node_to_sexp(left), op, Self::node_to_sexp(right))
            }
            AstNode::ScalarVariable(name) => {
                format!("(scalar_variable {})", name)
            }
            AstNode::ArrayVariable(name) => {
                format!("(array_variable {})", name)
            }
            AstNode::HashVariable(name) => {
                format!("(hash_variable {})", name)
            }
            AstNode::TypeglobVariable(name) => {
                format!("(typeglob_variable {})", name)
            }
            AstNode::ScalarReference(name) => {
                format!("(scalar_reference {})", name)
            }
            AstNode::ArrayReference(name) => {
                format!("(array_reference {})", name)
            }
            AstNode::HashReference(name) => {
                format!("(hash_reference {})", name)
            }
            AstNode::SubroutineReference(name) => {
                format!("(subroutine_reference {})", name)
            }
            AstNode::GlobReference(name) => {
                format!("(glob_reference {})", name)
            }
            AstNode::Number(value) => {
                format!("(number {})", value)
            }
            AstNode::String(value) => {
                format!("(string_literal {})", value)
            }
            AstNode::Identifier(name) => {
                format!("(identifier {})", name)
            }
            AstNode::Comment(content) => {
                format!("(comment {})", content)
            }
            AstNode::List(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                item_sexps.join(" ")
            }
            AstNode::ArrayRef(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                format!("(array_ref {})", item_sexps.join(" "))
            }
            AstNode::HashRef(items) => {
                let item_sexps: Vec<String> = items.iter().map(Self::node_to_sexp).collect();
                format!("(hash_ref {})", item_sexps.join(" "))
            }
            AstNode::ForStatement { init, condition, update, block, .. } => {
                let mut parts = vec![];
                if let Some(i) = init { parts.push(format!("(init {})", Self::node_to_sexp(i))); }
                if let Some(c) = condition { parts.push(format!("(condition {})", Self::node_to_sexp(c))); }
                if let Some(u) = update { parts.push(format!("(update {})", Self::node_to_sexp(u))); }
                parts.push(format!("(body {})", Self::node_to_sexp(block)));
                format!("(for_statement {})", parts.join(" "))
            }
            AstNode::PackageDeclaration { name, version, block } => {
                let mut parts = vec![format!("(name {})", name)];
                if let Some(v) = version { parts.push(format!("(version {})", v)); }
                if let Some(b) = block { parts.push(format!("(body {})", Self::node_to_sexp(b))); }
                format!("(package_declaration {})", parts.join(" "))
            }
            AstNode::UseStatement { module, version, import_list } => {
                let mut parts = vec![format!("use (package {})", module)];
                if let Some(v) = version { parts.push(format!("(version {})", v)); }
                if !import_list.is_empty() {
                    parts.push(format!("(import_list {})", import_list.join(" ")));
                }
                parts.push(";".to_string());
                format!("(use_statement {})", parts.join(" "))
            }
            AstNode::RequireStatement { module } => {
                format!("(require_statement require (package {}) ;)", module)
            }
            AstNode::Regex { pattern, flags, named_groups } => {
                let groups_str = if !named_groups.is_empty() {
                    format!(" (named_groups {})", named_groups.join(" "))
                } else {
                    String::new()
                };
                format!("(regex {} {}{})", pattern, flags, groups_str)
            }
            AstNode::BeginBlock(block) => {
                format!("(begin_block {})", Self::node_to_sexp(block))
            }
            AstNode::EndBlock(block) => {
                format!("(end_block {})", Self::node_to_sexp(block))
            }
            AstNode::CheckBlock(block) => {
                format!("(check_block {})", Self::node_to_sexp(block))
            }
            AstNode::InitBlock(block) => {
                format!("(init_block {})", Self::node_to_sexp(block))
            }
            AstNode::UnitcheckBlock(block) => {
                format!("(unitcheck_block {})", Self::node_to_sexp(block))
            }
            AstNode::QwList(words) => {
                let word_list = words.iter().map(|w| format!("(word {})", w)).collect::<Vec<_>>().join(" ");
                format!("(qw_list {})", word_list)
            }
            AstNode::DoBlock(expr) => {
                format!("(do_block {})", Self::node_to_sexp(expr))
            }
            AstNode::EvalBlock(block) => {
                format!("(eval_block {})", Self::node_to_sexp(block))
            }
            AstNode::EvalString(expr) => {
                format!("(eval_string {})", Self::node_to_sexp(expr))
            }
            AstNode::GotoStatement { target } => {
                format!("(goto_statement {})", target)
            }
            AstNode::LabeledBlock { label, block } => {
                format!("(labeled_block {} {})", label, Self::node_to_sexp(block))
            }
            AstNode::Heredoc { marker, indented, quoted, content } => {
                let flags = format!("{}{}",
                    if *indented { "~" } else { "" },
                    if *quoted { "'" } else { "" }
                );
                format!("(heredoc {} {} \"{}\")", marker, flags, content.escape_default())
            }
            AstNode::Pod(content) => {
                format!("(pod {})", content)
            }
            AstNode::DataSection(content) => {
                format!("(data_section {})", content)
            }
            AstNode::EndSection(content) => {
                format!("(end_section {})", content)
            }
            _ => format!("(unhandled_node {:?})", node),
        }
    }
}

impl Default for PureRustPerlParser {
    fn default() -> Self {
        Self::new()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_basic_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "$var";
        let result = parser.parse(source);
        assert!(result.is_ok());
        let ast = result.unwrap();
        let sexp = parser.to_sexp(&ast);
        println!("AST: {:?}", ast);
        println!("S-expression: {}", sexp);
    }

    #[test]
    fn test_variable_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "$scalar @array %hash";
        let result = parser.parse(source);
        assert!(result.is_ok());
        let ast = result.unwrap();
        let sexp = parser.to_sexp(&ast);
        println!("S-expression: {}", sexp);
    }

    #[test]
    fn test_assignment_parsing() {
        let mut parser = PureRustPerlParser::new();
        let source = "my $var = 42;";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Success! AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_function_declaration() {
        let mut parser = PureRustPerlParser::new();
        let source = "sub hello { print 'Hello'; }";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_if_statement() {
        let mut parser = PureRustPerlParser::new();
        let source = "if ($x > 0) { print 'positive'; }";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_array_assignment() {
        let mut parser = PureRustPerlParser::new();
        let source = "@array = (1, 2, 3);";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Array assignment AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
    
    #[test]
    fn test_hash_assignment() {
        let mut parser = PureRustPerlParser::new();
        let source = "%hash = (a => 1, b => 2);";
        let result = parser.parse(source);
        match result {
            Ok(ast) => {
                let sexp = parser.to_sexp(&ast);
                println!("Hash assignment AST: {:?}", ast);
                println!("S-expression: {}", sexp);
            }
            Err(e) => {
                println!("Parse error: {}", e);
                panic!("Parse should succeed");
            }
        }
    }
}