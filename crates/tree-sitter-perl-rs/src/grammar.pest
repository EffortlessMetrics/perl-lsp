// Perl Grammar for Pest Parser
// Complete implementation covering most Perl syntax

// Main entry point
program = { SOI ~ statements? ~ EOI }

// Statements
statements = { statement+ }

statement = { 
    sub_declaration
    | package_declaration
    | use_statement
    | require_statement
    | begin_block
    | end_block
    | check_block
    | init_block
    | unitcheck_block
    | if_statement
    | unless_statement
    | given_statement
    | while_statement
    | until_statement
    | for_statement
    | foreach_statement
    | do_block
    | eval_statement
    | goto_statement
    | return_statement
    | last_statement
    | next_statement
    | redo_statement
    | continue_statement
    | labeled_block
    | declaration_statement
    | expression_statement 
    | block_statement
    | comment
    | pod_section
    | data_section
    | end_section
    | empty_statement
    | standalone_expression
    | regex
}

empty_statement = { semicolon }
standalone_expression = { expression }

expression_statement = { expression ~ semicolon? }
declaration_statement = { declaration ~ semicolon? }
block_statement = { block }
return_statement = { "return" ~ expression? ~ semicolon? }
last_statement = { "last" ~ label? ~ semicolon? }
next_statement = { "next" ~ label? ~ semicolon? }
redo_statement = { "redo" ~ label? ~ semicolon? }
continue_statement = { "continue" ~ semicolon? }

labeled_block = { label ~ block }

// Declarations
declaration = {
    variable_declaration
    | constant_declaration
}

variable_declaration = { 
    ("my" | "our" | "local" | "state") ~ variable_list ~ ("=" ~ expression)?
}

constant_declaration = {
    "use" ~ "constant" ~ identifier ~ "=>" ~ expression
}

variable_list = { 
    ("(" ~ variable ~ ("," ~ variable)* ~ ")") |
    (variable ~ ("," ~ variable)*)
}

// Control Flow
if_statement = {
    "if" ~ "(" ~ expression ~ ")" ~ block ~ elsif_clause* ~ else_clause?
}

elsif_clause = { "elsif" ~ "(" ~ expression ~ ")" ~ block }
else_clause = { "else" ~ block }

unless_statement = {
    "unless" ~ "(" ~ expression ~ ")" ~ block ~ else_clause?
}

given_statement = {
    "given" ~ "(" ~ expression ~ ")" ~ given_block
}

given_block = { "{" ~ when_clause* ~ default_clause? ~ "}" }

when_clause = {
    "when" ~ "(" ~ when_condition ~ ")" ~ block
}

when_condition = {
    expression
}

default_clause = {
    "default" ~ block
}

while_statement = {
    label? ~ "while" ~ "(" ~ expression ~ ")" ~ block
}

until_statement = {
    label? ~ "until" ~ "(" ~ expression ~ ")" ~ block
}

for_statement = {
    label? ~ "for" ~ (
        // C-style for loop
        ("(" ~ (for_init | assignment_expression)? ~ ";" ~ expression? ~ ";" ~ expression? ~ ")" ~ block) |
        // foreach-style for loop with variable
        (variable ~ "(" ~ expression ~ ")" ~ block) |
        // foreach-style for loop without variable (uses $_)
        ("(" ~ expression ~ ")" ~ block)
    )
}

foreach_statement = {
    label? ~ "foreach" ~ variable? ~ "(" ~ expression ~ ")" ~ block
}

for_init = { declaration | assignment_expression | expression }

// Subroutines
sub_declaration = {
    sub_modifier? ~ "sub" ~ identifier ~ (signature | prototype)? ~ attributes? ~ block
}

sub_modifier = { "my" | "our" | "state" }

signature = { "(" ~ signature_params? ~ ")" }
signature_params = { signature_param ~ ("," ~ signature_param)* }
signature_param = {
    named_param
    | slurpy_param
    | positional_param
}

positional_param = {
    type_constraint? ~ variable ~ default_value?
}

named_param = {
    ":" ~ variable ~ default_value?
}

slurpy_param = {
    type_constraint? ~ (array_variable | hash_variable)
}

type_constraint = {
    identifier ~ !("=" | "$" | "@" | "%" | ":")
}

default_value = {
    "=" ~ expression
}

prototype = { "(" ~ prototype_args? ~ ")" }
prototype_args = { prototype_arg ~ ("," ~ prototype_arg)* }
prototype_arg = { "$" | "@" | "%" | "&" | "\\" ~ ("$" | "@" | "%" | "&") | "*" | ";" }
sigil = { "$" | "@" | "%" | "&" }

attributes = { ":" ~ attribute_list }
attribute_list = { attribute ~ (":" ~ attribute)* }
attribute = { identifier ~ ("(" ~ attribute_args ~ ")")? }
attribute_args = { (!(")" | ",") ~ ANY)+ }

// Packages and Modules
package_declaration = {
    "package" ~ qualified_name ~ version? ~ (block | semicolon)?
}

use_statement = {
    "use" ~ (module_name | version) ~ import_list? ~ semicolon?
}

require_statement = {
    "require" ~ (module_name | expression) ~ semicolon?
}

module_name = { qualified_name }
import_list = { "(" ~ import_items? ~ ")" | import_items }
import_items = { import_item ~ ("," ~ import_item)* }
import_item = { identifier | string }

// Expressions
expression = { assignment_expression | ternary_expression }

assignment_expression = {
    unary_expression ~ assignment_operator ~ expression
}

assignment_operator = {
    "=" | "+=" | "-=" | "*=" | "/=" | "%=" | "**=" | ".=" | "<<=" | ">>=" | "&=" | "|=" | "^="
    | "&&=" | "||=" | "//=" | "&.=" | "|.=" | "^.="
}

ternary_expression = {
    logical_or_expression ~ ("?" ~ expression ~ ":" ~ expression)?
}

logical_or_expression = { defined_or_expression ~ (("||" | "or") ~ defined_or_expression)* }
defined_or_expression = { logical_and_expression ~ ("//" ~ logical_and_expression)* }
logical_and_expression = { equality_expression ~ (("&&" | "and") ~ equality_expression)* }

equality_expression = {
    relational_expression ~ (("==" | "!=" | "eq" | "ne" | "<=>" | "cmp" | "~~") ~ relational_expression)*
}

relational_expression = {
    isa_expression ~ (("<=" | ">=" | "<" | ">" | "lt" | "gt" | "le" | "ge" | "=~" | "!~") ~ isa_expression)*
}

isa_expression = {
    bitwise_expression ~ ("isa" ~ bitwise_expression)*
}

bitwise_expression = { bitwise_string_expression ~ (("&" | "|" | "^") ~ bitwise_string_expression)* }
bitwise_string_expression = { shift_expression ~ (("&." | "|." | "^.") ~ shift_expression)* }

shift_expression = { range_expression ~ (("<<" | ">>") ~ range_expression)* }

range_expression = { additive_expression ~ (("..." | "..") ~ additive_expression)* }

additive_expression = {
    multiplicative_expression ~ (("+" | "-" | ".") ~ multiplicative_expression)*
}

multiplicative_expression = {
    exponential_expression ~ (("*" | "/" | "%" | "x") ~ exponential_expression)*
}

exponential_expression = {
    unary_expression ~ ("**" ~ unary_expression)*
}

unary_expression = {
    ("!" | "-" | "+" | "~" | "~." | "not")+ ~ unary_expression
    | reference
    | postfix_expression
}

postfix_expression = {
    primary_expression ~ postfix_operator*
}

postfix_operator = {
    array_access
    | hash_access
    | method_call
    | function_call
    | increment
    | decrement
    | postfix_dereference
}

postfix_dereference = {
    "->" ~ (
        "@*" |           // Array dereference
        "%*" |           // Hash dereference
        "$*" |           // Scalar dereference
        "&*" |           // Code dereference
        "**" |           // Glob dereference
        "@" ~ array_access |  // Array slice
        "@" ~ hash_access     // Hash slice
    )
}

array_access = { "[" ~ expression ~ "]" }
hash_access = { "{" ~ expression ~ "}" }
method_call = { "->" ~ (identifier ~ function_args? | function_args) }
function_call = { function_args }
function_args = { "(" ~ arg_list? ~ ")" }
arg_list = { expression ~ ("," ~ expression)* }
increment = { "++" }
decrement = { "--" }

primary_expression = {
    literal
    | reference
    | variable
    | array_ref
    | hash_ref
    | list
    | "(" ~ expression ~ ")"
    | block
    | anonymous_sub
    | regex
    | substitution
    | transliteration
    | heredoc
    | glob
    | readline
    | qw_list
}

// References to variables
reference = {
    scalar_reference
    | array_reference
    | hash_reference
    | subroutine_reference
    | glob_reference
}

scalar_reference = @{ "\\" ~ (scalar_variable | ("${" ~ expression ~ "}")) }
array_reference = @{ "\\" ~ (array_variable | ("@{" ~ expression ~ "}")) }
hash_reference = @{ "\\" ~ (hash_variable | ("%{" ~ expression ~ "}")) }
subroutine_reference = @{ "\\" ~ "&" ~ qualified_name }
glob_reference = @{ "\\" ~ "*" ~ identifier }

// Anonymous references
array_ref = { "[" ~ list_elements? ~ "]" }
hash_ref = { "{" ~ hash_elements? ~ "}" }
hash_elements = { hash_element ~ (("," | "=>") ~ hash_element)* ~ ","? }
hash_element = { expression }

// List literal
list = { "(" ~ list_elements? ~ ")" }
list_elements = { list_element ~ (("," | "=>") ~ list_element)* ~ ","? }
list_element = { expression }

// Literals
literal = {
    number
    | string
    | bareword
}

number = @{
    hex_number
    | oct_number
    | bin_number
    | float_number
    | int_number
}

hex_number = @{ "0x" ~ ASCII_HEX_DIGIT+ }
oct_number = @{ "0" ~ ASCII_OCT_DIGIT+ }
bin_number = @{ "0b" ~ ("0" | "1")+ }
float_number = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ (("e" | "E") ~ ("+" | "-")? ~ ASCII_DIGIT+)? }
int_number = @{ ASCII_DIGIT+ }

string = {
    single_quoted_string
    | double_quoted_string
    | backtick_string
    | q_string
    | qq_string
    | qx_string
}

single_quoted_string = @{ "'" ~ single_string_content ~ "'" }
single_string_content = @{ (!"'" ~ (escape_sequence | ANY))* }

double_quoted_string = { "\"" ~ double_string_content ~ "\"" }
double_string_content = { double_string_part* }
double_string_part = {
    interpolation
    | double_string_chars
}
double_string_chars = @{ (!( "\"" | "$" | "@" ) ~ ANY)+ | "$" ~ !(ASCII_ALPHANUMERIC | "_" | "{" ) | "@" ~ !(ASCII_ALPHANUMERIC | "_" | "{" ) }

backtick_string = @{ "`" ~ backtick_content ~ "`" }
backtick_content = @{ (!"`" ~ ANY)* }

q_string = { "q" ~ delimiter ~ q_string_content ~ delimiter }
qq_string = { 
    "qq" ~ (
        ("(" ~ qq_paren_content ~ ")") |
        ("[" ~ qq_bracket_content ~ "]") |
        ("{" ~ qq_brace_content ~ "}") |
        ("<" ~ qq_angle_content ~ ">") |
        (qq_delimiter ~ qq_delimited_content ~ qq_delimiter)
    )
}
qq_paren_content = @{ (!")" ~ ANY)* }
qq_bracket_content = @{ (!"]" ~ ANY)* }
qq_brace_content = @{ (!"}" ~ ANY)* }
qq_angle_content = @{ (!">" ~ ANY)* }
qq_delimiter = @{ !("(" | "[" | "{" | "<" | ASCII_ALPHANUMERIC | WHITESPACE) ~ ANY }
qq_delimited_content = @{ (!qq_delimiter ~ ANY)* }
qx_string = { "qx" ~ delimiter ~ qx_string_content ~ delimiter }

delimiter = @{ !ASCII_ALPHANUMERIC ~ ANY }
q_string_content = @{ (!delimiter ~ ANY)* }
qq_string_content = @{ (!delimiter ~ ANY)* }
qx_string_content = @{ (!delimiter ~ ANY)* }

escape_sequence = @{ "\\" ~ ANY }
interpolation = { 
    complex_scalar_interpolation 
    | complex_array_interpolation
    | array_dereference_interpolation
    | hash_dereference_interpolation
    | scalar_variable
    | array_variable
    | hash_variable
    | array_element 
    | hash_element_access 
}

// Complex interpolation forms
complex_scalar_interpolation = { "${" ~ expression ~ "}" }
complex_array_interpolation = { "@{[" ~ list_elements? ~ "]}" }
array_dereference_interpolation = { "@{" ~ expression ~ "}" }
hash_dereference_interpolation = { "%{" ~ expression ~ "}" }

// Variables
variable = {
    scalar_variable
    | array_variable
    | hash_variable
    | array_element
    | hash_element_access
    | special_variable
}

scalar_variable = @{ "$" ~ variable_name }
array_variable = @{ "@" ~ variable_name }
hash_variable = @{ "%" ~ variable_name }
array_element = { "$" ~ variable_name ~ "[" ~ expression ~ "]" }
hash_element_access = { "$" ~ variable_name ~ "{" ~ expression ~ "}" }

variable_name = @{
    identifier
    | package_variable
    | special_var_name
}

package_variable = @{ qualified_name ~ "::" ~ identifier }
special_variable = @{ "$" ~ special_var_name }
special_var_name = @{ 
    ASCII_DIGIT+ 
    | "!" | "\"" | "#" | "$" | "%" | "&" | "'" | "(" | ")" | "*" | "+" | "," | "-" | "." | "/" 
    | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" | "\\" | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~"
}

// Identifiers - must not be a complete keyword
identifier = @{ 
    !(reserved_word ~ !(ASCII_ALPHANUMERIC | "_")) ~ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* 
}

// Reserved words that should not be identifiers
reserved_word = { 
    "sub" | "my" | "our" | "local" | "state" | "if" | "elsif" | "else" | "unless" | 
    "while" | "until" | "for" | "foreach" | "return" | "last" | "next" | "redo" |
    "package" | "use" | "require" | "do" | "eval" | "goto" | "qw" | "qq" | "qx" | "qr" | "q"
}

// Special identifiers that are only reserved in specific contexts
goto_target = @{ (ASCII_ALPHA | "_") ~ (ASCII_ALPHANUMERIC | "_")* }
qualified_name = { identifier ~ ("::" ~ identifier)* }
label = @{ identifier ~ ":" }
bareword = { identifier }

// Regular Expressions
regex = {
    match_regex
    | qr_regex
}

match_regex = { "/" ~ match_regex_pattern ~ "/" ~ regex_flags? }
qr_regex = { 
    "qr" ~ ("/" ~ qr_slash_pattern ~ "/" | 
            "!" ~ qr_exclaim_pattern ~ "!" |
            "#" ~ qr_hash_pattern ~ "#" |
            regex_delimiter ~ qr_regex_pattern ~ regex_delimiter) ~ regex_flags? 
}
qr_slash_pattern = @{ (!"/" ~ (regex_escape | regex_group | ANY))* }
qr_exclaim_pattern = @{ (!"!" ~ (regex_escape | regex_group | ANY))* }
qr_hash_pattern = @{ (!"#" ~ (regex_escape | regex_group | ANY))* }
match_regex_pattern = @{ (!"/" ~ (regex_escape | regex_group | ANY))* }
qr_regex_pattern = @{ (!regex_delimiter ~ (regex_escape | regex_group | ANY))* }

// Regex components
regex_escape = { "\\" ~ ANY }
regex_group = {
    "(?<" ~ identifier ~ ">" ~ regex_group_content ~ ")" |  // Named capture
    "(?:" ~ regex_group_content ~ ")" |                     // Non-capturing
    "(?=" ~ regex_group_content ~ ")" |                     // Positive lookahead
    "(?!" ~ regex_group_content ~ ")" |                     // Negative lookahead
    "(?<=" ~ regex_group_content ~ ")" |                    // Positive lookbehind
    "(?<!" ~ regex_group_content ~ ")" |                    // Negative lookbehind
    "(" ~ regex_group_content ~ ")"                         // Capturing group
}
regex_group_content = @{ (!(")" | "(") ~ (regex_escape | ANY))* }

regex_delimiter = @{ !ASCII_ALPHANUMERIC ~ ANY }
regex_flags = @{ ("i" | "m" | "s" | "x" | "g" | "o" | "a" | "u" | "l" | "n" | "p" | "c" | "e" | "r")* }

substitution = {
    "s" ~ delimiter ~ sub_pattern ~ delimiter ~ replacement ~ delimiter ~ regex_flags?
}
sub_pattern = @{ (!delimiter ~ (regex_escape | regex_group | ANY))* }

replacement = @{ (!delimiter ~ ANY)* }

transliteration = {
    ("tr" | "y") ~ delimiter ~ search_list ~ delimiter ~ replace_list ~ delimiter ~ trans_flags?
}

search_list = @{ (!delimiter ~ ANY)* }
replace_list = @{ (!delimiter ~ ANY)* }
trans_flags = @{ ASCII_ALPHA* }

// Other constructs
// Heredoc - Note: Full heredoc parsing requires stateful handling
// This rule captures the heredoc declaration, actual content is handled by the scanner
heredoc = { 
    "<<" ~ heredoc_indented? ~ heredoc_delimiter
}
heredoc_indented = { "~" }
heredoc_delimiter = {
    heredoc_single_quoted |
    heredoc_double_quoted |
    heredoc_backtick |
    heredoc_escaped |
    bare_heredoc_delimiter
}

// Specific heredoc delimiter forms
heredoc_single_quoted = { "'" ~ bare_heredoc_delimiter ~ "'" }
heredoc_double_quoted = { "\"" ~ bare_heredoc_delimiter ~ "\"" }
heredoc_backtick = { "`" ~ bare_heredoc_delimiter ~ "`" }
heredoc_escaped = { "\\" ~ bare_heredoc_delimiter }

bare_heredoc_delimiter = @{ (ASCII_ALPHANUMERIC | "_")+ }

glob = { "<" ~ glob_pattern ~ ">" }
glob_pattern = @{ (!">'" ~ ANY)* }

readline = { "<" ~ filehandle? ~ ">" }
filehandle = { identifier | scalar_variable }

qw_list = { 
    "qw" ~ (
        ("(" ~ qw_paren_items ~ ")") |
        ("[" ~ qw_bracket_items ~ "]") |
        ("{" ~ qw_brace_items ~ "}") |
        ("<" ~ qw_angle_items ~ ">") |
        (qw_delimiter ~ qw_delimited_items ~ qw_delimiter)
    )
}
qw_paren_items = @{ (!")" ~ ANY)* }
qw_bracket_items = @{ (!"]" ~ ANY)* }
qw_brace_items = @{ (!"}" ~ ANY)* }
qw_angle_items = @{ (!">" ~ ANY)* }
qw_delimiter = @{ !("(" | "[" | "{" | "<" | ASCII_ALPHANUMERIC | WHITESPACE) ~ ANY }
qw_delimited_items = @{ (!qw_delimiter ~ ANY)* }

anonymous_sub = { "sub" ~ prototype? ~ attributes? ~ block }

block = { "{" ~ statements? ~ "}" }

version = @{ "v" ~ ASCII_DIGIT+ ~ ("." ~ ASCII_DIGIT+)* }

semicolon = { ";" }

// BEGIN/END blocks
begin_block = { "BEGIN" ~ block }
end_block = { "END" ~ block }
check_block = { "CHECK" ~ block }
init_block = { "INIT" ~ block }
unitcheck_block = { "UNITCHECK" ~ block }

// do/eval/goto
do_block = { "do" ~ (block | expression) ~ semicolon? }
eval_statement = { "eval" ~ (block | expression) ~ semicolon? }
goto_statement = { "goto" ~ (goto_target | expression) ~ statement_modifier? ~ semicolon? }

// Statement modifiers (postfix if/unless/while/until/for/foreach)
statement_modifier = {
    ("if" | "unless" | "while" | "until" | "for" | "foreach") ~ expression
}

// POD
pod_section = @{ 
    "=" ~ ASCII_ALPHA+ ~ (!NEWLINE ~ ANY)* ~ NEWLINE ~ 
    (!(NEWLINE ~ "=cut") ~ ANY)* ~ 
    NEWLINE ~ "=cut" ~ (!NEWLINE ~ ANY)* ~ (NEWLINE | EOI)
}

// DATA/END sections
data_section = @{
    "__DATA__" ~ ANY*
}
end_section = @{
    "__END__" ~ ANY*
}

// Comments and whitespace
comment = @{ "#" ~ (!NEWLINE ~ ANY)* }

WHITESPACE = _{ " " | "\t" | "\r" | "\n" }