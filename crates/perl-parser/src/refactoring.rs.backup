//! Refactoring support for Perl code
//!
//! This module provides refactoring operations like extract variable,
//! inline variable, and extract subroutine.

use crate::{
    ast::{Node, NodeKind},
    parser::Parser,
    SourceLocation,
};
use std::collections::HashMap;

/// Refactoring provider
pub struct RefactoringProvider {
    source: String,
}

/// Available refactoring actions
#[derive(Debug, Clone, PartialEq)]
pub enum RefactoringKind {
    ExtractVariable,
    InlineVariable,
    ExtractSubroutine,
    ExtractMethod,
}

/// A refactoring action
#[derive(Debug, Clone)]
pub struct RefactoringAction {
    pub kind: RefactoringKind,
    pub title: String,
    pub edits: Vec<TextEdit>,
}

/// A text edit
#[derive(Debug, Clone)]
pub struct TextEdit {
    pub range: Range,
    pub new_text: String,
}

/// A range in the source code
#[derive(Debug, Clone)]
pub struct Range {
    pub start: usize,
    pub end: usize,
}

impl RefactoringProvider {
    /// Create a new refactoring provider
    pub fn new(source: String) -> Self {
        Self { source }
    }
    
    /// Get available refactorings for a selection
    pub fn get_refactorings(&self, start: usize, end: usize) -> Vec<RefactoringAction> {
        let mut actions = Vec::new();
        
        // Parse the source
        let mut parser = Parser::new(&self.source);
        let ast = match parser.parse() {
            Ok(ast) => ast,
            Err(_) => return actions,
        };
        
        // Check what's selected
        if let Some(node) = self.find_node_in_range(&ast, start, end) {
            match &node.kind {
                NodeKind::Binary { .. } |
                NodeKind::Unary { .. } |
                NodeKind::Ternary { .. } |
                NodeKind::MethodCall { .. } |
                NodeKind::FunctionCall { .. } |
                NodeKind::ArrayRef { .. } |
                NodeKind::HashRef { .. } => {
                    // Can extract expression to variable
                    if let Some(action) = self.create_extract_variable_action(&node, start, end) {
                        actions.push(action);
                    }
                }
                NodeKind::Variable { .. } => {
                    // Can inline variable
                    if let Some(action) = self.create_inline_variable_action(&node) {
                        actions.push(action);
                    }
                }
                _ => {}
            }
        }
        
        // Check if selection contains complete statements
        if self.is_complete_statements(start, end) {
            if let Some(action) = self.create_extract_subroutine_action(start, end) {
                actions.push(action);
            }
        }
        
        actions
    }
    
    /// Extract variable refactoring
    pub fn extract_variable(
        &self,
        start: usize,
        end: usize,
        variable_name: &str,
    ) -> Result<Vec<TextEdit>, RefactoringError> {
        // Get the selected expression
        let selected_text = &self.source[start..end];
        
        // Find the statement containing the selection
        let (stmt_start, indent) = self.find_containing_statement(start)?;
        
        // Create the new variable declaration
        let declaration = format!("{}my ${} = {};\n", indent, variable_name, selected_text);
        
        // Create edits
        let mut edits = Vec::new();
        
        // Insert the declaration before the statement
        edits.push(TextEdit {
            range: Range { start: stmt_start, end: stmt_start },
            new_text: declaration,
        });
        
        // Replace the expression with the variable
        edits.push(TextEdit {
            range: Range { start, end },
            new_text: format!("${}", variable_name),
        });
        
        Ok(edits)
    }
    
    /// Inline variable refactoring
    pub fn inline_variable(
        &self,
        variable_name: &str,
        position: usize,
    ) -> Result<Vec<TextEdit>, RefactoringError> {
        let mut parser = Parser::new(&self.source);
        let ast = parser.parse().map_err(|_| RefactoringError::ParseError)?;
        
        // Find the variable declaration
        let declaration = self.find_variable_declaration(&ast, variable_name, position)?;
        
        // Get the initialization value
        let init_value = match &declaration.kind {
            NodeKind::VariableDeclaration { initializer, .. } => {
                initializer.as_ref()
                    .ok_or(RefactoringError::NoInitializer)?
            }
            _ => return Err(RefactoringError::InvalidNode),
        };
        
        // Find all usages of the variable after declaration
        let usages = self.find_variable_usages(&ast, variable_name, declaration.location.end_offset);
        
        // Check if the variable is modified after initialization
        if self.is_variable_modified(&ast, variable_name, declaration.location.end_offset) {
            return Err(RefactoringError::VariableModified);
        }
        
        // Extract the initialization expression
        let init_text = &self.source[init_value.location.start_offset..init_value.location.end_offset];
        
        let mut edits = Vec::new();
        
        // Replace all usages with the initialization value
        for usage in usages.iter().rev() {
            edits.push(TextEdit {
                range: Range {
                    start: usage.location.start_offset,
                    end: usage.location.end_offset,
                },
                new_text: init_text.to_string(),
            });
        }
        
        // Remove the declaration
        let (line_start, line_end) = self.get_line_bounds(declaration.location.start_offset);
        edits.push(TextEdit {
            range: Range { start: line_start, end: line_end },
            new_text: String::new(),
        });
        
        Ok(edits)
    }
    
    /// Extract subroutine refactoring
    pub fn extract_subroutine(
        &self,
        start: usize,
        end: usize,
        sub_name: &str,
    ) -> Result<Vec<TextEdit>, RefactoringError> {
        // Get the selected code
        let selected_code = &self.source[start..end];
        
        // Find variables used in the selection
        let (params, returns) = self.analyze_variables_in_range(start, end)?;
        
        // Generate parameter list
        let param_list = params.iter()
            .map(|p| format!("${}", p))
            .collect::<Vec<_>>()
            .join(", ");
        
        // Generate the subroutine
        let mut sub_code = format!("sub {} {{\n", sub_name);
        
        if !params.is_empty() {
            sub_code.push_str(&format!("    my ({}) = @_;\n", param_list));
        }
        
        // Add the selected code with proper indentation
        for line in selected_code.lines() {
            sub_code.push_str("    ");
            sub_code.push_str(line);
            sub_code.push('\n');
        }
        
        if !returns.is_empty() {
            sub_code.push_str(&format!("    return {};\n", 
                returns.iter()
                    .map(|r| format!("${}", r))
                    .collect::<Vec<_>>()
                    .join(", ")
            ));
        }
        
        sub_code.push_str("}\n\n");
        
        // Create the function call
        let call = format!("{}({});", sub_name, param_list);
        
        // Find where to insert the subroutine (before the current sub or at the end)
        let insert_pos = self.find_subroutine_insert_position(start);
        
        let mut edits = Vec::new();
        
        // Replace selection with function call
        edits.push(TextEdit {
            range: Range { start, end },
            new_text: call,
        });
        
        // Insert the new subroutine
        edits.push(TextEdit {
            range: Range { start: insert_pos, end: insert_pos },
            new_text: sub_code,
        });
        
        Ok(edits)
    }
    
    // Helper methods
    
    fn find_node_in_range(&self, node: &Node, start: usize, end: usize) -> Option<&Node> {
        if node.span.start >= start && node.span.end <= end {
            return Some(node);
        }
        
        // Check children
        match &node.kind {
            NodeKind::Program { statements } => {
                for stmt in statements {
                    if let Some(found) = self.find_node_in_range(stmt, start, end) {
                        return Some(found);
                    }
                }
            }
            NodeKind::Block { statements } => {
                for stmt in statements {
                    if let Some(found) = self.find_node_in_range(stmt, start, end) {
                        return Some(found);
                    }
                }
            }
            _ => {}
        }
        
        None
    }
    
    fn create_extract_variable_action(&self, node: &Node, start: usize, end: usize) -> Option<RefactoringAction> {
        Some(RefactoringAction {
            kind: RefactoringKind::ExtractVariable,
            title: "Extract to variable".to_string(),
            edits: vec![], // Will be filled when action is executed
        })
    }
    
    fn create_inline_variable_action(&self, node: &Node) -> Option<RefactoringAction> {
        Some(RefactoringAction {
            kind: RefactoringKind::InlineVariable,
            title: "Inline variable".to_string(),
            edits: vec![], // Will be filled when action is executed
        })
    }
    
    fn create_extract_subroutine_action(&self, start: usize, end: usize) -> Option<RefactoringAction> {
        Some(RefactoringAction {
            kind: RefactoringKind::ExtractSubroutine,
            title: "Extract to subroutine".to_string(),
            edits: vec![], // Will be filled when action is executed
        })
    }
    
    fn is_complete_statements(&self, start: usize, end: usize) -> bool {
        // Simple heuristic: check if selection starts at beginning of line
        // and ends with semicolon or newline
        if start > 0 && self.source.chars().nth(start - 1) != Some('\n') {
            return false;
        }
        
        let end_char = self.source.chars().nth(end - 1);
        matches!(end_char, Some(';' | '\n'))
    }
    
    fn find_containing_statement(&self, pos: usize) -> Result<(usize, String), RefactoringError> {
        // Find the start of the line containing pos
        let mut line_start = pos;
        while line_start > 0 && self.source.chars().nth(line_start - 1) != Some('\n') {
            line_start -= 1;
        }
        
        // Get indentation
        let mut indent = String::new();
        for ch in self.source[line_start..].chars() {
            if ch == ' ' || ch == '\t' {
                indent.push(ch);
            } else {
                break;
            }
        }
        
        Ok((line_start, indent))
    }
    
    fn find_variable_declaration(&self, ast: &Node, name: &str, before_pos: usize) -> Result<&Node, RefactoringError> {
        // TODO: Implement proper scope-aware variable lookup
        Err(RefactoringError::VariableNotFound)
    }
    
    fn find_variable_usages(&self, ast: &Node, name: &str, after_pos: usize) -> Vec<&Node> {
        // TODO: Implement variable usage finder
        Vec::new()
    }
    
    fn is_variable_modified(&self, ast: &Node, name: &str, after_pos: usize) -> bool {
        // TODO: Check if variable is assigned after initialization
        false
    }
    
    fn get_line_bounds(&self, pos: usize) -> (usize, usize) {
        let mut start = pos;
        while start > 0 && self.source.chars().nth(start - 1) != Some('\n') {
            start -= 1;
        }
        
        let mut end = pos;
        while end < self.source.len() && self.source.chars().nth(end) != Some('\n') {
            end += 1;
        }
        
        if end < self.source.len() {
            end += 1; // Include the newline
        }
        
        (start, end)
    }
    
    fn analyze_variables_in_range(&self, start: usize, end: usize) -> Result<(Vec<String>, Vec<String>), RefactoringError> {
        // TODO: Analyze which variables are used (params) and modified (returns)
        Ok((Vec::new(), Vec::new()))
    }
    
    fn find_subroutine_insert_position(&self, current_pos: usize) -> usize {
        // TODO: Find the best position to insert new subroutine
        0
    }
}

/// Refactoring error
#[derive(Debug, thiserror::Error)]
pub enum RefactoringError {
    #[error("Parse error")]
    ParseError,
    
    #[error("Variable not found")]
    VariableNotFound,
    
    #[error("Variable has no initializer")]
    NoInitializer,
    
    #[error("Variable is modified after initialization")]
    VariableModified,
    
    #[error("Invalid node type")]
    InvalidNode,
    
    #[error("Invalid selection")]
    InvalidSelection,
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_extract_variable() {
        let source = "my $total = $price * $quantity + $tax;";
        let provider = RefactoringProvider::new(source.to_string());
        
        // Extract "$price * $quantity"
        let result = provider.extract_variable(12, 30, "subtotal");
        assert!(result.is_ok());
        
        let edits = result.unwrap();
        assert_eq!(edits.len(), 2);
    }
}