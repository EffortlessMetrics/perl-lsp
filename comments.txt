File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 306
User: chatgpt-codex-connector[bot]
Comment: **<sub><sub>![P1 Badge](https://img.shields.io/badge/P1-orange?style=flat)</sub></sub>  Parse map/grep/sort list args without commas**

The remaining-argument loop only consumes args when a comma is present, so idiomatic Perl like `map { ... } @list` / `grep { ... } @array` leaves the list operand unparsed and the statement is misparsed or rejected. This regression only happens for map/grep/sort forms that rely on whitespace-separated list arguments, which is the common syntax. Consider restoring the previous ‚Äúparse until statement boundary‚Äù behavior for these builtins so list arguments without commas are accepted.

Useful? React with üëç¬†/ üëé.
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 324
User: chatgpt-codex-connector[bot]
Comment: **<sub><sub>![P2 Badge](https://img.shields.io/badge/P2-yellow?style=flat)</sub></sub>  Accept `my` declarations as tie first arg**

The new `tie` parsing path always uses `parse_expression()` for the first argument, but expressions treat `my` as a bare identifier rather than a declaration. That makes valid statements like `tie my %h, 'Pkg', ...` fail, which the previous builtin handling explicitly supported. This affects any code that ties a freshly declared lexical. Consider reintroducing the `my`-declaration branch for `tie`‚Äôs first argument (similar to `open`/`pipe`).

Useful? React with üëç¬†/ üëé.
---
File: crates/tree-sitter-perl-rs/src/grammar.pest
Line: 870
User: Copilot
Comment: The `glob_pattern` rule change from `(!">'" ~ ANY)*` to `(!">" ~ ANY)*` appears to be fixing a typo (removing the errant single quote). However, this could be a breaking change if any code was relying on the previous behavior. The new pattern correctly allows any characters except `>`, which aligns with Perl's glob syntax.
---
File: crates/tree-sitter-perl-rs/src/heredoc_parser.rs
Line: 699
User: Copilot
Comment: The test validates that declarations are limited to `MAX_HEREDOC_DEPTH`, but it doesn't verify the specific behavior when the limit is exceeded. Consider adding assertions to check that an error message is produced or that the parser gracefully handles the overflow rather than silently truncating.
---
File: crates/tree-sitter-perl-rs/src/heredoc_parser.rs
Line: 119
User: Copilot
Comment: When the heredoc depth limit is reached, the code continues but skips processing that heredoc. This behavior should be documented and tested to ensure that the parser doesn't produce misleading results. Consider adding error reporting or warnings when this limit is hit, similar to the timeout protection error at line 381.
---
File: crates/perl-lexer/tests/heredoc_security_tests.rs
Line: 40
User: Copilot
Comment: The timeout test is non-deterministic and may produce false positives/negatives depending on system load. The 6-second assertion might be too tight for slower CI environments. Consider either using a more deterministic approach (e.g., mocking time) or increasing the timeout threshold to account for system variability.
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 322
User: Copilot
Comment: The `tie` statement now uses `parse_expression()` to parse the variable argument, which should correctly handle `tie my %hash, ...` syntax where the first argument is a variable declaration. However, `parse_expression()` calls `parse_comma()` which treats commas as operators. This could cause issues if the comma after the variable is interpreted as a comma operator instead of an argument separator. Consider testing with complex tie expressions to ensure correct behavior, or use a more restricted parsing method.
```suggestion
                    // First argument to tie can be a variable declaration, e.g. tie my %hash, ...
                    let variable = if self.peek_kind() == Some(TokenKind::My) {
                        Box::new(self.parse_variable_declaration()?)
                    } else {
                        Box::new(self.parse_expression()?)
                    };
```
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 329
User: Copilot
Comment: Similarly, `parse_expression()` here will consume commas as comma operators, potentially parsing `"Package", @args` as a single ArrayLiteral expression. This would prevent the subsequent `while` loop from parsing individual arguments correctly. Use `parse_assignment()` instead to avoid comma operator issues.
```suggestion
                    let variable = Box::new(self.parse_assignment()?);
                    self.expect(TokenKind::Comma)?;
                    let package = Box::new(self.parse_assignment()?);

                    let mut args = vec![];
                    while self.peek_kind() == Some(TokenKind::Comma) {
                        self.consume_token()?; // consume ,
                        args.push(self.parse_assignment()?);
```
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 329
User: Copilot
Comment: Same issue here - `parse_expression()` will treat commas as operators, not argument separators. All arguments should be parsed using `parse_assignment()` to maintain consistent behavior with other builtin function argument parsing.
```suggestion
                    let variable = Box::new(self.parse_assignment()?);
                    self.expect(TokenKind::Comma)?;
                    let package = Box::new(self.parse_assignment()?);

                    let mut args = vec![];
                    while self.peek_kind() == Some(TokenKind::Comma) {
                        self.consume_token()?; // consume ,
                        args.push(self.parse_assignment()?);
```
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 343
User: Copilot
Comment: Use `parse_assignment()` instead of `parse_expression()` here for consistency and to avoid comma operator issues. The untie statement takes a single variable argument, so this is less critical than the tie parsing, but maintaining consistency with other statement parsing is important.
```suggestion
                    let variable = Box::new(self.parse_assignment()?);
```
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 300
User: Copilot
Comment: Using `parse_expression()` instead of `parse_assignment()` may change the behavior of builtin function argument parsing. The `parse_expression()` method calls `parse_comma()`, which could interpret commas as comma operators rather than argument separators in some contexts. The original code used `parse_assignment()` which avoids this issue. This change could break existing code that relies on the previous parsing behavior for builtin functions like `print`, `open`, etc.
---
File: crates/perl-parser-core/src/engine/parser/statements.rs
Line: 306
User: Copilot
Comment: Using `parse_expression()` instead of `parse_assignment()` for the second and subsequent arguments may introduce comma operator ambiguity. This could break parsing of builtin function calls that have multiple arguments. Consider using `parse_assignment()` to maintain consistency with existing builtin argument parsing behavior.
```suggestion
                                args.push(self.parse_assignment()?);
```
---
File: crates/tree-sitter-perl-rs/src/grammar.pest
Line: 414
User: Copilot
Comment: Adding `variable_declaration` as the first alternative in `primary_expression` could introduce parsing ambiguities or change precedence behavior. In Perl, variable declarations are typically statements, not expressions. This change may allow constructs like `my $x = 5` to be parsed as a primary expression, which could lead to unexpected behavior in certain contexts. Consider whether this is intentional and thoroughly test edge cases.
```suggestion
    class_method_call
```
---
File: xtask/src/tasks/corpus_audit/nodekind_analysis.rs
Line: 328
User: Copilot
Comment: The implementation correctly adds cases for Tie and Untie in `collect_nodekinds_recursive`, which is good. However, this function manually enumerates many NodeKind variants rather than using the `for_each_child` method available on Node. Consider refactoring to use `node.for_each_child()` to make this code more maintainable and ensure all node types are handled automatically when new ones are added.
---
File: crates/perl-lexer/src/lib.rs
Line: 990
User: Copilot
Comment: Similar issue with the lexer heredoc depth limit - when the limit is reached, an error token is returned but processing continues. This could lead to confusing parse results where some heredocs are processed and others are not. Consider whether the parser should halt or provide more comprehensive error recovery in this scenario.
---
