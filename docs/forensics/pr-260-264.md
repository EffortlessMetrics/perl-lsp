# PR #260 + #264: Substitution Operator Correctness Fixes

**Type**: Wrongness PR (Mutation Testing Discovery)
**Date**: 2025-12-31 (PR #260), 2026-01-04 (PR #264)
**Commits**:
- `b11ca0c5 fix(parser): substitution operator correctness (MUT_002, MUT_005) (#260)`
- `326707a8 fix(lexer): mixed-delimiter substitution replacement; enable MUT_002 regression (#264)`

---

## 1. Intent

| Field | Description |
| ----- | ----------- |
| PR numbers | #260, #264 |
| Issue/AC | Issue #144 (Ignored Tests Roadmap), #147 (Substitution Story) |
| Stated goal | Fix substitution operator parsing correctness bugs discovered by mutation testing |
| Actual scope | Lexer (`lib.rs`, `quote_handler.rs`), Parser (`parser.rs`, `quote_parser.rs`), Tests |

### The Scar Story

These PRs document a textbook case of **mutation testing catching real bugs**. Two mutant survivors in the substitution operator implementation (MUT_002 and MUT_005) exposed logic flaws that would have caused incorrect behavior in production:

1. **MUT_002**: Empty replacement with balanced/mixed delimiters failed (e.g., `s{pattern}{}` or `s[pattern]{replacement}`)
2. **MUT_005**: Invalid modifier characters were silently accepted (e.g., `s/foo/bar/z` parsed without error)

The tests were written first as `#[ignore]` annotations with mutant IDs, serving as executable documentation of known bugs. The fixes enabled these tests and killed the mutants.

---

## 2. Scope Map

### PR #260 (Main Fix)

| Directory | Files Changed | Lines Delta | Notes |
| --------- | ------------- | ----------- | ----- |
| `crates/perl-lexer/src/` | 2 | +52/-48 | Modifier scanning fix (alphanumeric), parse_regex_modifiers simplified |
| `crates/perl-parser/src/` | 3 | +169/-68 | quote_parser strict validation, parser error propagation |
| `crates/perl-parser/tests/` | 3 | +29/-58 | Regression tests enabled, test scope narrowed |
| `scripts/` | 1 | +3/-3 | Ignored baseline updated |

### PR #264 (Follow-up Cleanup)

| Directory | Files Changed | Lines Delta | Notes |
| --------- | ------------- | ----------- | ----- |
| `crates/perl-lexer/src/` | 1 | +35/-24 | `paired_closing()` helper, `repl_depth` clarity |
| `crates/perl-parser/tests/` | 1 | +94/-232 | De-duplicated tests to data-driven pattern |

**Total**: +278/-147 (PR #260), +131/-279 (PR #264)

---

## 3. Evidence Pointers

### Mutation IDs

| ID | Location | Description | Status |
| --- | -------- | ----------- | ------ |
| MUT_002 | `quote_parser.rs:80` | `&&` to `\|\|` mutation in `!is_paired && !rest1.is_empty()` | KILLED |
| MUT_005 | `parser.rs:4231` (orig) | Modifier validation accepting arbitrary characters | KILLED |

### Regression Tests Enabled

Before (ignored):
```rust
#[ignore = "MUT_002: Exposes empty replacement parsing bug - will kill mutant when fixed"]
fn test_ac2_empty_replacement_balanced_delimiters() { ... }

#[ignore = "MUT_005: Exposes invalid modifier validation bug - will kill mutant when fixed"]
fn test_ac2_invalid_flag_combinations() { ... }
```

After (enabled):
```rust
// MUT_002: Fixed - balanced delimiters now correctly parse replacement with different delimiter type
fn test_ac2_empty_replacement_balanced_delimiters() { ... }

// MUT_005 FIXED: Invalid modifier validation now properly rejects invalid modifiers
fn test_ac2_invalid_flag_combinations() { ... }
```

### Ignored Test Baseline Delta

```diff
-bug=8
+bug=4
-total=9
+total=5
```

---

## 4. Findings

### What Was Wrong

| Bug ID | Problem | Root Cause |
| ------ | ------- | ---------- |
| MUT_002 | `s[pattern]{replacement}` failed - mixed paired delimiters | Replacement scanner assumed same delimiter as pattern |
| MUT_002 | `s{pattern}{}` failed - empty replacement | Per-segment delimiter detection missing |
| MUT_005 | `s/foo/bar/z` accepted silently | Modifier scanning used `is_alphabetic()` not allowlist |
| MUT_005 | Invalid numeric modifiers accepted | Same - no alphanumeric filtering |

### How Mutation Testing Caught It

1. **MUT_002**: Mutator changed `&&` to `||` in condition `!is_paired && !rest1.is_empty()`
   - Original logic: enter manual replacement parsing only for non-paired with content
   - Mutated logic: enter manual parsing incorrectly for paired delimiters
   - Test `s{a}{b}` would fail if mutant survived

2. **MUT_005**: Mutator likely changed modifier character check or removed validation
   - Original (pre-fix): accepted any alphabetic character as modifier
   - Correct behavior: only `g, i, m, s, x, o, e, r` are valid
   - Tests with `s/foo/bar/z` should error but didn't

### Fixes Applied

**MUT_002 Fix** (PR #260 + #264):
```rust
// Before: assumed same delimiter for replacement
(delimiter, closing, false)

// After: detect replacement delimiter independently
if let Some(repl_delim) = self.current_char() {
    if matches!(repl_delim, '{' | '[' | '(' | '<') {
        let repl_close = Self::paired_closing(repl_delim);
        (repl_delim, repl_close, true)
    }
}
```

**MUT_005 Fix** (PR #260):
```rust
// Before: lexer accepted, parser didn't validate
if ch.is_alphabetic() { self.advance(); }

// After: lexer includes alphanumeric, parser validates strictly
if ch.is_ascii_alphanumeric() { self.advance(); }
// Parser layer:
pub fn validate_substitution_modifiers(modifiers_str: &str) -> Result<String, char> {
    if matches!(c, 'g' | 'i' | 'm' | 's' | 'x' | 'o' | 'e' | 'r') {
        valid_modifiers.push(c);
    } else {
        return Err(c);  // Invalid modifier
    }
}
```

---

## 5. Budget Estimates

| Metric | Value | Notes |
| ------ | ----- | ----- |
| DevLT (human attention) | 90-120 min | Band: 30-120 (standard feature) |
| Compute (tokens/CI) | Moderate | Mutation testing run + regression suite |
| Efficiency | High | Mutation testing found bugs that tests alone missed |

### Investment Breakdown

| Activity | Time | Notes |
| -------- | ---- | ----- |
| Mutation test analysis | 30 min | Identifying what MUT_002/005 tested |
| Quote parser fix | 30 min | Delimiter detection refactor |
| Lexer/parser integration | 20 min | Moving validation to parser layer |
| Test enablement | 10 min | Removing #[ignore], verifying |
| PR #264 cleanup | 20 min | `paired_closing()` helper, test dedup |

---

## 6. Factory Delta

| Guardrail | Before | After | Notes |
| --------- | ------ | ----- | ----- |
| Mutation test coverage | MUT_002, MUT_005 survived | Both killed | Tests now exercise logic branches |
| Modifier validation | Lexer only (permissive) | Parser strict + lexer capture | Better error messages |
| Ignored test baseline | bug=8 | bug=4 | 4 substitution bugs fixed |
| Test pattern | Repetitive individual tests | Data-driven pattern | 140 lines reduced in #264 |

### Architectural Improvements

1. **Validation Layer Separation**: Modifiers captured inclusively by lexer, validated strictly by parser
   - Enables better error messages with source location
   - Follows "lex liberally, parse strictly" principle

2. **Delimiter Helper Function**: `paired_closing()` makes pairing explicit
   - Removes unreachable code paths
   - Applies to both substitution and transliteration

3. **Mutation-Killing Test Design**: Tests now specifically target logic conditions
   - `test_kill_mutation_logical_operator_substitution()` exercises `&&` vs `||`
   - `test_kill_mutation_modifier_validation()` exercises character matching

---

## 7. Exhibit Score

| Dimension | Score (1-5) | Notes |
| --------- | ----------- | ----- |
| Clarity of intent | 5 | Mutant IDs in commit messages and test annotations |
| Scope discipline | 4 | Stayed focused, minor test cleanup in #264 |
| Evidence quality | 5 | Mutation IDs as receipts, before/after tests |
| Test coverage | 5 | Regression tests + mutation-killing tests |
| DevLT efficiency | 5 | Mutation testing found bugs before users |

---

## 8. Key Lessons

### Mutation Testing as Bug Discovery

This PR pair demonstrates mutation testing's value beyond coverage metrics:

1. **Real bugs exposed**: MUT_002 and MUT_005 would have caused silent failures
2. **Executable documentation**: `#[ignore = "MUT_XXX: ..."]` serves as bug tracker
3. **Confidence boost**: Killing mutants proves logic correctness

### Test-First for Known Bugs

Pattern used here:
```rust
#[test]
#[ignore = "MUT_XXX: Description - will kill mutant when fixed"]
fn test_known_bug() {
    // Test that will pass when bug is fixed
}
```

After fix:
```rust
#[test]
// MUT_XXX FIXED: Description of what was fixed
fn test_known_bug() {
    // Same test, now enabled
}
```

### Layered Validation Design

Moving validation from lexer to parser enables:
- Precise error locations
- Contextual error messages
- Separation of tokenization from semantics

---

## See Also

- [IGNORED_TESTS_ROADMAP.md](../IGNORED_TESTS_ROADMAP.md) - Wave B fixes
- [BUG_EXECUTION_CHECKLIST.md](../BUG_EXECUTION_CHECKLIST.md) - MUT_002/005 entries
- `crates/perl-parser/tests/quote_parser_mutation_hardening.rs` - Mutation-killing tests
- `crates/perl-parser/tests/substitution_ac_tests.rs` - Acceptance criteria tests
