# Heredoc Handling in Special Contexts: eval and s///e

## Overview

This document outlines the architecture for handling heredocs in two special Perl contexts that require multi-phase parsing:

1. **String eval**: `eval <<'EOF'...\nEOF`
2. **Regex substitution with /e**: `s/pattern/<<EOF/e...\nEOF`

## The Challenge

### 1. String eval Context

In Perl, `eval EXPR` treats the string EXPR as a mini Perl program, parsing it at runtime:

```perl
# The heredoc is NOT processed at compile time
eval <<'EOF';
    my $x = <<'INNER';
    This is inner content
INNER
    print $x;
EOF
```

**Key insight**: The outer heredoc scanner sees and processes the first `<<'EOF'`, but the inner `<<'INNER'` is just text until eval executes.

### 2. Regex Substitution /e Context

The `/e` flag causes the replacement to be evaluated as Perl code:

```perl
# At compile time: heredoc is parsed and becomes a string
# At runtime: the string is eval'd as code
s/foo/<<EOF/e;
bar
EOF
```

**Key insight**: The heredoc is recognized at compile time, but any heredocs generated by the eval'd code would need runtime handling.

## Current Parser Limitation

Our three-phase heredoc parser:
1. **Scanner**: Identifies heredoc declarations
2. **Statement Tracker**: Finds statement boundaries  
3. **Content Processor**: Associates content with declarations

This works for compile-time heredocs but doesn't handle:
- Heredocs inside eval strings (need re-parsing)
- Dynamic heredoc generation in s///e replacements

## Proposed Architecture: Fourth Phase

### Phase 4: Context-Sensitive Re-parsing

```rust
pub struct ContextAwareHeredocParser {
    base_parser: HeredocParser,
    context_stack: Vec<ParseContext>,
}

#[derive(Debug)]
enum ParseContext {
    Normal,
    EvalString { depth: usize },
    RegexReplacement { has_e_flag: bool },
}

impl ContextAwareHeredocParser {
    pub fn parse_with_context(&mut self, input: &str) -> Result<ParsedHeredoc, Error> {
        // Phase 1-3: Normal heredoc parsing
        let mut result = self.base_parser.parse(input)?;
        
        // Phase 4: Context-sensitive re-parsing
        self.handle_special_contexts(&mut result)?;
        
        Ok(result)
    }
    
    fn handle_special_contexts(&mut self, parsed: &mut ParsedHeredoc) -> Result<(), Error> {
        for node in &mut parsed.nodes {
            match node {
                Node::Eval(expr) if expr.is_heredoc() => {
                    // Re-parse the heredoc content as Perl code
                    let inner_content = self.extract_heredoc_content(expr);
                    let inner_parsed = self.parse_with_context(&inner_content)?;
                    node.set_parsed_content(inner_parsed);
                }
                Node::Substitution { replacement, flags } if flags.contains('e') => {
                    // Mark replacement for code evaluation
                    // Note: actual heredoc was already parsed in phase 1
                    replacement.mark_as_code_context();
                }
                _ => {}
            }
        }
        Ok(())
    }
}
```

### Implementation Steps

1. **Context Detection**
   ```rust
   fn detect_context(&self, tokens: &[Token]) -> ParseContext {
       // Scan for eval, s///e patterns
   }
   ```

2. **Recursive Parsing**
   ```rust
   fn parse_eval_content(&mut self, content: &str) -> Result<AstNode, Error> {
       // Create sub-parser instance
       let mut sub_parser = Self::new();
       sub_parser.parse_with_context(content)
   }
   ```

3. **AST Integration**
   ```rust
   fn integrate_sub_ast(&mut self, parent: &mut AstNode, child: AstNode) {
       // Merge child AST maintaining scope
   }
   ```

## Test Cases

### 1. Basic eval heredoc
```perl
eval <<'EOF';
print "Hello";
EOF
```

### 2. Nested heredocs in eval
```perl
eval <<'OUTER';
my $x = <<'INNER';
content
INNER
OUTER
```

### 3. s///e with heredoc
```perl
s/(\w+)/<<EOF/e;
Replaced: $1
EOF
```

### 4. Complex mixing
```perl
eval <<'CODE';
s/foo/<<'END'/e;
bar
END
CODE
```

## Error Handling

1. **Circular References**: Detect and prevent infinite eval loops
2. **Parse Errors**: Bubble up with context information
3. **Resource Limits**: Set max recursion depth for eval parsing

## Performance Considerations

1. **Lazy Parsing**: Only re-parse eval content if needed
2. **Caching**: Cache parsed eval content
3. **Bailout**: Skip re-parsing for very large eval blocks

## Integration Plan

1. **Phase 1**: Extend `HeredocParser` with context detection
2. **Phase 2**: Implement recursive parsing for eval
3. **Phase 3**: Handle s///e flag detection
4. **Phase 4**: Add comprehensive test suite
5. **Phase 5**: Optimize performance

## Conclusion

This fourth phase enables proper handling of Perl's dynamic heredoc contexts while maintaining backward compatibility with existing three-phase parsing. The implementation focuses on correctness first, with performance optimizations as a secondary goal.