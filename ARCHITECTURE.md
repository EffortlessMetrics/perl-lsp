# Architecture Guide

This document provides a comprehensive overview of the tree-sitter-perl project architecture, including three parser implementations and a full LSP server.

## üèóÔ∏è System Overview

The tree-sitter-perl project provides **multiple parser implementations** and **IDE integration**:

1. **v1: C-based Parser**: Original tree-sitter implementation (~95% coverage)
2. **v2: Pest Parser**: Pure Rust with PEG grammar (~99.995% coverage)
3. **v3: Native Parser**: Hand-written lexer+parser (~100% coverage) ‚≠ê
4. **Incremental Parsing**: True subtree reuse for <1ms LSP updates (NEW v0.8.7) üöÄ
5. **LSP Server**: Full Language Server Protocol implementation with real-time editing
6. **Tree-sitter Output**: All parsers produce compatible S-expressions
7. **Performance**: v3 achieves 4-19x speedup over v1 (1-150 ¬µs), incremental achieves 50-100x speedup for edits

## üìê Architecture Diagram

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                     tree-sitter-perl Project                        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ v1: C Parser ‚îÇ  ‚îÇ v2: Pest    ‚îÇ  ‚îÇ v3: Native   ‚îÇ  ‚îÇ  LSP   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   (Legacy)   ‚îÇ  ‚îÇ   Parser     ‚îÇ  ‚îÇParser ‚≠ê     ‚îÇ  ‚îÇ Server ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ         ‚îÇ                  ‚îÇ                  ‚îÇ              ‚îÇ       ‚îÇ
‚îÇ         ‚ñº                  ‚ñº                  ‚ñº              ‚ñº       ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ              Common S-Expression Output Format                ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    v3: Native Parser Detail                   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ perl-lexer  ‚îÇ‚Üí ‚îÇ perl-parser ‚îÇ‚Üí ‚îÇ Tree-sitter AST   ‚îÇ      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ (Tokenizer) ‚îÇ  ‚îÇ (RD Parser) ‚îÇ  ‚îÇ (S-expressions)   ‚îÇ      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                                     ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                    LSP Server Architecture                    ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  JSON-RPC   ‚îÇ  ‚îÇ  Document   ‚îÇ  ‚îÇ Language Services ‚îÇ      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Handler    ‚îÇ  ‚îÇ  Manager    ‚îÇ  ‚îÇ (Diagnostics,     ‚îÇ      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ             ‚îÇ  ‚îÇ  Symbols, etc.)   ‚îÇ      ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò      ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

## üîß Core Components

### 1. v3: Native Parser (Recommended)

#### perl-lexer (`/crates/perl-lexer/`)
**Purpose**: Context-aware tokenization with mode tracking

**Key Features**:
- Mode-based lexing (ExpectTerm, ExpectOperator)
- Handles slash disambiguation (/ as division vs regex)
- Zero dependencies
- Checkpoint/restore for backtracking

#### perl-parser (`/crates/perl-parser/`)
**Purpose**: Recursive descent parser with operator precedence

**Key Features**:
- Consumes tokens from perl-lexer
- Pratt parsing for operators
- 100% edge case coverage
- Tree-sitter compatible AST
- **Enhanced Position Tracking** (v0.8.7+): O(log n) LSP-compliant UTF-16 position mapping

**Position Tracking Architecture** (**Diataxis: Explanation**):
- **PositionTracker**: Production-ready position mapping with LineStartsCache integration
- **ParserContext**: Enhanced token stream processing with accurate position tracking
- **UTF-16 Compliance**: Proper character counting for multi-byte Unicode characters and emoji
- **Multi-line Support**: Accurate position tracking for tokens spanning multiple lines
- **Performance**: Binary search-based position lookups for real-time LSP editing

### 2. v2: Pest Grammar (`/crates/tree-sitter-perl-rs/src/grammar.pest`)

**Purpose**: PEG grammar defining Perl 5 syntax

**Key Features**:
- **Comprehensive Coverage**: All Perl constructs including edge cases
- **Operator Precedence**: Correctly handles 100+ Perl operators
- **Context Sensitivity**: Special handling for `/`, heredocs, etc.
- **Performance**: Optimized rule ordering for common patterns

**Example Rules**:
```pest
program = { SOI ~ statements? ~ EOI }
statement = { 
    simple_assignment     // Fast path
    | sub_declaration
    | if_statement
    | expression_statement
}
```

### 2. Tree-sitter Grammar (`/tree-sitter-perl/grammar.js`)

**Purpose**: Original Tree-sitter grammar with enhanced control flow support

**Key Features**:
- **Enhanced Control Flow**: Complete support for given/when/default statements
- **Tree-sitter Compatibility**: Native integration with Tree-sitter ecosystem  
- **Grammar Completeness**: Expanded coverage of modern Perl control structures
- **AST Node Types**: Dedicated nodes for given_statement, when_statement, default_statement
- **Test Coverage**: Comprehensive corpus testing for all control flow constructs

**Recent Improvements**:
- Added given/when/default grammar rules for switch-style control flow
- Enhanced test corpus with comprehensive edge case coverage  
- Improved Tree-sitter compatibility for modern Perl features

### 3. AST Builder (`src/pure_rust_parser.rs`)

**Purpose**: Converts Pest parse trees to strongly-typed AST nodes

**Key Components**:
- **AstNode Enum**: Comprehensive node types for all Perl constructs
- **build_node()**: Recursive AST construction from Pest pairs
- **Memory Efficiency**: Uses `Arc<str>` for string storage
- **Position Tracking**: Preserves source locations for all nodes

**AST Node Example**:
```rust
pub enum AstNode {
    Program(Vec<AstNode>),
    SubDeclaration {
        name: Arc<str>,
        prototype: Option<Arc<str>>,
        body: Box<AstNode>,
    },
    // ... 50+ node types
}
```

### 4. S-Expression Generator

**Purpose**: Outputs tree-sitter compatible format

**Features**:
- **Compatibility**: Matches tree-sitter's S-expression format exactly
- **Error Nodes**: Graceful handling of unparseable constructs
- **Position Info**: Includes byte ranges for all nodes
- **Streaming**: Can output large ASTs efficiently

### 5. Edge Case Handling System

**Purpose**: Handles Perl's most complex parsing challenges

**Components**:

#### Heredoc Handler (`heredoc_parser.rs`)
- Multi-phase parsing for stateful heredocs
- Supports all variants (quoted, interpolated, indented)
- 99% coverage of real-world patterns

#### Phase-Aware Parser (`phase_aware_parser.rs`)
- Tracks BEGIN/CHECK/INIT/END blocks
- Handles compile-time vs runtime distinctions
- Preserves execution order semantics

#### Enhanced Dynamic Recovery (`dynamic_delimiter_recovery.rs`) ‚ú®
- **Advanced pattern recognition** for delimiter variables across all Perl variable types
- Support for scalar (`my $delim = "EOF"`), array (`my @delims = ("END", "DONE")`), and hash assignments
- **Confidence scoring system** based on variable naming patterns (delim, end, eof, marker, etc.)
- **Multiple recovery strategies** (Conservative, BestGuess, Interactive, Sandbox)
- Enhanced regex patterns supporting all Perl variable declaration types (`my`, `our`, `local`, `state`)
- Clear diagnostics for unparseable cases with suggestions

### 5. Incremental Parsing with Rope-based Document Management (v0.8.7) üöÄ

**Purpose**: High-performance real-time editing with Rope-based text management and subtree reuse

**Architecture**:
```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                 Incremental Parsing with Rope Integration      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ LSP Client  ‚îÇ  ‚îÇ  LSP Edit   ‚îÇ  ‚îÇ   IncrementalDocument   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  (Editor)   ‚îÇ‚Üí ‚îÇ   Event     ‚îÇ‚Üí ‚îÇ  + Rope Integration     ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                                                ‚îÇ                 ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                 Rope-based Position Manager               ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ UTF-16/UTF-8‚îÇ  ‚îÇCRLF/LF Line ‚îÇ  ‚îÇ  Position Cache ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ Conversion  ‚îÇ  ‚îÇ  Handling   ‚îÇ  ‚îÇ   with Rope     ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                        ‚îÇ                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ                Subtree Cache                              ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇContent-based‚îÇ  ‚îÇPosition-based‚îÇ  ‚îÇ   LRU Cache     ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ   Lookup    ‚îÇ  ‚îÇ   Lookup    ‚îÇ  ‚îÇ   Management    ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                        ‚îÇ                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ            Selective Reparse Engine                       ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇFast Token   ‚îÇ  ‚îÇRange-based  ‚îÇ  ‚îÇContainer Node   ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îÇ  Update     ‚îÇ  ‚îÇ  Parsing    ‚îÇ  ‚îÇ   Splicing      ‚îÇ   ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îÇ                        ‚îÇ                                        ‚îÇ
‚îÇ  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê  ‚îÇ
‚îÇ  ‚îÇ           Updated AST with Rope-optimized Metrics         ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ Nodes reused: 142    ‚Ä¢ Nodes reparsed: 3             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ Cache hits: 89%      ‚Ä¢ Parse time: 0.7ms             ‚îÇ  ‚îÇ
‚îÇ  ‚îÇ   ‚Ä¢ UTF-16 conversions: 15   ‚Ä¢ Rope operations: 8       ‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Rope Integration Components** (**Diataxis: Reference**):

#### Rope-based Position Management
- **`textdoc.rs`**: Core document structure with `ropey::Rope` for efficient text operations
- **`position_mapper.rs`**: Centralized UTF-16 ‚Üî UTF-8 position conversion with line ending support
- **`incremental_integration.rs`**: LSP change event processing with Rope-based position tracking
- **`incremental_handler_v2.rs`**: Enhanced document change handling using Rope operations

#### UTF-16/UTF-8 Conversion (Production-Ready)
```rust
// Rope-based position conversion
pub struct PositionMapper {
    rope: Rope,                    // Efficient text representation
    line_ending: LineEnding,       // CRLF/LF/CR detection
}

// Convert LSP positions (UTF-16) to parser byte offsets
impl PositionMapper {
    pub fn lsp_pos_to_byte(&self, pos: Position) -> Option<usize> {
        // Handles emoji, surrogate pairs, and mixed line endings
    }
    
    pub fn byte_to_lsp_pos(&self, byte_offset: usize) -> Position {
        // Accurate UTF-16 code unit calculation
    }
}
```

#### Line Ending Support
- **Windows (CRLF)**: `\r\n` sequences properly handled
- **Unix (LF)**: Standard `\n` line endings  
- **Classic Mac (CR)**: Legacy `\r` line endings
- **Mixed Documents**: Robust detection and per-line handling

**Core Components** (**Diataxis: Reference**):

#### IncrementalDocument (`incremental_document.rs`)
- **Document State**: Version-tracked source text with parsed AST and Rope integration
- **Subtree Cache**: Dual-indexing (content hash + byte range) with Rope-optimized position tracking
- **Metrics Tracking**: Performance analytics (reused vs reparsed nodes, UTF-16 conversions)
- **Edit Application**: Efficient delta processing with Rope-based position adjustment

#### Rope Integration Layer
- **`textdoc::Doc`**: Core document wrapper with `ropey::Rope` for text storage
- **`position_mapper::PositionMapper`**: UTF-16/UTF-8 conversion with line ending detection
- **`incremental_integration::DocumentParser`**: Bridge between LSP and incremental parsing
- **UTF-16 Support**: Handles emoji, surrogate pairs, and variable-width Unicode characters

#### SubtreeCache (Internal)
- **Content Indexing**: Hash-based lookup for common patterns (literals, identifiers)  
- **Position Indexing**: Range-based lookup for accurate AST placement
- **LRU Management**: Memory-efficient cache eviction (1000 item default)
- **Arc Sharing**: Zero-copy node reuse via Arc<Node> reference counting

#### Selective Reparse Engine
- **Fast Token Updates**: Single-token changes (numbers, strings, identifiers) with in-place updates
- **Range-based Parsing**: Targeted parsing for affected regions only
- **Container Splicing**: Recursive reuse for Program, Block, Binary nodes
- **Fallback Strategy**: Graceful degradation to full parsing when needed

**Performance Characteristics** (**Diataxis: Explanation**):
- **<1ms updates** for small edits (token changes): 50-100x faster than full reparse
- **<2ms updates** for moderate edits (function changes): 25-50x faster than full reparse
- **70-90% cache hit ratios** in typical editing workflows
- **Memory efficient**: O(1) cache lookup, O(depth) position adjustment
- **Safety limits**: Cache size bounds, recursion depth limits, timeout protection

**Integration Points**:
- **LSP Server**: Automatic enablement via `DocumentParser` integration
- **Error Recovery**: Maintains functionality during incomplete/invalid code states  
- **Fallback Support**: Full reparse available when incremental parsing fails
- **Test Infrastructure**: Comprehensive async harness with timeout support
### 6. LSP Server (`/crates/perl-parser/src/lsp_server.rs`)

**Purpose**: Language Server Protocol implementation for IDE integration

**Architecture**:

```
LSP Client (Editor) ‚Üê‚Üí JSON-RPC ‚Üê‚Üí LSP Server
                                        ‚Üì
                                 Document Manager
                                        ‚Üì
                                 Parser (v3) ‚Üí AST
                                        ‚Üì
                                 Language Services
```

**Key Components**:

#### JSON-RPC Handler
- Processes LSP requests/responses
- Manages client-server communication
- Handles lifecycle (initialize, shutdown)

#### Document Manager
- Tracks open documents
- Caches parsed ASTs
- Manages document versions
- **Enhanced Position Tracking** (v0.8.7+): LSP-compliant UTF-16 position mapping with O(log n) performance

#### Language Services
- **Enhanced DiagnosticsProvider**: Advanced syntax error detection with variable pattern recognition
- **ScopeAnalyzer**: Advanced variable resolution supporting complex patterns
  - Hash access patterns: `$hash{key}` ‚Üí resolves `%hash`
  - Array access patterns: `$array[idx]` ‚Üí resolves `@array`
  - Method call patterns: `$obj->method` ‚Üí resolves base variable
  - Hash key context detection to reduce false bareword warnings
  - Recursive pattern resolution with fallback mechanisms
- **DocumentSymbolProvider**: Outline generation
- **DefinitionProvider**: Go to definition
- **ReferencesProvider**: Find all references
- **SignatureHelpProvider**: Parameter hints
- **SemanticTokensProvider**: Enhanced highlighting

## üîç Parser Pipeline

### 1. Tokenization
- Pest handles tokenization via grammar rules
- Zero-copy design using string slices
- Unicode-aware with proper boundaries

### 2. Parsing
- Recursive descent with packrat optimization
- Left recursion eliminated via precedence climbing
- Error recovery at statement boundaries

### 3. AST Construction
- Bottom-up construction from parse tree
- Type-safe node creation
- Position information preserved

### 4. Output Generation
- Tree-sitter S-expression format
- Optional debug output
- Streaming for large files

## üöÄ Performance Optimizations

### Grammar Optimizations
- **Fast Paths**: Common patterns parsed first
- **Atomic Rules**: Prevent backtracking where possible
- **Rule Ordering**: Most likely matches first

### Memory Optimizations
- **Arc<str>**: Shared string storage
- **Zero-Copy**: Parse directly from input
- **Lazy Allocation**: Build only required nodes

### Runtime Optimizations
- **Incremental Parsing**: Future enhancement
- **Parallel Parsing**: Parse independent blocks concurrently
- **Caching**: Reuse common subpatterns

## üß™ Testing Strategy

### Comprehensive Test Suite (16+ files)
- **Feature Tests**: `comprehensive_feature_tests.rs` - All Perl constructs
- **Heredoc Tests**: `comprehensive_heredoc_tests.rs`, `unicode_heredoc_tests.rs`
- **Edge Cases**: `edge_case_tests.rs` - Complex parsing scenarios
- **Integration**: `integration_tests.rs` - Full pipeline validation
- **Parser Tests**: `pure_rust_parser_tests.rs` - Unit tests
- **Special Context**: Multiple specialized test files

### Coverage Areas
- ‚úÖ Most Perl 5 syntax (~95% coverage)
- ‚úÖ Unicode support (identifiers, strings)
- ‚úÖ Modern Perl features (signatures, try/catch)
- ‚úÖ Statement modifiers and postfix operators
- ‚úÖ Complex interpolation and heredocs

### Performance Validation
- Criterion benchmarks in `/benches/`
- ~180 ¬µs/KB parsing speed
- Memory efficiency validation
- Comparison with C parser baseline

## üîç Scope Analysis Architecture (v0.8.6)

### ScopeAnalyzer Components

The LSP server includes a sophisticated scope analyzer for real-time code analysis:

```
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ                ScopeAnalyzer                    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ                                                 ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ Variable Scope  ‚îÇ   ‚îÇ Hash Key Context    ‚îÇ   ‚îÇ
‚îÇ ‚îÇ   Tracking      ‚îÇ   ‚îÇ    Detection        ‚îÇ   ‚îÇ
‚îÇ ‚îÇ                 ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ my/our/local  ‚îÇ   ‚îÇ ‚Ä¢ Hash subscripts   ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ Lexical scope ‚îÇ   ‚îÇ ‚Ä¢ Hash literals     ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ Usage tracking‚îÇ   ‚îÇ ‚Ä¢ Hash slices       ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îÇ                                                 ‚îÇ
‚îÇ ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê   ‚îÇ
‚îÇ ‚îÇ Pragma Tracker  ‚îÇ   ‚îÇ Issue Generator     ‚îÇ   ‚îÇ
‚îÇ ‚îÇ                 ‚îÇ   ‚îÇ                     ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ use strict    ‚îÇ   ‚îÇ ‚Ä¢ Undefined vars    ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ use warnings  ‚îÇ   ‚îÇ ‚Ä¢ Unused vars       ‚îÇ   ‚îÇ
‚îÇ ‚îÇ ‚Ä¢ Pragma state  ‚îÇ   ‚îÇ ‚Ä¢ Bareword warnings ‚îÇ   ‚îÇ
‚îÇ ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

### Hash Key Context Detection

**The Challenge**: Perl's `use strict` forbids barewords but allows them as hash keys.

**The Solution**: Advanced AST traversal to identify valid hash key contexts:

1. **Hash Subscripts**: `$hash{bareword}` - detects `{}` binary operations
2. **Hash Literals**: `{key => value}` - examines HashLiteral node pairs  
3. **Hash Slices**: `@hash{key1, key2}` - handles array literals in hash contexts

**Implementation Details**:
- `is_in_hash_key_context()` method walks AST parent chain
- Uses `std::ptr::eq` for precise node identity checking
- Maintains backward compatibility while eliminating false positives
- Comprehensive test coverage with 27 passing scope analyzer tests

### Scope Tracking Algorithm

```rust
// Simplified algorithm flow
fn analyze_variable(node: &Node, scope: &Scope) -> Vec<Issue> {
    match node.kind {
        Variable => check_declaration_and_usage(node, scope),
        Identifier => {
            if strict_mode && !is_in_hash_key_context(node) {
                flag_bareword_violation(node)
            }
        }
        Block => create_new_scope_and_recurse(node),
        // ... other node types
    }
}
```

## üîí Error Handling

### Parse Errors
- Clear error messages with location
- Recovery at statement boundaries
- Partial AST generation

### Scope Analysis Errors (NEW v0.8.6)
- Context-aware bareword detection
- Precise hash key identification
- Reduced false positives by ~90%
- Works with incomplete/invalid code

### Edge Case Errors
- Diagnostic information in separate channel
- Graceful degradation
- Clear indication of limitations

## üîç Scope Analyzer with Hash Key Context Detection (v0.8.7+)

**Diataxis: Reference** - Technical specification for production-stable scope analysis

### Architecture Overview
The scope analyzer provides comprehensive Perl variable and context tracking with industry-leading hash key context detection:

```rust
/// Advanced scope analyzer with hash key context detection
pub struct ScopeAnalyzer {
    /// Stack-based hash key context tracker for nested hash access patterns
    /// Each boolean represents whether the current analysis depth is within a hash key
    hash_key_stack: RefCell<Vec<bool>>,
}
```

### Hash Key Context Detection

#### Core Algorithm
- **Stack-based tracking**: Maintains boolean stack for nested hash access patterns
- **O(depth) performance**: Efficient traversal with safety limits for deep nesting
- **Context propagation**: Tracks hash key contexts through Binary operations (`op == "{}"`)

#### Supported Hash Patterns
1. **Hash Subscripts**: `$hash{bareword_key}` - Direct hash access with bareword keys
2. **Hash Literals**: `{ key => value, another_key => value2 }` - All keys properly identified
3. **Hash Slices**: `@hash{key1, key2, key3}` - Array-based key detection
4. **Nested Structures**: `$hash{level1}{level2}{level3}` - Deep nesting support

#### Implementation Details
```rust
fn is_in_hash_key_context(&self, _node: &Node) -> bool {
    // Walk the ancestor stack to see if any parent indicates a hash subscript
    // Performance: O(depth) iteration, typically 1-10 elements
    self.hash_key_stack.borrow().iter().any(|&b| b)
}
```

### Variable Resolution Patterns
- **Undefined Variable Detection**: Enhanced accuracy under `use strict` mode
- **Context-aware Analysis**: Bareword detection excludes hash key contexts
- **Pragma State Integration**: Works with PragmaTracker for strict/warnings state
- **Scope Hierarchy**: Supports nested scopes with variable shadowing detection

### Test Coverage
- **26+ comprehensive tests**: All hash key context scenarios covered
- **Production validation**: Proven in real-world Perl codebases
- **Edge case coverage**: Complex nesting patterns and mixed contexts
- **Performance benchmarks**: O(depth) complexity validated

### Performance Characteristics
- **Memory efficient**: RefCell<Vec<bool>> for minimal overhead
- **Safety limits**: Prevents infinite recursion in malformed ASTs
- **Context preservation**: Stack-based approach maintains accuracy through recursive analysis

## üö¶ Future Enhancements

### Planned Features
1. **Incremental Parsing**: Update AST for file changes
2. **Query Support**: Tree-sitter query language
3. **LSP Integration**: Language server protocol
4. **WASM Target**: Browser-based parsing

### Architecture Evolution
- Maintain backward compatibility
- Preserve S-expression format
- Enhance performance iteratively

## üìö References

- [Pest Parser](https://pest.rs/): PEG parser generator
- [Tree-sitter](https://tree-sitter.github.io/): Parsing framework
- [Perl Language Reference](https://perldoc.perl.org/): Official Perl documentation

---

This architecture provides a solid foundation for a modern, maintainable Perl parser that integrates seamlessly with existing tooling while being purely Rust-based.