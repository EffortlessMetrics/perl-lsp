--- a/crates/perl-parser/src/parser.rs
+++ b/crates/perl-parser/src/parser.rs
@@ -808,11 +808,73 @@ impl<'a> Parser<'a> {
         
         // Parse optional prototype or signature after attributes
         let (params, prototype) = if self.peek_kind() == Some(TokenKind::LeftParen) {
-            // Check if this is an old-style prototype or a modern signature
-            if self.is_prototype() {
-                let proto = self.parse_prototype()?;
+            // Try to determine if this is a prototype or signature by looking ahead
+            if let Some(proto) = self.try_parse_as_prototype()? {
                 // Store prototype as an attribute
                 attributes.push(format!("prototype({})", proto));
                 (Vec::new(), Some(proto))
             } else {
                 (self.parse_signature()?, None)
             }
         } else {
             (Vec::new(), None)
         };
         
         let body = self.parse_block()?;
         
         let end = self.previous_position();
         Ok(Node::new(
             NodeKind::Subroutine {
                 name,
                 params,
                 attributes,
                 body: Box::new(body),
             },
             SourceLocation { start, end }
         ))
     }
+    
+    /// Try to parse parentheses content as a prototype
+    /// Returns Some(prototype_string) if it looks like a prototype, None otherwise
+    fn try_parse_as_prototype(&mut self) -> ParseResult<Option<String>> {
+        // Look ahead to determine if this is a prototype
+        // Prototypes contain: $ @ % & * ; \ and combinations thereof
+        // Signatures contain: variable names, type constraints, defaults
+        
+        let mut lookahead_index = 1; // Skip the opening paren
+        let mut proto_chars = String::new();
+        let mut looks_like_prototype = true;
+        
+        // Scan ahead without consuming tokens
+        loop {
+            let token = match self.tokens.peek_at(lookahead_index) {
+                Some(t) => t,
+                None => return Ok(None), // EOF
+            };
+            
+            match token.kind {
+                TokenKind::RightParen => {
+                    // End of parentheses
+                    break;
+                }
+                TokenKind::Dollar | TokenKind::At | TokenKind::Percent | TokenKind::Star => {
+                    proto_chars.push_str(&token.text);
+                    lookahead_index += 1;
+                }
+                TokenKind::BitwiseAnd => {
+                    // & in prototype context means code reference
+                    proto_chars.push('&');
+                    lookahead_index += 1;
+                }
+                TokenKind::Semicolon => {
+                    proto_chars.push(';');
+                    lookahead_index += 1;
+                }
+                TokenKind::Backslash => {
+                    proto_chars.push('\\');
+                    lookahead_index += 1;
+                }
+                TokenKind::Identifier => {
+                    // If we see an identifier, it's likely a signature
+                    looks_like_prototype = false;
+                    break;
+                }
+                TokenKind::Colon => {
+                    // Named parameter syntax :$foo means signature
+                    looks_like_prototype = false;
+                    break;
+                }
+                _ => {
+                    // Unknown token, probably not a prototype
+                    looks_like_prototype = false;
+                    break;
+                }
+            }
+        }
+        
+        if looks_like_prototype && !proto_chars.is_empty() {
+            // Now actually consume the tokens to build the prototype
+            self.tokens.next()?; // consume '('
+            let mut result = String::new();
+            
+            loop {
+                let token = self.tokens.peek()?;
+                match token.kind {
+                    TokenKind::RightParen => {
+                        self.tokens.next()?; // consume ')'
+                        return Ok(Some(result));
+                    }
+                    TokenKind::Dollar | TokenKind::At | TokenKind::Percent | TokenKind::Star => {
+                        result.push_str(&self.tokens.next()?.text);
+                    }
+                    TokenKind::BitwiseAnd => {
+                        result.push('&');
+                        self.tokens.next()?;
+                    }
+                    TokenKind::Semicolon => {
+                        result.push(';');
+                        self.tokens.next()?;
+                    }
+                    TokenKind::Backslash => {
+                        result.push('\\');
+                        self.tokens.next()?;
+                    }
+                    _ => {
+                        return Err(ParseError::syntax("Invalid prototype", self.current_position()));
+                    }
+                }
+            }
+        } else {
+            Ok(None)
+        }
+    }