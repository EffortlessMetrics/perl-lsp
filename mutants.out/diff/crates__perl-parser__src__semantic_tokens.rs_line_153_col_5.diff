--- crates/perl-parser/src/semantic_tokens.rs
+++ replace remove_overlapping_tokens -> Vec<(u32, u32, u32, u32, u32)> with vec![(1, 1, 0, 0, 1)]
@@ -145,49 +145,17 @@
     encode_raw_tokens_to_deltas(dedup_tokens)
 }
 
 /// Remove overlapping tokens to comply with LSP specification
 /// Prefers tokens with higher specificity (AST over lexer) and longer spans
 fn remove_overlapping_tokens(
     mut raw_tokens: Vec<(u32, u32, u32, u32, u32)>,
 ) -> Vec<(u32, u32, u32, u32, u32)> {
-    if raw_tokens.is_empty() {
-        return raw_tokens;
-    }
-
-    // Sort by position (line, then character), then by length (longer first for same position)
-    raw_tokens.sort_by(|a, b| {
-        a.0.cmp(&b.0).then(a.1.cmp(&b.1)).then(b.2.cmp(&a.2)) // Longer tokens first (reverse order)
-    });
-
-    let mut result = Vec::new();
-
-    for token in raw_tokens {
-        let (line, char, len, _kind, _mods) = token;
-        let end_char = char + len;
-
-        // Check if this token overlaps with any already accepted token
-        let overlaps = result.iter().any(|&(existing_line, existing_char, existing_len, _, _)| {
-            if line != existing_line {
-                return false; // Different lines, no overlap
-            }
-
-            let existing_end = existing_char + existing_len;
-
-            // Check for overlap: token starts before existing ends AND token ends after existing starts
-            !(end_char <= existing_char || char >= existing_end)
-        });
-
-        if !overlaps {
-            result.push(token);
-        }
-    }
-
-    result
+    vec![(1, 1, 0, 0, 1)] /* ~ changed by cargo-mutants ~ */
 }
 
 /// Thread-safe token encoding from raw position data
 fn encode_raw_tokens_to_deltas(
     mut raw_tokens: Vec<(u32, u32, u32, u32, u32)>,
 ) -> Vec<EncodedToken> {
     // Sort by position (line, then character)
     raw_tokens.sort_by(|a, b| a.0.cmp(&b.0).then(a.1.cmp(&b.1)));
