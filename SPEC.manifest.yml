---
spec_version: "1.0"
issue_id: 147
title: "Complete Substitution Operator Parsing Implementation"
created_at: "2025-09-16T00:00:00Z"
status: "sealed"

scope:
  description: "Implement complete parsing support for Perl substitution operators (s///) including replacement text and modifier flags"

  includes:
    - "Replacement text parsing for substitution operators"
    - "Modifier flag parsing and validation (g,i,m,s,x,o,e,r)"
    - "Alternative delimiter support for substitution operators"
    - "AST representation for all substitution components"
    - "Comprehensive test coverage for substitution variations"
    - "Documentation updates reflecting complete support"

  excludes:
    - "Runtime evaluation of substitution operations"
    - "Modification of existing regex pattern parsing (already working)"
    - "Changes to lexer tokenization beyond delimiter recognition"
    - "LSP-specific feature implementations (handled by existing providers)"

constraints:
  technical:
    - "Must maintain backward compatibility with existing AST structure"
    - "Must not break existing regex parsing functionality"
    - "Must handle Unicode delimiters appropriately"
    - "Must preserve source position information for all parsed components"
    - "Must integrate with existing error reporting mechanisms"

  performance:
    - "Parsing performance must not degrade by more than 5% for non-substitution code"
    - "Memory usage for AST nodes must remain reasonable (<100 bytes per substitution node)"

  compatibility:
    - "Must support Perl 5.x substitution operator semantics"
    - "Must handle edge cases consistently with perl interpreter behavior"
    - "Must work across all supported platforms (Windows, macOS, Linux)"

public_contracts:
  ast_schema:
    SubstitutionOperator:
      description: "AST node representing a complete substitution operator"
      fields:
        - name: "pattern"
          type: "RegexPattern"
          description: "The search pattern (already supported)"
        - name: "replacement"
          type: "ReplacementText"
          description: "The replacement text with backreference support"
        - name: "flags"
          type: "SubstitutionFlags"
          description: "Modifier flags (g,i,m,s,x,o,e,r)"
        - name: "delimiter"
          type: "char"
          description: "The delimiter character used"
        - name: "span"
          type: "Span"
          description: "Source position information"

    ReplacementText:
      description: "Represents replacement text with potential backreferences"
      fields:
        - name: "text"
          type: "String"
          description: "Raw replacement text"
        - name: "backreferences"
          type: "Vec<BackReference>"
          description: "List of backreferences ($1, $2, $&, etc.)"
        - name: "span"
          type: "Span"
          description: "Source position information"

    SubstitutionFlags:
      description: "Represents substitution modifier flags"
      fields:
        - name: "global"
          type: "bool"
          description: "g flag - replace all occurrences"
        - name: "case_insensitive"
          type: "bool"
          description: "i flag - case insensitive matching"
        - name: "multiline"
          type: "bool"
          description: "m flag - multiline mode"
        - name: "single_line"
          type: "bool"
          description: "s flag - single line mode"
        - name: "extended"
          type: "bool"
          description: "x flag - extended regex"
        - name: "compile_once"
          type: "bool"
          description: "o flag - compile once"
        - name: "evaluate"
          type: "bool"
          description: "e flag - evaluate replacement as expression"
        - name: "return_count"
          type: "bool"
          description: "r flag - return substitution count"
        - name: "span"
          type: "Span"
          description: "Source position information"

  parser_interface:
    functions:
      - name: "parse_substitution_operator"
        description: "Main entry point for parsing substitution operators"
        signature: "fn parse_substitution_operator(&mut self) -> Result<SubstitutionOperator, ParseError>"

      - name: "parse_replacement_text"
        description: "Parse replacement text with backreference detection"
        signature: "fn parse_replacement_text(&mut self, delimiter: char) -> Result<ReplacementText, ParseError>"

      - name: "parse_substitution_flags"
        description: "Parse and validate substitution modifier flags"
        signature: "fn parse_substitution_flags(&mut self) -> Result<SubstitutionFlags, ParseError>"

      - name: "validate_flag_combination"
        description: "Validate that flag combinations are valid"
        signature: "fn validate_flag_combination(flags: &SubstitutionFlags) -> Result<(), ParseError>"

risks:
  high:
    - "Complex delimiter parsing could introduce edge case bugs"
    - "Backreference parsing complexity may affect maintainability"

  medium:
    - "AST schema changes could require updates in dependent code"
    - "Performance impact on large files with many substitutions"

  low:
    - "Documentation updates may lag behind implementation"
    - "Test coverage gaps for obscure delimiter combinations"

mitigation_strategies:
  - "Comprehensive property-based testing for delimiter combinations"
  - "Performance benchmarking before and after implementation"
  - "Gradual rollout with feature flags if needed"
  - "Code review focus on edge case handling"

dependencies:
  internal:
    - "perl-lexer crate for enhanced delimiter tokenization"
    - "existing regex parsing infrastructure"
    - "error reporting and span management systems"

  external:
    - "Unicode support libraries for delimiter validation"

testing_strategy:
  unit_tests:
    - "Individual component parsing (replacement, flags, delimiters)"
    - "AST node creation and serialization"
    - "Error handling for malformed substitutions"

  integration_tests:
    - "End-to-end parsing of complete substitution operators"
    - "Cross-component integration (parser + lexer + AST)"
    - "LSP feature integration tests"

  property_tests:
    - "Random delimiter character combinations"
    - "Random flag combinations and validation"
    - "Fuzz testing for edge cases"

success_criteria:
  functional:
    - "All 6 acceptance criteria from ISSUE-147.story.md are met"
    - "100% test coverage for new parsing functionality"
    - "Zero regression in existing functionality"

  non_functional:
    - "Parsing performance within 5% of baseline"
    - "Memory usage within acceptable bounds"
    - "Clean clippy and format checks"

implementation_phases:
  phase_1:
    - "AST schema design and implementation"
    - "Basic replacement text parsing"
    - "Unit tests for core components"

  phase_2:
    - "Modifier flag parsing and validation"
    - "Alternative delimiter support"
    - "Integration tests"

  phase_3:
    - "Error handling and edge cases"
    - "Performance optimization"
    - "Documentation updates"

rollback_plan:
  triggers:
    - "Performance degradation >10%"
    - "Breaking changes in dependent code"
    - "Critical parsing bugs affecting existing functionality"

  steps:
    - "Revert parser changes"
    - "Restore previous AST schema"
    - "Run full regression test suite"
    - "Document issues for future resolution"

---