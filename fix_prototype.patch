diff --git a/crates/perl-parser/src/parser.rs b/crates/perl-parser/src/parser.rs
index 1234567..abcdefg 100644
--- a/crates/perl-parser/src/parser.rs
+++ b/crates/perl-parser/src/parser.rs
@@ -808,11 +808,11 @@ impl<'a> Parser<'a> {
         
         // Parse optional prototype or signature after attributes
         let (params, prototype) = if self.peek_kind() == Some(TokenKind::LeftParen) {
-            // Check if this is an old-style prototype or a modern signature
-            if self.is_prototype() {
-                let proto = self.parse_prototype()?;
+            // Try to determine if this is a prototype or signature
+            if let Some(proto) = self.try_parse_prototype()? {
                 // Store prototype as an attribute
                 attributes.push(format!("prototype({})", proto));
+                // Prototypes have no params in the AST
                 (Vec::new(), Some(proto))
             } else {
                 (self.parse_signature()?, None)
@@ -833,6 +833,60 @@ impl<'a> Parser<'a> {
             SourceLocation { start, end }
         ))
     }
+    
+    /// Try to parse a prototype - returns Some(prototype) if it's a prototype, None if it's a signature
+    fn try_parse_prototype(&mut self) -> ParseResult<Option<String>> {
+        // Save parser state in case we need to backtrack
+        let saved_pos = self.tokens.position();
+        
+        self.tokens.next()?; // consume '('
+        let mut proto = String::new();
+        let mut seen_semicolon = false;
+        
+        while let Ok(token) = self.tokens.peek() {
+            match token.kind {
+                TokenKind::RightParen => {
+                    self.tokens.next()?; // consume ')'
+                    return Ok(Some(proto));
+                }
+                TokenKind::Dollar | TokenKind::At | TokenKind::Percent | TokenKind::Star => {
+                    // These are prototype characters
+                    proto.push_str(&self.tokens.next()?.text);
+                }
+                TokenKind::BitwiseAnd => {
+                    // & in prototype means code reference
+                    proto.push('&');
+                    self.tokens.next()?;
+                }
+                TokenKind::Semicolon => {
+                    // ; marks optional parameters
+                    proto.push(';');
+                    seen_semicolon = true;
+                    self.tokens.next()?;
+                }
+                TokenKind::Backslash => {
+                    // \ means reference prototype
+                    proto.push('\\');
+                    self.tokens.next()?;
+                }
+                TokenKind::Identifier => {
+                    // If we see an identifier, it's likely a signature parameter
+                    // But we need to check - old prototypes can have type constraints
+                    // For now, assume identifier means signature
+                    self.tokens.set_position(saved_pos);
+                    return Ok(None);
+                }
+                _ => {
+                    // Unknown token in prototype context
+                    self.tokens.set_position(saved_pos);
+                    return Ok(None);
+                }
+            }
+        }
+        
+        // If we get here without closing paren, it's an error
+        self.tokens.set_position(saved_pos);
+        Ok(None)
+    }
 