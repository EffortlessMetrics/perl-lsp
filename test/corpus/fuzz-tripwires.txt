==================
qw with regex code and re eval
==================
# @id: fuzz_tripwires.001
# @tags: indirect qw regex regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


use re 'eval';
my @words = qw(foo bar baz);
my $ok = "a" =~ /(??{"a"}) (?{ $c++ })/x;
no re 'eval';
my @items = qw/one two three/;

---

(source_file
  (use_statement (identifier) (string))
  (expression_statement (my_declaration (variable) (qw_list)))
  (expression_statement (my_declaration (variable) (binary_expression (string) (regex))))
  (no_statement (identifier) (string))
  (expression_statement (my_declaration (variable) (qw_list))))

==================
Pack inside sprintf with heredoc literal
==================
# @id: fuzz_tripwires.002
# @tags: indirect qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


my $s = sprintf "%v02X", pack("H*", "DEAD");
my $x = <<'EOF';
sprintf("%s", "ok");
EOF
my $y = sprintf "%vd", pack("U*", 0x41, 0x42);

---

(source_file
  (expression_statement (my_declaration (variable) (call_expression (identifier) (string) (call_expression (identifier) (argument_list (string) (string))))))
  (expression_statement (my_declaration (variable) (heredoc)))
  (expression_statement (my_declaration (variable) (call_expression (identifier) (string) (call_expression (identifier) (argument_list (string) (number) (number)))))))

==================
Indirect with CORE restore and file test chain
==================
# @id: fuzz_tripwires.003
# @tags: file-test indirect qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


new Point 1, 2;
*CORE::GLOBAL::open = sub { die "blocked" };
CORE::open(my $fh, "<", $file);
-r $file && -f _ && -s _;
print FH "test";

---

(source_file
  (expression_statement (indirect_method_call (identifier) (number) (number)))
  (expression_statement (assignment_expression (glob) (anonymous_subroutine (block (expression_statement (call_expression (identifier) (string)))))))
  (expression_statement (call_expression (qualified_identifier) (argument_list (my_declaration (variable)) (string) (variable))))
  (expression_statement (binary_expression (binary_expression (file_test (variable)) (file_test)) (file_test)))
  (expression_statement (call_expression (identifier) (identifier) (string))))

==================
Mixed statement modifiers with do while
==================
# @id: fuzz_tripwires.004
# @tags: indirect qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


do { $x++ } while $x < 3;
print $x if $x > 0;
return unless defined wantarray;
die "error" unless $ok;
do { last if $done; $i++ } until $i > 10;

---

(source_file
  (do_while_statement (block (expression_statement (postfix_expression (variable)))) (binary_expression (variable) (number)))
  (expression_statement (statement_modifier (call_expression (identifier) (variable)) (binary_expression (variable) (number))))
  (return_statement (statement_modifier (call_expression (identifier) (call_expression (identifier)))))
  (expression_statement (statement_modifier (call_expression (identifier) (string)) (variable)))
  (do_until_statement (block 
    (expression_statement (statement_modifier (call_expression (identifier)) (variable)))
    (expression_statement (postfix_expression (variable))))
    (binary_expression (variable) (number))))

==================
Complex delimiter mixing
==================
# @id: fuzz_tripwires.005
# @tags: indirect qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


m!pattern!;
s{old}{new}g;
tr|a-z|A-Z|;
qr~regex~i;
qq#interpolated $var#;
q<literal>;
qx`command`;
qw[word list];

---

(source_file
  (expression_statement (regex))
  (expression_statement (substitution))
  (expression_statement (transliteration))
  (expression_statement (regex))
  (expression_statement (string))
  (expression_statement (string))
  (expression_statement (qx_string))
  (expression_statement (qw_list)))

==================
Nested constructs with precedence
==================
# @id: fuzz_tripwires.006
# @tags: indirect qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


my $x = do { local $/ = undef; <$fh> } // "default";
my @y = map { do { $_ * 2 } if $_ > 0 } @nums;
sub f { wantarray ? do { @list } : do { $scalar } }
my $z = eval { do { die } } || $fallback;

---

(source_file
  (expression_statement (my_declaration (variable) (binary_expression 
    (do_block (block 
      (expression_statement (local_declaration (special_variable) (undef)))
      (expression_statement (readline (variable)))))
    (string))))
  (expression_statement (my_declaration (variable) (call_expression (identifier) (block 
    (expression_statement (statement_modifier 
      (do_block (block (expression_statement (binary_expression (variable) (number)))))
      (binary_expression (variable) (number)))))
    (variable))))
  (subroutine_declaration (identifier) (block 
    (expression_statement (ternary_expression 
      (call_expression (identifier))
      (do_block (block (expression_statement (variable))))
      (do_block (block (expression_statement (variable))))))))
  (expression_statement (my_declaration (variable) (binary_expression 
    (call_expression (identifier) (block (expression_statement (do_block (block (expression_statement (call_expression (identifier))))))))
    (variable)))))

==================
Unicode and special encoding edge cases
==================
# @id: fuzz_tripwires.007
# @tags: indirect punctuation-var qw regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


my $♥ = "love";
my $π = 3.14159;
use utf8;
my $Σ = sub { sum(@_) };
binmode STDOUT, ":encoding(UTF-8)";
open my $fh, "<:raw:encoding(UTF-8):crlf", $file;

---

(source_file
  (expression_statement (my_declaration (variable) (string)))
  (expression_statement (my_declaration (variable) (number)))
  (use_statement (identifier))
  (expression_statement (my_declaration (variable) (anonymous_subroutine (block (expression_statement (call_expression (identifier) (argument_list (special_variable))))))))
  (expression_statement (call_expression (identifier) (identifier) (string)))
  (expression_statement (call_expression (identifier) (argument_list (my_declaration (variable)) (string) (variable)))))

==================
Regex branch reset and advanced patterns
==================
# @id: fuzz_tripwires.008
# @tags: indirect qw regex regex-code tripwire
# @perl: 5.8+
# @flags: lexer-sensitive tripwire


/^(?|(a)|(b))\1$/;
/(*PRUNE)(*SKIP)(*FAIL)/;
/(?&name)(?(DEFINE)(?<name>pattern))/;
/\K/;
/(?(?=lookahead)then|else)/;
/(?>atomic)/;

---

(source_file
  (expression_statement (regex))
  (expression_statement (regex))
  (expression_statement (regex))
  (expression_statement (regex))
  (expression_statement (regex))
  (expression_statement (regex)))
