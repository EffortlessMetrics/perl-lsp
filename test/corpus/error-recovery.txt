==================
Unclosed string
==================
# @id: error.string.unclosed.001  
# @tags: error string recovery
# @flags: error-node-expected

my $str = "unclosed string
print "next line";

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (string))))
  (expression_statement (call_expression (identifier) (string))))

==================
Unclosed regex
==================
# @id: error.regex.unclosed.001  
# @tags: error regex recovery
# @flags: error-node-expected lexer-sensitive

if ($x =~ /pattern) {
    print "matched";
}

---

(source_file
  (if_statement (parenthesized_expression (binary_expression (variable) (ERROR (regex)))) (block
    (expression_statement (call_expression (identifier) (string))))))

==================
Mismatched brackets
==================
# @id: error.brackets.001  
# @tags: error brackets recovery
# @flags: error-node-expected

my @array = (1, 2, 3];
my %hash = { a => 1, b => 2);
my $ref = [1, 2, 3};

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (list (number) (number) (number)))))
  (expression_statement (my_declaration (variable) (ERROR (hash_ref))))
  (expression_statement (my_declaration (variable) (ERROR (array_ref)))))

==================
Incomplete statement
==================
# @id: error.statement.incomplete.001  
# @tags: error statement recovery
# @flags: error-node-expected

my $x = 
print "hello";
if ($y == 
    print "condition incomplete";
}

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR)))
  (expression_statement (call_expression (identifier) (string)))
  (if_statement (parenthesized_expression (ERROR (binary_expression (variable)))) (block
    (expression_statement (call_expression (identifier) (string))))))

==================
Missing semicolons
==================
# @id: error.semicolon.001  
# @tags: error semicolon recovery
# @flags: error-node-expected

my $x = 5
my $y = 10
print $x + $y

---

(source_file
  (expression_statement (my_declaration (variable) (number)))
  (expression_statement (my_declaration (variable) (number)))
  (expression_statement (call_expression (identifier) (binary_expression (variable) (variable)))))

==================
Unclosed block
==================
# @id: error.block.unclosed.001  
# @tags: error block recovery
# @flags: error-node-expected

if ($condition) {
    print "inside";
    # missing closing brace

sub next_function {
    return 42;
}

---

(source_file
  (if_statement (parenthesized_expression (variable)) (ERROR (block
    (expression_statement (call_expression (identifier) (string)))
    (comment))))
  (subroutine_declaration (identifier) (block
    (return_statement (number)))))

==================
Invalid syntax mix
==================
# @id: error.syntax.mix.001  
# @tags: error syntax recovery
# @flags: error-node-expected

my $x = = 5;
print $x ++ -- ;
my @array = (1, , 3);

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (number))))
  (expression_statement (call_expression (identifier) (ERROR (postfix_expression (variable)))))
  (expression_statement (my_declaration (variable) (list (number) (ERROR) (number)))))

==================
Heredoc errors
==================
# @id: error.heredoc.001  
# @tags: error heredoc recovery
# @flags: error-node-expected lexer-sensitive

my $text = <<EOF
This heredoc is missing
its terminator

print "next statement";

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (heredoc))))
  (expression_statement (call_expression (identifier) (string))))

==================
Package and sub errors
==================
# @id: error.package.sub.001  
# @tags: error package subroutine recovery
# @flags: error-node-expected

package 
sub missing_name {
    return 1;
}

sub incomplete(

---

(source_file
  (ERROR (package_statement))
  (subroutine_declaration (identifier) (block
    (return_statement (number))))
  (ERROR (subroutine_declaration (identifier))))

==================
Operator precedence errors
==================
# @id: error.precedence.001  
# @tags: error operator precedence recovery
# @flags: error-node-expected

my $x = 5 + * 3;
my $y = not and $z;
my $a = $b | | $c;

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (binary_expression (number) (number)))))
  (expression_statement (my_declaration (variable) (ERROR (unary_expression (variable)))))
  (expression_statement (my_declaration (variable) (ERROR (binary_expression (variable) (variable))))))

==================
Quote operator errors
==================
# @id: error.quote.001  
# @tags: error quote-operators recovery
# @flags: error-node-expected

my $str = q(unclosed;
my @list = qw(a b c;
my $regex = qr/pattern;

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (string))))
  (expression_statement (my_declaration (variable) (ERROR (qw_list))))
  (expression_statement (my_declaration (variable) (ERROR (regex)))))

==================
Reference errors
==================
# @id: error.reference.001  
# @tags: error reference dereference recovery
# @flags: error-node-expected

my $ref = \;
my $deref = $$;
my @array = @$;
my %hash = %$;

---

(source_file
  (expression_statement (my_declaration (variable) (ERROR (reference))))
  (expression_statement (my_declaration (variable) (ERROR (scalar_deref))))
  (expression_statement (my_declaration (variable) (ERROR (array_deref))))
  (expression_statement (my_declaration (variable) (ERROR (hash_deref)))))

==================
Control flow errors
==================
# @id: error.control.001  
# @tags: error control-flow recovery
# @flags: error-node-expected

if {
    print "missing condition";
}

while () {
    last;
}

for (;;

---

(source_file
  (ERROR (if_statement (block
    (expression_statement (call_expression (identifier) (string))))))
  (while_statement (parenthesized_expression (ERROR)) (block
    (expression_statement (call_expression (identifier)))))
  (ERROR (for_statement)))