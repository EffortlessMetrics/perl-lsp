==================
Feature bundles
==================
# @id: feature.bundle.001  
# @tags: feature bundle version
# @perl: 5.10+

use feature ':5.10';
use feature ':5.38';
use feature qw(:5.36 unicode_strings);
no feature ':all';

---

(source_file
  (use_statement (identifier) (string))
  (use_statement (identifier) (string))
  (use_statement (identifier) (qw_list))
  (no_statement (identifier) (string)))

==================
Individual features
==================
# @id: feature.individual.001  
# @tags: feature state signatures say
# @perl: 5.10+

use feature 'say';
use feature 'state';
use feature 'signatures';
use feature qw(say state switch);
no feature 'switch';

---

(source_file
  (use_statement (identifier) (string))
  (use_statement (identifier) (string))
  (use_statement (identifier) (string))
  (use_statement (identifier) (qw_list))
  (no_statement (identifier) (string)))

==================
Experimental warnings
==================
# @id: experimental.warnings.001  
# @tags: experimental warnings signatures
# @perl: 5.20+
# @flags: experimental

no warnings 'experimental::signatures';
no warnings 'experimental::smartmatch';
no warnings 'experimental::refaliasing';
no warnings qw(experimental::signatures experimental::smartmatch);
use warnings 'experimental::signatures';

---

(source_file
  (no_statement (identifier) (string))
  (no_statement (identifier) (string))
  (no_statement (identifier) (string))
  (no_statement (identifier) (qw_list))
  (use_statement (identifier) (string)))

==================
Signatures with experimental
==================
# @id: experimental.signatures.001  
# @tags: experimental signatures subroutine
# @perl: 5.20+
# @flags: experimental

use feature 'signatures';
no warnings 'experimental::signatures';

sub add ($x, $y) {
    return $x + $y;
}

sub optional ($x, $y = 10) {
    return $x + $y;
}

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (subroutine_declaration (identifier) (signature (signature_parameter) (signature_parameter)) (block
    (return_statement (binary_expression (variable) (variable)))))
  (subroutine_declaration (identifier) (signature (signature_parameter) (signature_parameter (number))) (block
    (return_statement (binary_expression (variable) (variable))))))

==================
Refaliasing experimental
==================
# @id: experimental.refaliasing.001  
# @tags: experimental refaliasing references
# @perl: 5.22+
# @flags: experimental

use feature 'refaliasing';
no warnings 'experimental::refaliasing';

\my $x = \$y;
\my @a = \@b;
\my %h = \%g;

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (expression_statement (assignment_expression (reference (my_declaration (variable))) (reference (variable))))
  (expression_statement (assignment_expression (reference (my_declaration (variable))) (reference (variable))))
  (expression_statement (assignment_expression (reference (my_declaration (variable))) (reference (variable)))))

==================
Declared refs experimental
==================
# @id: experimental.declared_refs.001  
# @tags: experimental declared_refs references
# @perl: 5.26+
# @flags: experimental

use feature 'declared_refs';
no warnings 'experimental::declared_refs';

my \($x, $y) = \($a, $b);
my \@array = \@original;

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (expression_statement (my_declaration (reference (list (variable) (variable))) (reference (list (variable) (variable)))))
  (expression_statement (my_declaration (reference (variable)) (reference (variable)))))

==================
Postderef experimental
==================
# @id: experimental.postderef.001  
# @tags: experimental postderef dereference
# @perl: 5.20+
# @flags: experimental

use feature 'postderef';
no warnings 'experimental::postderef';

my @array = $ref->@*;
my %hash = $ref->%*;
my $scalar = $ref->$*;

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (expression_statement (my_declaration (variable) (postfix_dereference (variable))))
  (expression_statement (my_declaration (variable) (postfix_dereference (variable))))
  (expression_statement (my_declaration (variable) (postfix_dereference (variable)))))

==================
Lexical subs experimental
==================
# @id: experimental.lexical_subs.001  
# @tags: experimental lexical_subs my state
# @perl: 5.18+
# @flags: experimental

use feature 'lexical_subs';
no warnings 'experimental::lexical_subs';

my sub private { 
    return "private"; 
}

state sub cached {
    state $cache = {};
    return $cache;
}

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (my_subroutine_declaration (identifier) (block
    (return_statement (string))))
  (state_subroutine_declaration (identifier) (block
    (expression_statement (state_declaration (variable) (hash_ref)))
    (return_statement (variable)))))

==================
Try catch experimental
==================
# @id: experimental.try.001  
# @tags: experimental try catch finally
# @perl: 5.34+
# @flags: experimental

use feature 'try';
no warnings 'experimental::try';

try {
    dangerous();
} catch ($e) {
    warn "Error: $e";
} finally {
    cleanup();
}

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (try_catch_statement 
    (try_block (block (expression_statement (call_expression (identifier) (argument_list)))))
    (catch_block (variable) (block (expression_statement (call_expression (identifier) (string)))))
    (finally_block (block (expression_statement (call_expression (identifier) (argument_list)))))))

==================
Defer experimental
==================
# @id: experimental.defer.001  
# @tags: experimental defer cleanup
# @perl: 5.36+
# @flags: experimental

use feature 'defer';
no warnings 'experimental::defer';

sub process {
    open my $fh, '<', $file;
    defer { close $fh }
    
    return read_data($fh);
}

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (subroutine_declaration (identifier) (block
    (expression_statement (call_expression (identifier) (argument_list (my_declaration (variable)) (string) (variable))))
    (defer_statement (block (expression_statement (call_expression (identifier) (variable)))))
    (return_statement (call_expression (identifier) (argument_list (variable)))))))

==================
Class feature experimental
==================
# @id: experimental.class.001  
# @tags: experimental class method field
# @perl: 5.38+
# @flags: experimental

use feature 'class';
no warnings 'experimental::class';

class Point {
    field $x :param = 0;
    field $y :param = 0;
    
    method move ($dx, $dy) {
        $x += $dx;
        $y += $dy;
    }
}

---

(source_file
  (use_statement (identifier) (string))
  (no_statement (identifier) (string))
  (class_declaration (identifier) (block
    (field_declaration (variable) (attribute) (number))
    (field_declaration (variable) (attribute) (number))
    (method_declaration (identifier) (signature (signature_parameter) (signature_parameter)) (block
      (expression_statement (assignment_expression (variable) (variable)))
      (expression_statement (assignment_expression (variable) (variable))))))))

==================
Multiple experimental features
==================
# @id: experimental.multiple.001  
# @tags: experimental multiple combined
# @perl: 5.36+
# @flags: experimental

use feature qw(signatures try defer);
no warnings qw(
    experimental::signatures
    experimental::try
    experimental::defer
);

sub process ($data) {
    defer { log("done") }
    try {
        validate($data);
    } catch ($e) {
        die "Invalid: $e";
    }
}

---

(source_file
  (use_statement (identifier) (qw_list))
  (no_statement (identifier) (qw_list))
  (subroutine_declaration (identifier) (signature (signature_parameter)) (block
    (defer_statement (block (expression_statement (call_expression (identifier) (argument_list (string))))))
    (try_catch_statement 
      (try_block (block (expression_statement (call_expression (identifier) (argument_list (variable))))))
      (catch_block (variable) (block (expression_statement (call_expression (identifier) (string)))))))))